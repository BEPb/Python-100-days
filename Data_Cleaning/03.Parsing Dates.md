# Parsing Dates

### Настройте нашу среду
Первое, что нам нужно сделать, это загрузить библиотеки и набор данных, которые мы будем использовать. Мы будем 
работать с набором данных, содержащим информацию об оползнях, произошедших в период с 2007 по 2016 год. В следующем 
упражнении вы примените свои новые навыки к набору данных о землетрясениях по всему миру.  

```python
# modules we'll use
import pandas as pd
import numpy as np
import seaborn as sns
import datetime

# read in our data
landslides = pd.read_csv("../input/landslide-events/catalog.csv")

# set seed for reproducibility
np.random.seed(0)
```

### Проверьте тип данных нашего столбца даты
Начнем с рассмотрения первых пяти строк данных.

```python
landslides.head()
```
Мы будем работать со столбцом «дата» из фрейма данных оползней. Давайте удостоверимся, что он действительно выглядит 
так, как будто он содержит даты. 

```python
# print the first few rows of the date column
print(landslides['date'].head())
```
Да, это даты! Но то, что я, человек, могу сказать, что это даты, не означает, что Python знает, что это даты. 
Обратите внимание, что в нижней части вывода head() вы можете видеть, что тип данных этого столбца — «объект».  

Pandas использует dtype «объект» для хранения различных типов данных, но чаще всего, когда вы видите столбец с 
«объектом» dtype, в нем будут строки. 

Если вы проверите здесь документацию по dtype для pandas, вы заметите, что есть также определенные dtypes datetime64.
Поскольку dtype нашего столбца — объект, а не datetime64, мы можем сказать, что Python не знает, что этот столбец 
содержит даты.  

Мы также можем посмотреть только dtype столбца, не печатая первые несколько строк: 

```python
# check the data type of our date column
landslides['date'].dtype
```
Возможно, вам придется проверить документацию numpy, чтобы сопоставить буквенный код с dtype объекта. «О» — это код 
«объекта», поэтому мы видим, что эти два метода дают нам одну и ту же информацию.  

### Преобразуйте наши столбцы даты в дату и время
Теперь, когда мы знаем, что наш столбец даты не распознается как дата, пришло время преобразовать его, чтобы он 
распознавался как дата. Это называется «разбор дат», потому что мы берем строку и идентифицируем ее составные части. 

Мы можем определить формат наших дат с помощью руководства под названием «директива strftime», дополнительную 
информацию о котором вы можете найти по этой ссылке. Основная идея заключается в том, что вам нужно указать, где 
какие части даты и какие знаки препинания стоят между ними. Существует множество возможных частей даты, но наиболее 
распространенными являются %d для дня, %m для месяца, %y для двухзначного года и %Y для четырехзначного года.

Некоторые примеры:

- 17.01.07 имеет формат "%m/%d/%y"
- 17-1-2007 имеет формат "%d-%m-%Y"
Возвращаясь к заголовку столбца «дата» в наборе данных о оползнях, мы видим, что он имеет формат 
«месяц/день/двузначный год», поэтому мы можем использовать тот же синтаксис, что и в первом примере, для анализа в 
наши даты:  

```python
# create a new column, date_parsed, with the parsed dates
landslides['date_parsed'] = pd.to_datetime(landslides['date'], format="%m/%d/%y")
```
Теперь, когда я проверяю первые несколько строк нового столбца, я вижу, что dtype — это datetime64. Я также вижу, 
что мои даты были немного переставлены, чтобы они соответствовали объектам даты и времени порядка по умолчанию 
(год-месяц-день).  

```python
# print the first few rows
landslides['date_parsed'].head()
```
Теперь, когда наши даты проанализированы правильно, мы можем взаимодействовать с ними полезными способами.

Что, если я столкнусь с ошибкой с несколькими форматами даты? Пока мы указываем формат даты здесь, иногда вы 
столкнетесь с ошибкой, когда в одном столбце будет несколько форматов даты. Если это произойдет, вы можете попросить 
панд сделать вывод о том, каким должен быть правильный формат даты. Вы можете сделать это так:  

```python
landslides['date_parsed'] = pd.to_datetime(landslides['Date'], infer_datetime_format=True)
```

Почему вы всегда не используете infer_datetime_format = True? Есть две большие причины, по которым панды не всегда 
угадывают формат времени. Во-первых, панды не всегда могут определить правильный формат даты, особенно если кто-то 
проявил творческий подход к вводу данных. Во-вторых, это намного медленнее, чем указание точного формата дат.  

### Выберите день месяца
Теперь, когда у нас есть столбец проанализированных дат, мы можем извлечь такую информацию, как день месяца, когда 
произошел оползень. 
```python
# get the day of the month from the date_parsed column
day_of_month_landslides = landslides['date_parsed'].dt.day
day_of_month_landslides.head()
```
Если бы мы попытались получить ту же информацию из исходного столбца «дата», мы бы получили ошибку: AttributeError: 
Можно использовать только метод доступа .dt со значениями, подобными дате и времени. Это связано с тем, что dt.day 
не знает, как обращаться со столбцом с «объектом» dtype. Несмотря на то, что в нашем фрейме данных есть даты, мы 
должны проанализировать их, прежде чем сможем взаимодействовать с ними полезным способом.

### Постройте день месяца, чтобы проверить синтаксический анализ даты
Одна из самых больших опасностей при синтаксическом анализе дат — перепутать месяцы и дни. Функция to_datetime() 
имеет очень полезные сообщения об ошибках, но не помешает перепроверить, имеют ли смысл извлеченные нами дни месяца. 

Для этого построим гистограмму дней месяца. Мы ожидаем, что он будет иметь значения от 1 до 31 и, поскольку нет 
оснований предполагать, что в одни дни месяца оползни случаются чаще, чем в другие, относительно равномерное 
распределение. (С провалом на 31, потому что не во всех месяцах 31 день.) Давайте посмотрим, так ли это:  
```python
# remove na's
day_of_month_landslides = day_of_month_landslides.dropna()

# plot the day of the month
sns.distplot(day_of_month_landslides, kde=False, bins=31)
```

Да, похоже, мы правильно проанализировали наши даты, и этот график мне понятен.
