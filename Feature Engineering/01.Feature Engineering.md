Feature Engineering
###Добро пожаловать в Feature Engineering!
В этом курсе вы узнаете об одном из самых важных шагов на пути к созданию отличной модели машинного обучения: 
 разработке функций. Вы узнаете, как:

- определить, какие функции являются наиболее важными, с помощью взаимной информации
- изобретать новые возможности в нескольких реальных проблемных областях
- кодировать категории высокой мощности с целевой кодировкой
- создавать функции сегментации с помощью кластеризации k-средних
- разложить вариацию набора данных на функции с помощью анализа главных компонентов
 Практические упражнения составляют полную записную книжку, в которой используются все эти методы для подачи заявки  
  на участие в конкурсе «Начало работы с ценами на жилье». После прохождения этого курса у вас будет несколько идей, 
которые вы сможете использовать для дальнейшего повышения своей успеваемости.

###Цель разработки функций
Цель разработки функций - просто сделать ваши данные более подходящими для решения данной проблемы.

Рассмотрим такие показатели «кажущейся температуры», как индекс жары и охлаждение ветром. Эти величины пытаются 
измерить воспринимаемую людьми температуру на основе температуры воздуха, влажности и скорости ветра, которые мы 
можем измерить напрямую. Вы можете думать о кажущейся температуре как о результате своего рода разработки функций, 
попытки сделать наблюдаемые данные более актуальными для того, что нас действительно волнует: как на самом деле 
ощущается снаружи!

Вы можете выполнить проектирование функций, чтобы:

- улучшить прогнозную производительность модели
- уменьшить вычислительные потребности или потребности в данных
- улучшить интерпретируемость результатов

###Руководящий принцип проектирования функций
Чтобы функция была полезной, она должна иметь отношение к цели, которую ваша модель может изучить. Например, 
линейные модели могут изучать только линейные отношения. Итак, при использовании линейной модели ваша цель - 
преобразовать элементы, чтобы сделать их взаимосвязь с целевой линейной.

Ключевой идеей здесь является то, что преобразование, которое вы применяете к функции, становится, по сути, частью 
самой модели. Допустим, вы пытались предсказать цену квадратных участков земли по длине одной стороны. Подбор 
линейной модели непосредственно к длине дает плохие результаты: зависимость не является линейной.

Диаграмма рассеяния длины по оси x и цены по оси y, точки увеличиваются по кривой с наложенной плохо совпадающей 
 линией.
Линейная модель плохо подходит, если в качестве элемента используется только длина.
Если мы возведем в квадрат объект длины, чтобы получить «Площадь», мы создадим линейную зависимость. Добавление 
области к набору функций означает, что эта линейная модель теперь может соответствовать параболе. Другими словами, 
возведение объекта в квадрат дало линейной модели возможность соответствовать квадрату пространственных объектов.

Слева: область теперь на оси абсцисс. Точки увеличиваются линейно, с наложенной хорошо подходящей линией. Справа: 
длина по оси абсцисс. Точки увеличиваются по кривой, как и раньше, и накладывается хорошо подходящая кривая.
Слева: соответствие площади намного лучше. Справа: что также улучшает посадку по длине.
Это должно показать вам, почему можно так высоко окупить время, вложенное в разработку функций. Какие бы отношения 
ни усвоила ваша модель, вы можете обеспечить себя посредством преобразований. При разработке набора функций 
подумайте о том, какую информацию ваша модель могла бы использовать для достижения максимальной производительности.

###Пример - составы бетона
Чтобы проиллюстрировать эти идеи, мы увидим, как добавление нескольких синтетических функций в набор данных может 
улучшить прогнозную производительность модели случайного леса.

Набор данных Concrete содержит различные составы бетона и конечную прочность на сжатие продукта, которая является 
мерой того, какую нагрузку может выдержать этот вид бетона. Задача этого набора данных - предсказать прочность 
бетона на сжатие с учетом его формулировки.

```python
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_score

df = pd.read_csv("../input/fe-course-data/concrete.csv")
df.head()
```
Цементная пескоструйная печь Шлаковая зола Вода Суперпластификатор Грубый Агрегат Мелкий Агрегат Возраст Сжатость Прочность
0540,0 0,0 0,0 162,0 2,5 1040,0 676,0 28 79,99
1 540,0 0,0 0,0 162,0 2,5 1055,0 676,0 28 61,89
2 332,5 142,5 0,0 228,0 0,0 932,0 594,0 270 40,27
3 332,5 142,5 0,0 228,0 0,0 932,0 594,0 365 41,05
4 198,6 132,4 0,0 192,0 0,0 978,4 825,5 360 44,30


Здесь вы можете увидеть различные ингредиенты, входящие в состав каждой разновидности бетона. Через мгновение мы 
увидим, как добавление некоторых дополнительных синтетических функций, производных от них, может помочь модели 
изучить важные взаимосвязи между ними.

Сначала мы установим базовый уровень, обучив модель на нерасширенном наборе данных. Это поможет нам определить, 
действительно ли наши новые функции полезны.

Установление таких базовых показателей является хорошей практикой в начале процесса разработки функций. Базовая 
оценка может помочь вам решить, стоит ли сохранять ваши новые функции или вам следует отказаться от них и, 
возможно, попробовать что-то еще.
```python
X = df.copy()
y = X.pop("CompressiveStrength")

# Train and score baseline model
# Поезд и оценка базовой модели
baseline = RandomForestRegressor(criterion="mae", random_state=0)
baseline_score = cross_val_score(
    baseline, X, y, cv=5, scoring="neg_mean_absolute_error"
)
baseline_score = -1 * baseline_score.mean()

print(f"MAE Baseline Score: {baseline_score:.4}")
```
Базовый балл MAE: 8,232

Если вы когда-либо готовили дома, вы могли знать, что соотношение ингредиентов в рецепте обычно является лучшим 
показателем того, как получится рецепт, чем их абсолютное количество. Тогда мы могли бы предположить, что 
соотношение вышеперечисленных функций было бы хорошим предиктором CompressiveStrength.

В ячейке ниже в набор данных добавлены три новых соотношения.
```python
X = df.copy()
y = X.pop("CompressiveStrength")

# Create synthetic features
# Создание синтетических функций
X["FCRatio"] = X["FineAggregate"] / X["CoarseAggregate"]
X["AggCmtRatio"] = (X["CoarseAggregate"] + X["FineAggregate"]) / X["Cement"]
X["WtrCmtRatio"] = X["Water"] / X["Cement"]

# Train and score model on dataset with additional ratio features
# Обучайте и оценивайте модель в наборе данных с дополнительными функциями соотношения
model = RandomForestRegressor(criterion="mae", random_state=0)
score = cross_val_score(
    model, X, y, cv=5, scoring="neg_mean_absolute_error"
)
score = -1 * score.mean()

print(f"MAE Score with Ratio Features: {score:.4}")
```

Оценка MAE с характеристиками соотношения: 7,948


И, конечно же, производительность улучшилась! Это свидетельство того, что эти новые функции соотношения 
 предоставили модели важную информацию, которую она раньше не обнаруживала.

