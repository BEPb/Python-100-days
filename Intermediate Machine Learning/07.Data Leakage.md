###Data Leakage
В этом руководстве вы узнаете, что такое утечка данных и как ее предотвратить. Если вы не знаете, как это 
предотвратить, утечка будет происходить часто, и это испортит ваши модели незаметным и опасным образом. Итак, это 
одна из важнейших концепций для практикующих специалистов по данным.

### Вступление
Утечка данных (или утечка) происходит, когда ваши обучающие данные содержат информацию о цели, но аналогичные 
данные не будут доступны, когда модель используется для прогнозирования. Это приводит к высокой производительности 
обучающего набора (и, возможно, даже данных проверки), но модель будет плохо работать в производственной среде.

Другими словами, утечка заставляет модель выглядеть точной до тех пор, пока вы не начнете принимать решения с 
помощью модели, а затем модель становится очень неточной.

Существует два основных типа утечки: утечка на цель и загрязнение при тестировании поезда.

###Целевая утечка
Утечка цели  происходит, когда ваши предикторы включают данные, которые не будут доступны в то время, когда вы 
делаете прогнозы. Важно думать о целевой утечке с точки зрения времени или хронологического порядка, в котором 
данные  становятся доступными, а не только с точки зрения того, помогает ли функция делать хорошие прогнозы.

Пример  будет полезен. Представьте, что вы хотите предсказать, кто заболеет пневмонией. Несколько верхних строк 
необработанных данных выглядят так:

```
got_pneumonia возраст вес мужчина принял_антибиотик_медицин ...
Ложь 65100 Ложь Ложь ...
Неверно 72130 Верно Неверно ...
Верно 58100 Ложно Верно ...
```

После  пневмонии люди принимают антибиотики для выздоровления. Необработанные данные показывают сильную взаимосвязь 
между  этими столбцами, но take_antibiotic_medicine часто изменяется после определения значения got_pneumonia. Это 
целевая утечка.

Модель  увидит, что любой, у кого для take_antibiotic_medicine значение False, не болел пневмонией. Поскольку данные 
валидации  поступают из того же источника, что и данные обучения, шаблон будет повторяться при валидации, и модель 
будет  иметь отличные оценки валидации (или перекрестной валидации).

Но эта  модель будет очень неточной при последующем развертывании в реальном мире, потому что даже пациенты, которые 
заболеют  пневмонией, еще не получили антибиотики, когда нам нужно будет делать прогнозы об их будущем здоровье.

Чтобы  предотвратить утечку данных этого типа, следует исключить любую переменную, обновленную (или созданную) после 
достижения целевого значения.

###Загрязнение поезда-теста
Другой тип утечки возникает, когда вы не можете отличить данные обучения от данных проверки.

Напомним, что проверка предназначена для измерения того, как модель работает с данными, которые она раньше не рассматривала. Вы можете незаметно повредить этот процесс, если данные проверки влияют на поведение предварительной обработки. Иногда это называют заражением во время поездов.

Например, представьте, что перед вызовом train_test_split () выполняется предварительная обработка (например, установка импутера для пропущенных значений). Конечный результат? Ваша модель может получить хорошие оценки при проверке, что дает вам большую уверенность в ней, но будет плохо работать, когда вы развернете ее для принятия решений.

В конце концов, вы включили данные проверки или тестирования в то, как вы делаете прогнозы, поэтому они могут хорошо работать с этими конкретными данными, даже если они не могут быть обобщены на новые данные. Эта проблема становится еще более тонкой (и более опасной), когда вы выполняете более сложную разработку функций.

Если ваша проверка основана на простом разделении на поезд и тест, исключите данные проверки из любого типа подгонки, включая подгонку шагов предварительной обработки. Это проще, если вы используете конвейеры scikit-learn. При использовании перекрестной проверки еще более важно, чтобы вы выполняли предварительную обработку внутри конвейера!

###Пример
В этом примере вы узнаете один способ обнаружения и устранения целевой утечки.

Мы будем использовать набор данных о приложениях  для кредитных карт и пропустим базовый код настройки данных. 
Конечным результатом является то, что информация  о каждой заявке на выдачу кредитной карты хранится в DataFrame X. 
Мы будем использовать ее, чтобы предсказать, какие заявки были приняты в Серии y.
```python
import pandas as pd

# Read the data
data = pd.read_csv('../input/aer-credit-card-data/AER_credit_card_data.csv', 
                   true_values = ['yes'], false_values = ['no'])

# Select target
y = data.card

# Select predictors
X = data.drop(['card'], axis=1)

print("Number of rows in the dataset:", X.shape[0])
X.head()
```
```
Количество строк в наборе данных: 1319
отчеты возраст доход доля расходы владелец самозависимые иждивенцы месяцев действия основных карт
0 0 37,66667 4,5200 0,033270 124,983300 Верно Ложь 3 54 1 12
1 0 33,25000 2,4200 0,005217 9,854167 Ложь Ложь 3 34 1 13
2 0 33,66667 4,5000 0,004156 15,000000 Верно Неверно 4 58 1 5
3 0 30,50000 2,5400 0,065214 137,869200 Ложь Ложь 0 25 1 7
4 0 32,16667 9,7867 0,067051 546,503300 Истина Ложь 2 64 1 5
```


Поскольку  это небольшой набор данных, мы будем использовать перекрестную проверку, чтобы обеспечить точные 
измерения качества модели.
```python
from sklearn.pipeline import make_pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score

# Since there is no preprocessing, we don't need a pipeline (used anyway as best practice!)
# Поскольку нет предварительной обработки, нам не нужен конвейер (в любом случае используется как лучшая практика!)
my_pipeline = make_pipeline(RandomForestClassifier(n_estimators=100))
cv_scores = cross_val_score(my_pipeline, X, y, 
                            cv=5,
                            scoring='accuracy')

print("Cross-validation accuracy: %f" % cv_scores.mean())
```

Точность перекрестной проверки: 0,980292


По мере накопления опыта вы обнаружите, что очень редко можно найти модели, которые точны в 98% случаев. Это случается, но это достаточно необычно, чтобы мы должны более внимательно проверять данные на предмет утечки цели.

Вот сводка данных, которую вы также можете найти на вкладке данных:

- card: 1, если заявка на кредитную карту принята, 0, если нет
- отчеты: количество серьезных уничижительных отчетов.
- Возраст: Возраст n лет плюс двенадцатая часть года
- доход: Годовой доход (деленный на 10 000)
- доля: отношение ежемесячных расходов по кредитной карте к годовому доходу.
- Расходы: Средние ежемесячные расходы по кредитной карте.
- Владелец: 1, если владеет домом, 0, если сдает в аренду
- selfempl: 1, если работает не по найму, 0, если нет
- иждивенцы: 1 + количество иждивенцев
- месяцы: количество месяцев проживания по текущему адресу
- majorcards: количество основных кредитных карт.
- active: Количество активных кредитных счетов.
 
Некоторые переменные выглядят подозрительно. Например, означают ли расходы расходы по этой карте или по картам, 
  использованным до использования?

На этом этапе может оказаться очень полезным сравнение базовых данных:

```python
expenditures_cardholders = X.expenditure[y]
expenditures_noncardholders = X.expenditure[~y]

print('Fraction of those who did not receive a card and had no expenditures: %.2f' \
      %((expenditures_noncardholders == 0).mean()))
print('Fraction of those who received a card and had no expenditures: %.2f' \
      %(( expenditures_cardholders == 0).mean()))
```
Как показано выше, у всех, кто не получил карту, расходов не было, и только 2% из получивших карту не имели расходов. Неудивительно, что наша модель оказалась очень точной. Но это также, похоже, случай целевой утечки, когда расходы, вероятно, означают расходы на карту, на которую они подали заявку.

Поскольку доля частично определяется расходами, ее тоже следует исключить. Переменные active и majorcards немного менее понятны, но, судя по описанию, звучат тревожно. В большинстве ситуаций лучше перестраховаться, чем сожалеть, если вы не можете отследить людей, создавших данные, чтобы узнать больше.

Мы запустим модель без целевой утечки следующим образом:
```python
# Drop leaky predictors from dataset
# Удалите негерметичные предикторы из набора данных
potential_leaks = ['expenditure', 'share', 'active', 'majorcards']
X2 = X.drop(potential_leaks, axis=1)

# Evaluate the model with leaky predictors removed
# Оценить модель с удаленными негерметичными предикторами
cv_scores = cross_val_score(my_pipeline, X2, y, 
                            cv=5,
                            scoring='accuracy')

print("Cross-val accuracy: %f" % cv_scores.mean())
```

Перекрестная точность: 0,838510


Эта точность немного ниже, что может разочаровать. Однако мы можем ожидать, что она будет правильной примерно в 80% 
случаев при использовании в новых приложениях, тогда как модель с утечками, вероятно, будет работать намного хуже 
(несмотря на ее более высокий очевидный балл при перекрестной проверке).

###Заключение
Утечка данных может быть многомиллионной ошибкой во многих приложениях для обработки данных. Тщательное разделение данных обучения и валидации может предотвратить загрязнение тестовых поездов, а конвейеры могут помочь реализовать это разделение. Точно так же сочетание осторожности, здравого смысла и исследования данных может помочь определить целевую утечку.

Что дальше?
Это все еще может показаться абстрактным. Попробуйте продумать примеры в этом упражнении, чтобы развить свой навык 
определения целевой утечки и загрязнения во время тренировочного теста! 

































