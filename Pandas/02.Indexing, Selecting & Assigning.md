Indexing, Selecting & Assigning
### Индексирование, выбор и назначение

###Вступление¶
Выбор конкретных значений pandas DataFrame или Series для работы является неявным шагом практически в любой операции 
с данными, которую вы выполняете, поэтому одна из первых вещей, которую вам нужно узнать при работе с данными в 
Python, - это то, как выбрать данные. пункты, имеющие отношение к вам, быстро и эффективно. 

```python
import pandas as pd
reviews = pd.read_csv("../input/wine-reviews/winemag-data-130k-v2.csv", index_col=0)
pd.set_option('max_rows', 5)
```
###Родные аксессуары
Собственные объекты Python предоставляют хорошие способы индексирования данных. Pandas несет в себе все это, что помогает легко начать работу.

Рассмотрим этот DataFrame:
```python
reviews
```
В Python мы можем получить доступ к свойству объекта, обращаясь к нему как к атрибуту. Например, объект книги может 
иметь свойство title, к которому мы можем получить доступ, вызвав book.title. Столбцы в DataFrame pandas работают 
примерно так же.

Следовательно, чтобы получить доступ к свойству отзывов о стране, мы можем использовать:
```python
reviews.country
```
Если у нас есть словарь Python, мы можем получить доступ к его значениям с помощью оператора индексации ([ ]). Мы 
можем сделать то же самое со столбцами в DataFrame:

```python
reviews['country']
```
Это два способа выбора определенной серии  из DataFrame. Ни один из них не является более или менее синтаксически 
правильным, чем другой, но оператор  индексации [ ] имеет то преимущество, что он может обрабатывать имена столбцов 
с зарезервированными символами в них  (например, если бы у нас был столбец с указанием страны, reviews.country 
provnce не будет работать).

Разве серия «Панды» не похожа на  причудливый словарь? В значительной степени это так, поэтому неудивительно, что 
для перехода к одному конкретному значению нам нужно всего лишь еще раз использовать оператор индексации []:

```python
reviews['country'][0]
```
###Индексирование в пандах
Оператор индексации и выбор атрибутов удобны, потому что они работают так же, как и в остальной части экосистемы 
Python. Новичку их легко подобрать и использовать. Однако у pandas есть свои собственные операторы доступа, loc и 
iloc. Для более сложных операций вы должны использовать именно их.

Выбор на основе индекса
Индексирование Pandas работает в одной из двух парадигм. Первый - выбор на основе индекса: выбор данных на основе 
их числового положения в данных. iloc следует этой парадигме.

Чтобы выбрать первую строку данных в DataFrame, мы можем использовать следующее:
```python
reviews.iloc[0]
```
И loc, и iloc - сначала строка, а вторая - столбец. Это противоположно тому, что мы делаем в «родном» Python: 
сначала столбец, а второй ряд.

Это означает, что получить строки немного легче, а столбцы - немного сложнее. Чтобы получить все записи в столбец с 
iloc, мы можем сделать следующее:

```python
reviews.iloc[:, 0]
```
Сам по себе оператор:, также родом из Python, означает «все». Однако в сочетании с другими селекторами его можно 
использовать для указания диапазона значений. Например, чтобы выбрать столбец страны только из первой,  второй и 
третьей строки, мы должны сделать: 
```python
reviews.iloc[:3, 0]
```
Или, чтобы выбрать только вторую и третью записи, мы бы сделали:
```python
reviews.iloc[1:3, 0]
```
Также можно передать список:
```python
reviews.iloc[[0, 1, 2], 0]
```
Наконец, стоит знать, что при выборе можно использовать отрицательные числа. Это начнет отсчет вперед с конца 
 значений. Так, например, вот последние пять элементов набора данных.
```python
reviews.iloc[-5:]
```
###Выбор на основе ярлыка
Вторая парадигма для выбора атрибута - это парадигма, за которой следует оператор loc: выбор на основе меток. В этой парадигме имеет значение значение индекса данных, а не его позиция.

Например, чтобы получить первую запись в обзорах, теперь мы должны сделать следующее:
```python
reviews.loc[0, 'country']
```
iloc концептуально проще, чем loc, потому что он игнорирует индексы набора данных. Когда мы используем iloc, мы 
 обрабатываем набор данных как большую матрицу (список списков), которую мы должны индексировать по позиции. loc, 
напротив, использует информацию из индексов для выполнения своей работы. Поскольку ваш набор данных обычно имеет 
значимые индексы, обычно проще делать что-то, используя вместо него loc. Например, вот одну операцию, которую 
намного проще использовать с помощью loc:
```python
reviews.loc[:, ['taster_name', 'taster_twitter_handle', 'points']]
```
###Выбор между loc и iloc
При выборе loc и iloc или переходе между ними следует иметь в виду одну "ловушку", а именно то, что эти два метода 
используют несколько разные схемы индексации.

iloc использует схему индексации Python stdlib, где первый элемент диапазона включен, а последний исключен. Таким 
образом, 0:10 выберет записи 0, ..., 9. loc, тем временем, индексы включительно. Таким образом, 0:10 выберет записи 
0, ..., 10.

Почему изменение? Помните, что loc может индексировать любой тип stdlib: например, строки. Если у нас есть 
 DataFrame со значениями индекса Яблоки, ..., Картофель, ..., и мы хотим выбрать «все варианты фруктов в алфавитном 
порядке между Яблоками и Картофелем», то намного удобнее проиндексировать df.loc [' Яблоки ':' Картофель '], чем 
 индексировать что-то вроде df.loc ['Apples', 'Potatoet'] (t идет после s в алфавите).

Это особенно сбивает с толку, когда индекс DataFrame представляет собой простой числовой список, например 0, ..., 
1000. В этом случае df.iloc [0: 1000] вернет 1000 записей, а df.loc [0: 1000] вернет 1001 из них! Чтобы получить 
1000 элементов с помощью loc, вам нужно будет опуститься на один ниже и запросить df.loc [0: 999].

В остальном семантика использования loc такая же, как у iloc.
### Управление индексом¶
Выбор на основе меток зависит от меток в индексе. Важно отметить, что используемый нами индекс не является 
неизменным. Мы можем манипулировать индексом так, как сочтем нужным.

Для выполнения этой работы можно использовать метод set_index (). Вот что происходит, когда мы устанавливаем_index 
в поле заголовка:
```python
reviews.set_index("title")
```
Это полезно, если вы можете придумать индекс для набора данных, который лучше текущего.

###Условный выбор
До сих пор мы индексировали данные на разных этапах, используя структурные свойства самого DataFrame. Однако, чтобы 
делать интересные вещи с данными, нам часто нужно задавать вопросы, основанные на условиях.

Например, предположим, что нас интересуют вина лучше среднего, произведенные в Италии.

Мы можем начать с проверки, является ли каждое вино итальянским или нет:
```python
reviews.country == 'Italy'
```
Эта операция произвела серию логических значений True / False в зависимости от страны каждой записи. Затем этот 
результат можно использовать внутри loc для выбора соответствующих данных:
```python
reviews.loc[reviews.country == 'Italy']
```
Этот DataFrame имеет ~ 20 000 строк. В оригинале было ~ 130 000. Это означает, что около 15% вин происходит из Италии.

Мы также хотели знать, какие из них лучше среднего. Вина оцениваются по шкале от 80 до 100, поэтому это может 
означать вина, набравшие не менее 90 баллов.

Мы можем использовать амперсанд (&), чтобы соединить два вопроса:
```python
reviews.loc[(reviews.country == 'Italy') & (reviews.points >= 90)]
```
Предположим, мы купим любое вино, произведенное в Италии или имеющее рейтинг выше среднего. Для этого мы используем 
вертикальную черту (|):
```python
reviews.loc[(reviews.country == 'Italy') | (reviews.points >= 90)]
```
Pandas поставляется с несколькими встроенными условными селекторами, два из которых мы выделим здесь.

Первый isin. isin позволяет выбирать данные, значение которых находится в списке значений. Например, вот как с его 
помощью мы можем выбирать вина только из Италии или Франции:
```python
reviews.loc[reviews.country.isin(['Italy', 'France'])]
```
Второе значение равно нулю (и его компаньон не равен нулю). Эти методы позволяют выделить значения, которые 
являются (или не являются) пустыми (NaN). Например, чтобы отфильтровать вина без ценника в наборе данных, мы бы 
сделали следующее:
```python
reviews.loc[reviews.price.notnull()]
```
###Назначение данных
Иначе говоря, назначить данные DataFrame очень просто. Вы можете присвоить либо постоянное значение:
```python
reviews['critic'] = 'everyone'
reviews['critic']
```
Или с итерацией значений:
```python
reviews['index_backwards'] = range(len(reviews), 0, -1)
reviews['index_backwards']
```

###Вступление
В этом наборе упражнений мы будем работать с набором данных Wine Reviews.
Запустите следующую ячейку, чтобы загрузить свои данные и некоторые служебные функции (включая код для проверки 
ваших ответов).
```python
import pandas as pd

reviews = pd.read_csv("../input/wine-reviews/winemag-data-130k-v2.csv", index_col=0)
pd.set_option("display.max_rows", 5)

from learntools.core import binder; binder.bind(globals())
from learntools.pandas.indexing_selecting_and_assigning import *
print("Setup complete.")
```
```python
reviews.head()
```
###Упражнения
добавить Codeadd Markdown
1. Выберите столбец описания из обзоров и присвойте результат переменной desc.
```python
# Your code here
desc = reviews.description

# Check your answer
q1.check()
```
2. Выберите первое значение из столбца описания отзывов, присвоив его переменной first_description.
```python
first_description = reviews.description.iloc[0]
```
3. Выберите первую строку данных (первую запись) из обзоров, присвоив ее переменной first_row.
```python
first_row = reviews.iloc[0]
```
Выберите первые 10 значений из столбца описания в обзорах, присвоив результат переменной first_descriptions.

Подсказка: отформатируйте вывод как серию панд.
```python
first_descriptions = reviews.description.iloc[:10]
```
5. Выберите записи с индексными метками 1, 2, 3, 5 и 8, присвоив результат переменной sample_reviews.

Другими словами, сгенерируйте следующий DataFrame:
```python
indices = [1, 2, 3, 5, 8]
sample_reviews = reviews.loc[indices]
```
6. Создайте переменную df, содержащую столбцы страны, провинции, региона_1 и региона_2 записей с индексными метками 
0, 1, 10 и 100. Другими словами, сгенерируйте следующий фрейм данных:
```python
cols = ['country', 'province', 'region_1', 'region_2']
indices = [0, 1, 10, 100]
df = reviews.loc[indices, cols]
```
7. Создайте переменную df, содержащую столбцы страны и сорта из первых 100 записей.

Подсказка: вы можете использовать loc или iloc. Работая над ответом на этот и несколько следующих вопросов, 
придерживайтесь следующих замечаний, описанных в руководстве:

iloc использует схему индексации Python stdlib, где первый элемент диапазона включен, а последний исключен. loc, 
тем временем, индексы включительно.

Это особенно сбивает с толку, когда индекс DataFrame представляет собой простой числовой список, например 0, ..., 
1000. В этом случае df.iloc [0: 1000] вернет 1000 записей, а df.loc [0: 1000] вернет 1001 из них! Чтобы получить  
1000 элементов с помощью loc, вам нужно будет опуститься на один ниже и запросить df.iloc [0: 999].
```python
cols = ['country', 'variety']
df = reviews.loc[:99, cols]
# или
# cols_idx = [0, 11]
# df = reviews.iloc[:100, cols_idx]
```
8. Создайте DataFrame italian_wines, содержащий обзоры вин, произведенных в Италии. Подсказка: что равно reviews.
country? 
```python
italian_wines = reviews[reviews.country == 'Italy']
```
9. Создайте DataFrame top_oceania_wines, содержащий все отзывы с не менее 95 баллами (из 100) для вин из Австралии или 
Новой Зеландии. 
```python
top_oceania_wines = reviews.loc[
    (reviews.country.isin(['Australia', 'New Zealand']))
    & (reviews.points >= 95)
]
```




