## Программная логика

После изучения предыдущих глав, я думаю, вам необходимо выполнить несколько упражнений, чтобы закрепить знания, 
которые вы узнали раньше. Хотя то, что мы узнали до сих пор, является лишь верхушкой айсберга Python, этого 
содержания для нас достаточно что бы строить программы в логике. Для новичков в языках программирования после 
изучения основных языковых элементов Python (переменных, типов, операторов, выражений, структур ветвлений, структур 
циклов и т. д.) Необходимо попытаться использовать то, что мы узнали. Другими словами, нужна только тренировка вашей 
способности переводить алгоритмы (методы и шаги для решения проблем), описанные на человеческом естественном языке, в код 
Python, и это должно быть достигнуто путем большой практики.

В этой главе собраны для вас несколько классических случаев и упражнений. Надеюсь, что эти примеры помогут 
вам закрепить ранее полученные знания Python, а с другой стороны, помогут понять, как построить логику в программе 
и как использовать простые алгоритмы, решать реальные проблемы.

### Классический пример

1. Ищите количество нарциссов

   > Объяснение : Число нарциссов также по другому называется инвариантным суперполным числом, или числом 
   > собственной силы, а также еще его называют числом Армстронга. Нарциссическое число - это трехзначное число, и 
   > равно сумме кубов каждой цифры числа. Например: 
   > число 153
   > (1 в кубе) + (5 в кубе) + (3 в кубе) = 153
   > 1 ^ 3 + 5 ^ 3 + 3 ^ 3 = 153
   > 1 + 125 + 27 = 153
   
```Python
"""
Python 3.9 Найдите количество всех нарциссов

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""

for num in range(100, 1000):  # перебираем все числа от 100 до 1000
       low = num % 10  # Выделяем последнию цифру в трехзначном числе за счет деления по модулю
       mid = num // 10 % 10  # Выделяем среднию цифру в трехзначном числе за счет деления без остатка
       high = num // 100  # Выделяем первую цифру в трехзначном числе за счет деления без остатка
       if num == low ** 3 + mid ** 3 + high ** 3:  # проверяем условие (сумма кубов всех чисел = исходному числу)
           print(num)  # если равно, то печатаем это число
   ```

  В приведенном выше коде мы нашли единицы, десятки и сотни трехзначного числа с помощью операций деления по 
  модулю и деления без остатка. Этот небольшой трюк до сих пор широко используется в реальных разработках. Аналогичным 
  образом мы также можем обратить положительное целое число, например: изменить число 12345 на 54321, код будет 
  следующим.
   ```Python
"""
Python 3.9 Найдите количество всех нарциссов

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""
   
   num = int(input('num = '))  # вводим число
   reversed_num = 0  # создаем переменную и задаем начальное значение равное нулю
   while num > 0:  # пока исходное число больше нуля
       reversed_num = reversed_num * 10 + num % 10  # формируем нашу переменную по одному числу начиная с конца 
       # исходного числа, за счет деления по модулю, в дальнеших шагах сдвигается в лево за счет умножение на 10
       num //= 10  # исходное число делим на 10 без остатка, отбрасывая последнию цифру на следующем ходу
   print(reversed_num)  # после окончания цикла выводим результат
   ```

3. Проблема сотни денег и ста цыплят 

   > Пояснение : Сотня денег и сотня цыплят - это математическая задача, поставленная древним китайским математиком 
   > Чжан Цюцзянь в книге «Математика». Итак условие задачи: петух стоит пять рублей, курица стоит три рубля, а за 
   > один рубль можно купить трех цыплят. Купите сотню кур (цыплят, петухов) за сотню рублей и дайте ответ, сколько 
   > цыплят, куриц и петухов можно купить за 100 рублей без осттатка?
   
```Python
"""
Python 3.9 Сотня денег и сотня цыплят
Название файла '02.сотня_цыплят.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""

# x - переменная обозначающая число петухов
# y - переменная обозначающая число куриц
# z - переменная обозначающая число цыплят

for x in range(0, 20):  # за 100-ню можно купить не более 20 петухов, т.о. устанавливаем диапазон от 0 до 20 петухов
    for y in range(0, 33):  # за 100-ню можно купить не более 33 куриц
        z = 100 - x - y  # количество цыплят будет равно остатку от сотни (за вычетом петухов и куриц)
        if 5 * x + 3 * y + z / 3 == 100:  # если условие выполняется, то мы нашли решение
            print('Итого: %d петухов,  %d куриц,  %d цыплят' % (x, y, z))  # выводим ответ
   ```

   Метод , используемый выше, называется исчерпывающим методом , также известный как метод поиска перебора. Этот 
   метод перебирает все возможные варианты в альтернативных решениях по одному и проверяет, соответствует ли каждому 
   варианту описания задачи, и , наконец , получить решение. Этот метод кажется неуклюжим, но для компьютеров с 
   очень мощной вычислительной способностью он является даже очень хорошим выбором, и если решение проблемы 
   существует, этот метод должен быть в состоянии его найти.

4. CRAPS азартная игра 

   > Описание : CRAPS, также известный как Craps, - очень популярная настольная азартная игра в Лас-Вегасе, США. В 
   > игре используются два кубика, и игрок набирает очки, бросая два кубика для участия в игре. Простое правило: 
   > если игрок  бросает кости, и набирает 7 или 11 очков, то игрок выигрывает; если игрок бросает кости, и 
   > набирает 2 очка, 3 очка или 12 очков, то побеждает крупье. Игрок продолжает бросать кости до тех пор, пока не 
   > будет определен победитель.

```Python
"""
Python 3.9 Игра в кости CRAPS
Название файла '03.игра_в_кости.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""

from random import randint  # подключаем модуль генерации случайных чисел

money = 1000  # исходная сумма денег игрока
while money > 0:  # игра продолжается пока у игрока есть деньги
       print('Ваши общие активы равны:', money, ' рублей')  # информация сколько денег есть у игрока
       needs_go_on = False
       while True:  # задаем бесконечный цикл
           debt = int(input('Пожалуйста делайте Вашу ставку: '))  # приглашение ввести ставку для игры
           if 0 < debt <= money:  # проверка на то что вводимая ставка не превышает имеющейся суммы денег и больше нуля
               break  # если условие выполняется, то прерываем цикл (выходим из него)
# имитируем этап бросания костей (каждая кость может выпасть от одного до шести очков)
       first = randint(1, 6) + randint(1, 6)  # итоговая сумма двух генерируемых чисел от одного до 6
       print('Игрок вытряхивает % d очков' % first)
       if first == 7 or first == 11:  # если количество полученных очков = 7 или 11
           print('Игрок выигрывает!')
           money += debt  # к исходной сумме игрока добовляется сумма ставки
       elif first == 2 or first == 3 or first == 12:  # если количество полученных очков = 2, 3 или 12
           print('Банк выигрывает, Вы проигали эту ставку!')
           money -= debt  # от исходной суммы денег игрока отнимаем сумму ставки
       else:  # в других случаях
           needs_go_on = True  # переменной "нужно перебросить кости" присваиваем значение True (ИСТИНА)
       while needs_go_on:  # пока значение переменной "нужно перебросить кости"  = True (ИСТИНА)
           needs_go_on = False  # переменной "нужно перебросить кости" присваиваем значение False (ЛОЖЬ)
           # имитируем этап бросания костей (каждая кость может выпасть от одного до шести очков)
           first = randint(1, 6) + randint(1, 6)  # итоговая сумма двух генерируемых чисел от одного до 6
           print('Игрок вытряхивает % d очков' % first)
           if first == 7 or first == 11:  # если количество полученных очков = 7 или 11
               print('Игрок выигрывает!')
               money += debt  # к исходной сумме игрока добовляется сумма ставки
           elif first == 2 or first == 3 or first == 12:  # если количество полученных очков = 2, 3 или 12
               print('Банк выигрывает, Вы проигали эту ставку!')
               money -= debt  # от исходной суммы денег игрока отнимаем сумму ставки
           else:  # в других случаях
               needs_go_on = True  # переменной "нужно перебросить кости" присваиваем значение True (ИСТИНА)
print('Вы банкрот, игра окончена!')
```

### Полезные упражнения 

1. Сгенерируйте первые 20 чисел последовательности Фибоначчи .

   > Пояснение : Последовательность Фибоначчи (последовательность Фибоначчи), также известная как 
   > последовательность золотого сечения, - это итальянский математик Леонардо Фибоначчи (Leonardoda Fibonacci) он 
   > же Леонардо Пизанский (по месту его проживания), 
   > предложивший свою последовательность в «Книге вычислений», в шутку это последовательность еще называют «кроличьей 
   > последовательностью». Характеристика последовательности Фибоначчи состоит в том, что первые два числа 
   > последовательности равны 0 и 1, и начиная с третьего числа, каждое число представляет собой сумму двух предыдущих 
   > чисел в форме: 0 и 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, .... иногда ноль опускают в этом ряду.
   > Последовательность Фибоначчи имеет прямое применение в современной физике, квазикристаллической структуре, 
   > химии и других областях.


```Python
"""
Python 3.9 Сгенерируйте первые 20 чисел последовательности Фибоначчи
1 1 2 3 5 8 13 21 ...
Название файла '04.Фибоначчи.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""

a = 0  # задаем значение первого числа
b = 1  # задаем значение второго числа

print(a, end=' ')  # выводим значение первого числа, до его изменения, остаемся на этой строке

for _ in range(20):  # цикл в 20 ходов, для 20 чисел последовательности Фибоначчи
    a, b = b, a + b  # переопределяем переменные, теперь а = b, b = a + b
    print(a, end=' ')  # выводим новое значение переменной а, остаемся на этой строке

```
   
2. Найдите идеальное число в пределах 10 000

   > Объяснение : Совершенное число также называется полным числом - это натуральное число, равное сумме всех своих 
   > собственных делителей (т.е. всех положительных делителей, отличных от самого числа). 
   > Например: число 6 (6 = 1 + 2 + 3) и 28 (28 = 1 + 2 + 4 + 7 + 14) - идеальные числа. 
   > Совершенные числа обладают множеством магических характеристик, и желающие могут узнать о них самостоятельно.
   
```Python
"""
Python 3.9 Идеальное число
Название файла '04.Фибоначчи.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""
import math  # подключаем модуль для математических операций

for num in range(1, 10000):  # перебираем все числа от 1 до 10 000
    result = 0  # создаем переменную равную нулю

    for factor in range(1, int(math.sqrt(num)) + 1):  # перебираем все числа от 1 до (корень квадратный 10 000) + 1
        if num % factor == 0: # если число разделенное по модуллю равно нулю, т.е. делится без остатка, т.о. мы нашли собственный делитель
            result += factor  # находим сумму всех собственных делителей
            if factor > 1 and num // factor != factor:  # если собственный делитель больше одного и не равен самому себе
                result += num // factor  # добовляем к результату число - результат делние без остатка
    if result == num:  # если сумма всех делителей равна исходному числу, 
        print(num)  # то выводим результат
```
3. Выведите все простые числа в пределах 100 .

   > Примечание : простое число относится к положительному целому числу (не включая 1), которое может делиться 
   > только на 1 и само себя.
```Python
"""
простое число от 2 до 99
Название файла '06.простое_число.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-05
"""

import math  # подключаем модуль для математических операций

for num in range(2, 100):  # перебираем все числа от 2 до 100
    is_prime = True  # создаем переменную равную истине
    for factor in range(2, int(math.sqrt(num)) + 1):  # перебираем все числа от 2 до (корень квадратный 100) + 1
        if num % factor == 0:  # если число разделенное по модуллю равно нулю, т.е. делится без остатка, 
            # т.о. мы нашли собственный делитель
            is_prime = False  # меняем переменную равную истине на ложь
            break  # прерываем выполнение этого цикла
    if is_prime:  # если цикл выполнен полностью, т.о. не найдено число каторое делится только само на себя
        print(num, end=' ')  # выводим результат, остаемся на этой строке
```
