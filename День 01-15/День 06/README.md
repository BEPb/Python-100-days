[Вернуться на главную](https://github.com/BEPb/Python-100-days)


## Использование функций и модулей

Мастер программирования г-н Мартин Фаулер однажды сказал: «У кода много неприятных запахов, и повторение - худший из 
них! » Чтобы написать высококачественный код, первое, что нужно решить - это проблему повторяющегося кода. Общий код 
выделяем в функцию, где нам нужно использовать общий код, нам нужно только «вызвать» эту «функцию».

Функции в Python выполняют важную роль в организации кода и повышении его читаемости, однородности и переиспользуемости.


Основные цели функций в Python:
- Упрощение кода и повторное использование: Функции позволяют группировать код, который выполняет конкретную задачу, 
и повторно использовать его с разными аргументами.
- Улучшение структуры кода: Функции помогают организовать код в логически связанные группы. Это делает код более понятным и легким для поддержки.
- Улучшение общей читаемости: Функции позволяют выделить логические блоки кода и повысить читаемость. Например, если вы используете функцию add_numbers, без просмотра кода можно понять, что функция складывает числа.
- Улучшение тестирования: Функции упрощают тестирование кода, так как каждая функция может быть протестирована отдельно.
- Улучшение производительности: Функции могут быть скомпилированы, что обычно делает их более быстрыми чем 
нескомпилированный код. 

### Определить функцию

В Python функции определяются с помощью ключевого слова ``def``, за которым следует имя функции, список параметров в 
круглых скобках и двоеточие. Затем следует блок кода, который выполняется при вызове функции. В конце функции всегда 
рекомендуется использовать ключевое слово ``return``, чтобы вернуть значение из функции.  Как и переменные, каждая  
функция имеет 
 звучное имя, а правила именования согласуются с правилами именования переменных. Параметры, передаваемые в функцию,
 можно поместить в круглые скобки после имени функции. Это очень похоже на математическую функцию. Параметры 
 функции в программе эквивалентны аргументу функции в математике, а после результат функции, мы можем вернуть в 
 общий код при помощи команды ``return``. Возврат значения через ключевое слово эквивалентно зависимой переменной 
 функции в математике.

Пример структуры функции:
```python
def my_function(param1, param2):
    # тело функции, в котором происходят необходимые операции
    result = param1 + param2
    return result

# def - ключевое слово, которым начинается определение функции
# my_function - имя функции
# (param1, param2) - список параметров, передаваемых в функцию
# : - двоеточие, обозначающее начало тела функции
# result = param1 + param2 - код, который выполняется при вызове функции и сохраняет результат в переменную result
# return result - ключевое слово, возвращающее значение из функции

# ниже применим нашу функцию, меняя только аргументы функции
print(my_function(2, 3))  # Получим результат 5
print(my_function(12, 5))  # Получим результат 17
print(my_function(0, 3))  # Получим результат 3
```

Поняв, как определить функцию, мы можем провести рефакторинг любого кода. Так называемый рефакторинг заключается в 
корректировке структуры кода без влияния на результат выполнения кода. 

### Вызов функции - встроенные функции Python / импорт модулей и функций
Для вызова встроенных функций Python необходимо просто написать их название и передать необходимые аргументы в 
скобках. Например: 

```python
print("Hello, World!")
```

Для импорта модулей и функций используется ключевое слово `import`. Например, для импорта функции `sqrt` из модуля 
`math` нужно написать: 

```python
import math

x = math.sqrt(25)
print(x)
```

Если нужно импортировать только определенную функцию из модуля, можно использовать следующий синтаксис:

```python
from module_name import function_name

x = function_name(arg1, arg2)
```

Например:

```python
from math import sqrt

x = sqrt(25)
print(x)
```

### Возвращаемое значение функции - нет возвращаемого значения / вернуть одно значение / вернуть несколько значений Python

В Python функция может возвращать нет, одно или несколько значений. 

1. Если функция не должна возвращать значение, то используется ключевое слово `None`. Например:

```python
def say_hello():
    print("Hello!")

result = say_hello() # Вызов функции say_hello
print(result) # Output: None
```

2. Чтобы вернуть одно значение из функции, используется ключевое слово `return`. Например:

```python
def add_numbers(x, y):
    return x + y

result = add_numbers(2, 3) # Вызов функции add_numbers
print(result) # Output: 5
```

3. Если функция должна вернуть несколько значений, то она может вернуть их в виде кортежа, списка или другого 
   итерируемого объекта. Например: 

```python
def get_details(name, age):
    address = "Unknown"
    phone = "Unknown"
    return name, age, address, phone

result = get_details("John", 25) # Вызов функции get_details
print(result) # Output: ('John', 25, 'Unknown', 'Unknown')
```

Чтобы получить доступ к отдельным значениям, можно использовать индексы кортежа или списка, например: `result[0]` 
вернет `'John'`, а `result[1]` вернет `25`. 



### Параметры функции

Функция - это «строительный блок» кода, поддерживаемого большинством языков программирования, но все еще существует 
много различий между функциями в Python и функциями на других языках. Одно из заметных отличий - это параметры 
функции Python, с которыми работают. В Python параметры функции могут иметь значения по умолчанию и поддерживать 
использование переменных параметров.

В Python параметры функции могут принимать значения по умолчанию. Это означает, что если параметр не указан при 
вызове функции, он будет использовать значение по умолчанию, которое было задано при определении функции. 

Пример:
```python
def greet(name, greeting='Hello'):
    print(greeting + ', ' + name)
# В этой функции параметр name является обязательным, а параметр greeting имеет значение по умолчанию 'Hello'. Таким 
# образом, если мы вызываем функцию и не передаем значение для greeting, она будет использовать значение 'Hello':
```
>>> greet('John')
Hello, John

>>> greet('Emily', 'Hi')
Hi, Emily


В Python существует несколько типов параметров функций:

1. Параметры по умолчанию (default parameters) - это параметры функции, которым задано значение по умолчанию. Если 
   при вызове функции этот параметр не передается, то будет использовано значение по умолчанию, заданное при 
   объявлении функции. Пример:  

```
def foo(a, b=10):
    print(a + b)
    
foo(5) # выведет 15, так как b принимает значение по умолчанию 10
foo(5, 7) # выведет 12, так как b принимает переданное значение 7
```

2. Параметры переменных (variable parameters) - это параметры функции, которые могут принимать произвольное 
   количество аргументов. В Python это можно сделать двумя способами: *args и **kwargs. Пример: 

```
def bar(*args):
    for arg in args:
        print(arg)
        
bar(1, 2, 3) # выведет 1, 2, 3
```

3. Параметры ключевого слова (keyword parameters) - это параметры функции, которые могут быть переданы при вызове 
   функции с использованием их имен. При этом порядок передачи параметров не имеет значения. Пример: 

```
def baz(a, b):
    print(a + b)
    
baz(a=5, b=7) # выведет 12
baz(b=7, a=5) # выведет 12
```

4. Параметры именованного ключевого слова (named keyword parameters) - это параметры функции, которые должны быть 
   переданы при вызове функции с использованием их имен, иначе возникнет ошибка. Пример: 

```
def qux(*, a, b):
    print(a + b)

qux(a=5, b=7) # выведет 12
qux(5, b=7) # выдаст ошибку, так как параметр a должен быть передан с использованием его имени
```

Важно отметить, что все перечисленные типы параметров могут использоваться вместе в одной функции. Также они могут 
иметь произвольное количество аргументов. 


Также функции в Python могут принимать произвольное количество аргументов. Для этого в определении функции 
используются символы звездочки (*) и двойной звездочки (**): 

```python
def my_function(*args, **kwargs):
    print(args)
    print(kwargs)
```
Пример использования этой функции:

```python
>>> my_function('a', 'b', 'c', name='John', age=30)
('a', 'b', 'c')
{'name': 'John', 'age': 30}
```

Здесь параметры *args и **kwargs принимают произвольное количество аргументов. *args означает, что функция может 
принимать любое количество неименованных аргументов, а **kwargs означает, что функция может принимать любое 
количество именованных аргументов.

*args и **kwargs являются параметрами функции Python, используемыми для обработки изменяемого или неизменяемого 
количества аргументов при вызове функции. 

*args - это параметр, который представляет собой кортеж неограниченного количества позиционных аргументов, 
переданных в функцию. Этот параметр используется, когда мы не знаем заранее, сколько аргументов будет передано 
функции.  

**kwargs - это параметр, который представляет собой словарь неограниченного количества ключевых аргументов, 
переданных в функцию. Этот параметр используется, когда мы не знаем заранее, какие ключевые аргументы будут переданы 
функции.  

Пример использования *args:

```python
def my_sum(*args):  # создаем функцию с именем my_sum которая принимает любое количество аргументов
    result = 0  # создаем внутри функции переменную равную 0
    for num in args:  # задаем цикл, который перебирает все принятые функцией аргументы
        result += num  # добавляем каждый аргумент к итоговой сумме аргументов
    return result  # полученный результат вычислений функции возвращаем для дальнейшего работы с ним

print(my_sum(1, 2, 3)) # выводит 6
print(my_sum(1, 2, 3, 4, 5)) # выводит 15
```

Пример использования **kwargs:

```python
def my_func(**kwargs):  # создаем функцию с именем my_func которая принимает любое количество ключевых аргументов
    for key, value in kwargs.items(): # задаем цикл, который перебирает все принятые функцией аргументы 
                                        # (по парно ключ, аргумент)
        print(f"{key}:{value}")         # выводим на печать пару значений ключ, аргумент
# обратите внимание в этой функции нет возврата значений функции, т.к. цель функции вывести на экран пару ключ - 
# значение, принятых аргументов 

# Применим нашу функцию:
my_func(name="John", age=30, location="New York") # выводит name:John, age:30, location:New York
```


### Управляйте функциями с помощью модулей

Концепция модулей в Python состоит в том, что любой файл .py может быть использован как модуль, который может 
содержать функции, классы, переменные и т.д. Эти модули могут быть импортированы в другие файлы Python и 
использованы для выполнения определенных функций или задач.  

В Python есть множество настраиваемых модулей, которые могут быть использованы для управления функциями. Некоторые 
из них: 

1. math - модуль, который содержит различные математические функции, такие как sin, cos, sqrt и т.д.

2. random - модуль, который используется для работы с генераторами случайных чисел.

3. datetime - модуль, который содержит классы и функции для работы с датами и временем.

4. os - модуль, который позволяет работать с операционной системой, включая создание / удаление файлов и директорий.

5. csv - модуль, который используется для чтения и записи CSV-файлов.

Пример использования модуля math для вычисления гипотенузы прямоугольного треугольника:

```python
import math

a = 3
b = 4

c = math.sqrt(a**2 + b**2)

print("Гипотенуза треугольника равна:", c)
```

Вывод:

```
Гипотенуза треугольника равна: 5.0
```

Как видно из примера, мы импортировали модуль math, используя команду `import math`, а затем использовали функцию 
`math.sqrt()` для вычисления квадратного корня. 



Для любого языка программирования присвоение имен идентификаторам, таким как переменные и функции, является 
головной болью, потому что мы столкнемся с неловкой ситуацией конфликтов имен. Самый простой сценарий - определить 
две функции с одним и тем же именем в одном и том же файле .py. Поскольку Python не имеет концепции перегрузки 
функций, последующее определение переопределит предыдущее значение, т.о. эти две функции с одинаковым 
именем на самом деле есть только одна функция.

```Python
def too():
    print('Привет, мир!')


def too():
    print('Прощай, мир!')


# Т.к. выше указаны две функции с одинковым именем, то при вызыве по имени идет обращение к последней по тексту.
too()
# получим результат:
# Прощай, мир!
```

Конечно, мы можем легко избежать описанной выше ситуации, но если проект разрабатывается несколькими людьми в 
команде, в команде может быть несколько программистов, которые определили названную foo функцию, тогда как решить 
этот конфликт именования? Ответ на самом деле очень прост. Каждый файл в Python представляет собой 
модуль. У нас могут быть функции с одинаковыми именами в разных модулях. При использовании функций мы можем 
использовать ``import`` ключевые слова для импорта определенных модулей, чтобы различать их. Какая ``too`` функция 
в каком модуле, код выглядит следующим образом.
`module1.py`

```Python
def too():
    print('Привет, мир!')
```

`module2.py`

```Python
def too():
    print('Прощай, мир!')
```

`test.py`

```Python
from module1 import too

# Привет, мир!
too()

from module2 import too

# Прощай, мир!
too()
```

Вы также можете определить, какую ``too`` функцию использовать, как показано ниже.

`test.py`

```Python
import module1 as m1
import module2 as m2

m1.too()
m2.too()
```

Но если код написан следующим образом, то в программе вызывается последний импортированный код, потому что 
импортированный позже перезаписывает импортированный ранее

`test.py`

```Python
from module1 import too
from module2 import too

# Прощай, мир!
too()
```

`test.py`

```Python
from module2 import too
from module1 import too

# Привет, мир!
foo()
```

Следует отметить, что если импортируемый модуль имеет исполняемый код в дополнение к определению функций, то 
интерпретатор Python выполнит этот код при импорте этого модуля. На самом деле, мы можем этого не делать, для этого 
лучше всего поместить код выполнения в условия, показанное ниже. В этом случае, если модуль не запускается напрямую,
то код в условии if не будет выполняться, потому что есть только модули, которые выполняются напрямую

`module3.py`

```Python
def foo():
    pass


def bar():
    pass

# __name__ - это неявная переменная в Python, представляющая имя текущего модуля 
# __main__ - это тоже неявная переменная в Python, представляющая имя главного модуля выполняемого интерпретатором Python
if __name__ == '__main__':  # если этот код подключили как модуль, то код далее выполнятся не будет
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```

Таким образом возьмете за правило писать свой код так:
```Python
def main():  # главная функция этой программы
    # Добавьте сюда свой код
    pass  # Оператор-заглушка, равноценный отсутствию операции


if __name__ == '__main__':  # проверка на то запущен ли этот код (программа)
    main()  # вызываем главную функцию этой программы
```


### Инкапсуляция функциональных модулей с функциями python

Инкапсуляция - это процесс сокрытия данных и функций внутри обособленного модуля, который может быть использован в 
других частях кода, без необходимости знать о его внутренней реализации. 

В Python, вы можете создавать функциональные модули, содержащие функции, классы и переменные, их атрибуты и методы, 
которые не непосредственно необходимы другим частям кода. При этом, вы можете использовать специальный синтаксис для 
определения публичных и приватных элементов:  

- Публичные элементы объявляются без приставки "_". К таким элементам можно получить доступ из других частей кода.
- Приватные элементы объявляются с приставкой "_". Они доступны только внутри модуля.

Например, создайте файл my_module.py и определите в нём публичную и приватную функции:

```python
# Public function
def greet(name):
    print(f"Hello, {name}!")

# Private function
def _internal_function():
    print("This is a private function")
```

Вы можете импортировать модуль и вызвать его публичную функцию в любом другом файле:

```python
import my_module

my_module.greet("Bob") # выведет "Hello, Bob!"
```

Однако, если вы попытаетесь вызвать приватную функцию, вам будет выброшено исключение:

```python
import my_module

my_module._internal_function() # выбросит AttributeError
```

Таким образом, инкапсуляция в Python позволяет создавать безопасные и модульные приложения, которые могут быть 
использованы в различных проектах. 

### Проблемы области - локальная область / вложенная область / глобальная область / встроенная область / ключевые слова, связанные с областью действия Python

Область действия (scope) в Python определяет область видимости переменных, функций и классов в коде. 

Проблемы, связанные с областью действия в Python:

1. Локальная область (Local Scope) - это область действия, в которой переменные определены внутри функции и не могут 
   быть использованы вне функции. Если попытаться обратиться к переменной вне функции, будет ошибка. 

2. Вложенная область (Enclosing Scope) - это область действия, в которой функция определена внутри другой функции, и 
   переменные могут использоваться в любом месте внутри внешней функции и ее вложенных функций, но не могут 
   использоваться вне функций.  

3. Глобальная область (Global Scope) - это область действия, в которой переменные определены вне функции и могут 
   быть использованы в любом месте в коде, в том числе и внутри функций. 

4. Встроенная область (Built-in Scope) - это область действия, в которой определены встроенные функции и объекты 
   Python, такие как print, str, int и другие. 

5. Ключевые слова, связанные с областью действия в Python - global и nonlocal. Ключевое слово global используется 
   для того, чтобы обозначить, что переменная в функции будет использоваться в глобальной области. Ключевое слово 
   nonlocal используется для указания, что переменная будет использоваться во вложенной области.  



1. Локальная область: это область видимости переменной внутри функции. Например:

```python
def my_func():
    x = 10  # локальная переменная
    print(x)

my_func()  # получим результат 10

# но если попытаться вызвать переменную х, то мы получим ошибку, т.к. эта переменная в программе не видна, а видна 
# только внутри функции

print(х)  # ошибка
```
Здесь переменная "x" является локальной и доступна только внутри функции.

2. Вложенная область: это область видимости внутри функции, которая содержит другую функцию. Например:

```python
def outer_func():
    x = 10  # здесь также может быть локальная переменная
    def inner_func():
        nonlocal x  # ссылаемся на переменную x, объявленную в outer_func
        x += 5
        print(x)
    
    inner_func()

outer_func()
```
Здесь внутри функции "outer_func" есть вложенная функция "inner_func", которая имеет доступ к переменной "x", 
объявленной в "outer_func".  

3. Глобальная область: это область видимости переменной во всем модуле Python. Например:

```python
x = 10  # глобальная переменная

def my_func():
    print(x)

my_func()
```
Здесь переменная "x" является глобальной, так как она объявлена за пределами функции "my_func" и доступна внутри нее.

4. Встроенная область: это область видимости переменных, определенных в модуле Python. Некоторые из них встроены в 
   Python, например, "print", "len" и т.д. Например: 

```python
y = [1, 2, 3]
print(len(y))
```
Здесь "len" является встроенной функцией в Python и доступна во всем модуле Python. Переменная "y" является 
глобальной в этом случае.  

### Просмотр содержимого импортируемой функции
Есть несколько способов просмотреть содержимое импортируемой функции в Python. 

1. Используя функцию help(): 
```
import функция
help(функция)
```
Пример:
```
import math
help(math.sin)
```
2. Используя функцию dir(): 
```
import функция
dir(функция)
```
Пример: 
```
import math
dir(math)
```
3. Используя модуль inspect:
```
import inspect
import функция
print(inspect.getsource(функция))
```
Пример:
```
import inspect
import math
print(inspect.getsource(math.sin))
```

Важно помнить, что не все функции могут содержать исходный код. Некоторые встроенные и системные функции имеют 
оптимизированный код, который недоступен для просмотра.  

Примеры:
- 01.общий_делитель_кратное.py
- 02.встроенные_функции.py
- 03.общие_модули.py

[Вернуться на главную](https://github.com/BEPb/Python-100-days)


[К следующему занятию](https://github.com/BEPb/Python-100-days/tree/master/%D0%94%D0%B5%D0%BD%D1%8C%2001-15/%D0%94%D0%B5%D0%BD%D1%8C%2007/README.md)
