## Строки и общие структуры данных

### Строки

Вторая мировая война привела к рождению современных электронных компьютеров. Сначала компьютеры использовались для 
расчета траекторий ракет. В течение многих лет после появления компьютеров информация, обрабатываемая компьютерами, 
была в основном числовой. Первый в мире электронный компьютер, получивший название ENIAC (Electronic Numerical 
Integral Computer), был создан в Пенсильванском университете в США и может выполнять около 5000 операций с 
плавающей запятой в секунду. Со временем, хотя численные расчеты по-прежнему остаются одной из самых важных вещей в 
повседневной работе с компьютером, все больше данных, обрабатываемых современными компьютерами, может существовать 
в форме текста. Если мы хотим управлять компьютером с помощью программ Python Вам сначала необходимо понять тип строки 
и знания, связанные с этим типом.

Так называемая строка - это конечная последовательность из нуля или более символов. В программе Python, если мы 
заключим один или несколько символов в одинарные или двойные кавычки, мы можем представить строку.

```Python
s1 = 'Привет, мир!'  # это строка отделена одинарными кавычками
s2 = "Прощай, мир!"  # это тоже строка  отделена двойными кавычками
s3 = """ Ну, что, мир? """  # это тоже строка  отделена тройными кавычками
print(s1, s2, s3, end='')  # выводим значение переменных (строки)
```

Вы можете использовать `\` (обратную косую черту) в строке, чтобы указать, что следующий символ больше не имеют 
своего исходного значения, например: сочетание `\n` представляет новую строку; а сочетание `\t` представляет собой 
символ табуляции. Итак, если вы хотите представить в записываемой строке символ слэш `\`, то вам необходимо 
использовать два слэша `\\`. Вы можете запустить следующий код, чтобы увидеть, что будет выводиться.

```Python
s1  =  ' \' привет, мир! \ ' ' 
s2  =  ' \ n \\ привет, мир! \\ \ n ' 
print ( s1 , s2 , end = '' )
```

После слеша `\` может стоять восьмеричная или шестнадцатеричная цифра для представления символов, 
например `\141`, и `\x61` представляет собой строчные буквы `a`. За символом слеша `\` может также следовать кодировка 
символов Unicode для представления символов, 

Python предоставляет очень богатый набор операторов для строковых типов. Мы можем использовать `+` операторы для 
объединения строк, мы можем использовать операторы `* `для повторения содержимого строки, и мы можем использовать 
`in` и  `not in` для определения, содержит ли строка другой символ. Мы также можем использовать оператор `[]` суммы 
или `[:]` оператор извлечения символа или некоторых символов из строки (операция нарезки), код показан ниже.

```Python
s1 = 'привет ' * 3  # переменная s1 будет состоять из трех слов привет через пробел
print(s1) # выводим результат 
# "привет привет привет "

s2 = 'мир'  # перменная s2 состоит из слова "мир"
s1 += s2  # теперь переменная s1 = s1 + s2 т.е. 'привет привет привет ' + 'мир' = 'привет привет привет  мир'
print(s1) # выводим результат переменной s1
# 'привет привет привет  мир'

print('при' in s1) # Если переменна s1 содерижит в своем составе строку 'при' то выведет зничение - ИСТИНА "True"
print('облоко' in s1) # # Если переменна s1 не содерижит в своем составе строку 'облоко' то выведет зничение - ЛОЖЬ # "False" 

# Теперь потренируемся извлекать символы в указанной позиции из строки (операция с индексом)
str2 = 'abc123456'  # создадим новую переменную - строку
print(str2[2]) # указывает на 3-й символ (нумерация идет так 0,1,2, по этому третий), т.о. получаем символ - "c"
# Нарезка строки (от указанного начального индекса до указанного конечного индекса)
print(str2[2:5]) # указывает на последовательность от 3-го символа до 6-го, т.о. получаем "c12"
print(str2[2:]) # указывает на последовательность от 3-го символа до последнего, т.о. получаем "c123456"
print(str2[2::2]) # указывает на последовательность от 3-го символа до последнего, с шагом 2, т.о. получаем "c246"
print(str2[::2]) # все символы с шагом 2 от первого до последнего, т.о. получаем "ac246"
print(str2[::-1]) #  все символы от последнего до первого (знак `-` означает обратную последовательность),  "654321cba"
print(str2[-3:-1]) # от 3-го символа с конца до 1-го с конца, т.о. получаем "45"
```

В Python мы также можем завершить обработку строк с помощью ряда методов, код показан ниже.

```Python
str1  =  'hello, world!' 
# Вычислить длину строки с помощью встроенной функции len 
print(len(str1)) # 13 
# Получить копию строки но каждое слово с заглавной буквы 
print(str1.capitalize()) # Hello, World! 
# получить строку копию всех слов 
print(str1.title()) # Hello, World!
# преобразует строку в заглавные буквы
print(str1.upper()) # HELLO, WORLD!
# Найти из строки позицию указанные символов 
print(str1.find('or')) # 8
print(str1.find('shit')) # если строка не найдена то получаем значение -1
# Аналогично find, но принимает значение истина или ложь
print(str1.startswith('He')) # False
print(str1.startswith('hel')) # True
# Проверяется, заканчивается ли строка указанной строкой 
print(str1.endswith('!')) # True
# центр строка с заданной шириной и заполнить указанные символы с обеих сторон 
print(str1.center(50, '*'))
# Поместите строку справа от указанной ширины и заполните указанными символами слева
print(str1.rjust(50, ' '))
str2 = 'abc123456'
# Проверка, строка состоит из чисел 
print(str2.isdigit())  # False
# Проверка, состоит ли строка из букв
print(str2.isalpha())  # False
# Проверить, состоит ли строка из цифр и букв
print(str2.isalnum())  # True
str3 = '  jackfrued@126.com '
print(str3)
# Получить копию строки после обрезки левого и правого пробелов строки 
print(str3.strip())
```

Помимо строк, Python также имеет множество встроенных структур данных. Если вы хотите сохранять данные в программе и 
управлять ими, вы можете использовать существующие структуры данных для достижения большей части времени. Наиболее 
часто используемые структуры это списки, кортежи, множества и словари.

### Список

Списки Python схожи с массивами в других языках. В Python, пустой список может быть создан следующим образом:

```python
my_list = []
my_list = list()
```
Как вы видите, вы можете создать список при помощи квадратных скобок, или при помощи встроенного инструмента Python 
– list. Список состоит из таких элементов, как строки, цифры, объекты и смеси типов. Давайте взглянем на несколько 
примеров:

```python
my_list = [1, 2, 3]
my_list2 = ["a", "b", "c"]
my_list3 = ["a", 1, "Python", 5]
```

В следующем коде показано, как определить список, как перемещаться по списку, а также операцию индексации списка.


```Python
list1 = [1, 3, 5, 7, 100]
print(list1) # [1, 3, 5, 7, 100]
# Знак умножения указывает на повторение элементов списка
list2 = ['hello'] * 3
print(list2) # ['hello', 'hello', 'hello']
# Вычислить длину списка (количество элементов)
print(len(list1)) # 5
# Подстрочная (индексная) операция 
print(list1[0]) # 1
print(list1[4]) # 100
# print(list1[5])  # IndexError: list index out of range
print(list1[-1]) # 100
print(list1[-3]) # 5
list1[2] = 300
print(list1) # [1, 3, 300, 7, 100]
# Перебирать элементы списка с нижними индексами 
for index in range(len(list1)):
    print(list1[index])
# Обойти элементы списка через цикл
for elem in list1:
    print(elem)
# После обработки списка с помощью функции enumerate вы можете получить индекс элемента и значение одновременно 
for index, elem in enumerate(list1):
    print(index, elem)
```


Следующий код демонстрирует, как добавлять элементы в список и как удалять элементы из списка.


```Python
list1 = [1, 3, 5, 7, 100]
#  Добавление элементов 
list1.append(200)
list1.insert(1, 400)
# Объединить два списка 
# list1.extend([1000, 2000])
list1 += [1000, 2000]
print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]
print(len(list1)) # 9
# Сначала определите, находится ли элемент в списке с помощью операций с элементами, и удалите элемент,
if 3 in list1:
	list1.remove(3)
if 1234 in list1:
    list1.remove(1234)
print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]
# удалить элементы из указанного места
list1.pop(0)
list1.pop(len(list1) - 1)
print(list1) # [400, 5, 7, 100, 200, 1000]
# Очистить элементы списка
list1.clear()
print(list1) # []
```


Как и строка, список также можно нарезать. С помощью операции нарезки мы можем скопировать список или извлечь часть 
списка, чтобы создать новый список. Код выглядит следующим образом.

```Python
fruits = ['grape', 'apple', 'strawberry', 'waxberry']
fruits += ['pitaya', 'pear', 'mango']
# выбираем значения из списка
fruits2 = fruits[1:4]
print(fruits2) # apple strawberry waxberry
# Список можно скопировать с помощью операции
fruits3 = fruits[:]
print(fruits3) # ['grape', 'apple', 'strawberry', 'waxberry', 'pitaya', 'pear', 'mango']
fruits4 = fruits[-3:-1]
print(fruits4) # ['pitaya', 'pear']
# # можно получить после инвертирования копии списка обратной нарезки
fruits5 = fruits[::-1]
print(fruits5) # ['mango', 'pear', 'pitaya', 'waxberry', 'strawberry', 'apple', 'grape']
```

Следующий код реализует операцию сортировки в списке.

```Python
list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']
list2 = sorted(list1)
# Функция сортировки возвращает отсортированную копию списка и не изменяет переданный список
list3 = sorted(list1, reverse=True)
# Используйте параметр ключевого слова, чтобы указать сортировку по длине строки вместо значения по умолчанию алфавитный порядок
list4 = sorted(list1, key=len)
print(list1)
print(list2)
print(list3)
print(list4)
# сортировка объектов этого же списка в обратной последовательности
list1.sort(reverse=True)
print(list1)
```

### Генерация списков (list)

Мы также можем использовать генеративный синтаксис для создания списков, код показан ниже.

```Python
f = [x for x in range(1, 10)]  # генерируем числовой список
print(f)
f = [x + y for x in 'ABCDE' for y in '1234567']  # генерируем буквенно-числовой список
print(f)
# После создания списка с этим синтаксисом он использует больше места в памяти 
f = [x ** 2 for x in range(1, 1000)]  # генерируем числовой список
print(sys.getsizeof(f))  # Просмотр количества байтов, занятых объектом
print(f)
# Обратите внимание, что следующий код создает не список, а объект-генератор (скобки не квадратные, а круглые)
# Данные можно получить через генератор, что бы занимать меньше места в памяти для хранения данных 
# Каждый раз, когда требуются данные из списка, данные получаются посредством внутренних вычислений (но это требует 
# дополнительного времени)
f = (x ** 2 for x in range(1, 1000))
print(sys.getsizeof(f))  # По сравнению с верхним примером, он не занимает места
print(f)
for val in f:
    print(val)
```

В дополнение к синтаксису генератора, упомянутому выше, есть еще один способ определить генератор в Python, который 
заключается в "yield" преобразовании обычной функции в функцию генератора с помощью ключевых слов. Следующий код 
демонстрирует, как реализовать генератор, который генерирует последовательность Фибоначчи. Так называемая 
последовательность Фибоначчи может быть определена следующим рекурсивным методом:

```Python
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
        yield a


def main():
    for val in fib(20):
        print(val)


if __name__ == '__main__':
    main()
```

Для понимания, что делает yield, необходимо понимать, что такое генераторы. Генераторам же предшествуют итераторы. 
Когда вы создаёте список, вы можете считывать его элементы один за другим — это называется итерацией:

```Python
mylist = [1, 2, 3]
for i in mylist :
   print(i)
```
Mylist является итерируемым объектом. Когда вы создаёте список, используя генераторное выражение, вы создаёте также итератор:

```Python
mylist = [x*x for x in range(3)]
for i in mylist:
    print(i)
```
Всё, к чему можно применить конструкцию «for… in...», является итерируемым объектом: списки, строки, файлы… Это 
удобно, потому что можно считывать из них значения сколько потребуется — однако все значения хранятся в памяти, а 
это не всегда желательно, если у вас много значений.

Генераторы это тоже итерируемые объекты, но прочитать их можно лишь один раз. Это связано с тем, что они не хранят 
значения в памяти, а генерируют их на лету:

```Python
mygenerator = (x*x for x in range(3))
for i in mygenerator :
    print(i)
```
Всё то же самое, разве что используются круглые скобки вместо квадратных. НО: нельзя применить конструкцию for i in 
mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает 
про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.

Yield - это ключевое слово, которое используется примерно как return — отличие в том, что функция вернёт генератор.

```python
def createGenerator() :
    mylist = range(3)
    for i in mylist :
        yield i*i

mygenerator = createGenerator() # создаём генератор
print(mygenerator) # mygenerator является объектом!
# generator object createGenerator at 0xb7555c34
for i in mygenerator:
     print(i)
```

### Кортежи (tuple)

Кортежи в Python похожи на списки, а также являются типом данных контейнера. Одна переменная (объект) может 
использоваться для хранения нескольких данных. Разница в том, что элементы кортежа не могут быть изменены. Мы 
использовали его более одного раза в предыдущий код. Как следует из названия, мы объединяем несколько элементов в 
кортеж, поэтому он может содержать несколько частей данных, как список. Следующий код демонстрирует, как определять 
и использовать кортежи.

```Python
# создаем кортеж
t = ('апельсин', 38, True, 'автобус')
print(t)
# Получить элементы в кортеже
print(t[0])
print(t[3])
# Обойти каждое значение в кортеже и печатаем его 
for member in t:
    print(member)
# TypeError # Переменная t повторно ссылается на новый кортеж, но элементы кортежа изменить нельзя
t = ('дерево', 20, True, 'мир')
print(t)
# Преобразование кортежа в список 
person = list(t)
print(person)
# Список можно изменять
person[0] = 'яблоко'
person[1] = 25
print(person)
# Преобразование списка в кортеж
fruits_list = ['apple', 'banana', 'orange']
fruits_tuple = tuple(fruits_list)
print(fruits_tuple)
```

Здесь стоит обсудить вопрос. У нас уже есть такая структура данных, как список. Зачем нам нужен такой тип, как 
кортеж (tuple)?

1. Элементы в кортеже не могут быть изменены. Фактически, мы можем предпочесть использовать неизменяемые объекты в 
проекте, особенно в многопоточной среде (описанной позже) (с одной стороны, поскольку состояние объекта не может 
   быть изменено, это поможет избежать ненужных программных ошибок. Неизменяемый объект легче поддерживать, чем 
   изменяемый объект, так как вы можете сэкономить на синхронизации обработки. Неизменяемый объект 
   может легко получить общий доступ). Итак, вывод такой: если вам не нужно добавлять, удалять или изменять 
   элементы, вы можете рассмотреть возможность использования кортежей. Конечно, если метод должен возвращать 
   несколько значений, использование кортежей также является хорошим выбором.
2. Кортежи лучше списков с точки зрения времени создания и занимаемого пространства. Мы можем использовать функцию 
   `getsizeof` модуля sys, чтобы проверить, сколько места в памяти занимают кортежи и списки, в которых хранятся одни 
   и те же элементы. Это легко сделать. Мы также можем использовать волшебную команду `%timeit` в ipython для анализа 
   времени, необходимого для создания кортежей и списков одного и того же содержимого. В любом случае после проверки 
   Вы убедитесь, кортежи занимают меньше места и работать с ними получается быстрее нежели со списками.



### множества (set)

В Python множество - это набором уникальных элементов (не допускается повторений). Множество в python - "контейнер", 
содержащий не повторяющиеся элементы в случайном порядке. Множества удобно использовать для удаления повторяющихся 
элементов.

С множествами можно выполнять множество операций: находить объединение, пересечение...

- len(s) - число элементов в множестве (размер множества).
- x in s - принадлежит ли x множеству s.
- set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
- set == other - все элементы set принадлежат other, все элементы other принадлежат set.
- set.issubset(other) или set <= other - все элементы set принадлежат other.
- set.issuperset(other) или set >= other - аналогично.
- set.union(other, ...) или set | other | ... - объединение нескольких множеств.
- set.intersection(other, ...) или set & other & ... - пересечение.
- set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
- set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- set.copy() - копия множества.


И операции, непосредственно изменяющие множество:

- set.update(other, ...); set |= other | ... - объединение.
- set.intersection_update(other, ...); set &= other & ... - пересечение.
- set.difference_update(other, ...); set -= other | ... - вычитание.
- set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
- set.add(elem) - добавляет элемент в множество.
- set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
- set.discard(elem) - удаляет элемент, если он находится в множестве.
- set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
- set.clear() - очистка множества.

Вы можете создавать и использовать множество, как показано в следующем коде.

```Python
# Создадим числовое множество
set1 = {1, 2, 3, 3, 3, 2}
print(set1)
print('Length =', len(set1))
# создадим 2 множества
set2 = set(range(1, 10))
set3 = set((1, 2, 3, 3, 2, 1))
print(set2, set3)  # т.к. множество состоит только из уникальных элементов, повторяющеся элементы исчезнут
set4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0}  # более сложный пример создания множества
print(set4)
```

Добавлять элементы в множество и удалить элементы из него.

```Python
set1.add(4)  # добавить элемент
set1.add(5)
set2.update([11, 12])  # объединение, сразу добавляет несколько элементов
set2.discard(5)  # удаляет элемент, если он находится в множестве
if 4 in set2:
    set2.remove(4)  # удаляет элемент из множества. KeyError, если такого элемента не существует.
print(set1, set2)
print(set3.pop())
print(set3)
```

Зададим элементы, пересечение, объединение, вычитания и другие операции.

```Python
# Установим операции пересечения и объединения, разности, симметричной разности
print(set1 & set2)
# print(set1.intersection(set2))
print(set1 | set2)
# print(set1.union(set2))
print(set1 - set2)
# print(set1.difference(set2))
print(set1 ^ set2)
# print(set1.symmetric_difference(set2))
# Определить подмножество и надмножество 
print(set2 <= set1)
# print(set2.issubset(set1))
print(set3 <= set1)
# print(set3.issubset(set1))
print(set1 >= set2)
# print(set1.issuperset(set2))
print(set1 >= set3)
# print(set1.issuperset(set3))
```

> Примечание: Python позволяет настраивать операторы для определенного типа или структуры данных с помощью 
> некоторых специальных методов (будет обсуждаться в следующей главе). В приведенном выше коде мы можем вызывать 
> метод объекта коллекции, когда мы работаем с коллекцией. Вы также можете использовать соответствующий оператор 
> напрямую. Например, `&` функция оператора и метода пересечения одинаковы, но использование оператора делает код более 
> интуитивно понятным.


### словарь 

Словарь - это еще одна модель контейнера переменных. Словарь в Python такой же, как и словарь, используемый в нашей 
жизни. Он может хранить любой тип объекта. В отличие от списков и кортежей, каждый элемент словаря состоит из одной 
«пары ключ-значение» состоящий из ключа и значения, а ключ и значение разделены двоеточием. Следующий код 
демонстрирует, как определять и использовать словарь.

```Python
# Создадим словарь  
scores = {'яблоко': 95, 'апельсин': 78, 'груша': 82}
print(scores)
# Конструктор синтаксиса для создания словарей может быить и таким:
items1 = dict(one=1, two=2, three=3, four=4)
# Используйте функцию zip для сжатия двух последовательностей в словарь 
items2 = dict(zip(['a', 'b', 'c'], '123'))
# Дедуктивный синтаксис для создания словаря 
items3 = {num: num ** 2 for num in range(1, 10)}
print(items1, items2, items3)
# Вы можете получить соответствующее в словарь по ключу Значение
print(scores['яблоко'])
print(scores['апельсин'])
# Просматрим все пары ключ-значение в словаре
for key in scores:
    print(f'{key}: {scores[key]}')
# Обновить элементы в словаре
scores['яблоко'] = 65
scores['груша'] = 71
scores.update(персик=67, киви=85)
print(scores)
if 'персик' in scores:
    print(scores['персик'])
print(scores.get('персик'))
# Метод get также получает соответствующее значение по ключу, но может установить значение по умолчанию
print(scores.get('банан', 60))
# Удалим элемент в словаре 
print(scores.popitem())
print(scores.popitem())
print(scores.pop('яблоко', 65))
# Очистить словарь
scores.clear()
print(scores)
```
