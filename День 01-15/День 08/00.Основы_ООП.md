## Основы объектно-ориентированного программирования

Программисты, живущие в настоящее время, должны были слышать термин «объектно-ориентированное программирование», и 
некоторые люди часто спрашивают, могут ли они объяснить, что такое «объектно-ориентированное программирование» 
одним предложением. Давайте сначала рассмотрим более формальное утверждение.

«Составьте набор структур данных и методов, чтобы преобразовать их в объекты, сгруппировать объекты с одинаковым 
поведением в классы, скрыть внутренние детали с помощью инкапсуляции классов и реализовать специализацию классов с 
помощью наследования. Специализация классов и обобщения с помощью полиморфизма для достижения динамического 
назначения на основе типов объектов".

Ранее мы говорили, что «программа - это набор инструкций». Операторы, которые мы пишем в программе, при выполнении 
станут одной или несколькими инструкциями, а затем будут выполняться процессором. Конечно, чтобы упростить дизайн 
программы, мы ввели понятие функции, поместили в функцию относительно независимый и часто повторно используемый код,
и вам нужно вызывать функцию только тогда, когда эти функции необходимы; если функция слишком сложная, мы можем 
разделить ее на подфункции, чтобы уменьшить сложность системы. Но, сказав так много, я не знаю, обнаружили ли вы, что 
так называемое программирование заключается в том, что программисты управляют компьютером для выполнения различных 
задач в соответствии с тем, как он работает. Однако способ работы компьютера отличается от обычного человеческого 
мышления. Если вы программируете, вы должны отказаться от обычного человеческого мышления, чтобы угодить компьютеру. 
Но самое главное, что когда нам нужно разработать сложную систему, 
сложность кода затрудняет разработку и сопровождение, поэтому в конце 1960-х годов наступил «программный кризис». 
В индустрии начали появляться такие концепции, как «программная инженерия» и так далее.
Конечно, каждый в кругу программистов знает, что на самом деле не существует «серебряной пули», которая решает 
все проблемы. Что действительно вселяет надежду в разработчиков программного обеспечения, так это появление 
языка программирования Smalltalk, который родился в 1970-х годах. Объектно-ориентированный подход идеи 
программирования (прототип объектно-ориентированного программирования восходит к более раннему языку Simula). 
Согласно этой концепции программирования, данные в программе и функция управления данными представляют собой 
логическое целое, которое мы называем «объектами», и способ решения проблемы заключается в создании требуемых 
объектов и отправке различных объектов на сервер. В конце концов, совместная работа нескольких объектов позволяет 
нам создавать сложные системы для решения реальных проблем.

Примечание. Конечно, объектно-ориентированный подход - не «серебряная пуля» для решения всех проблем в 
разработке программного обеспечения, поэтому почти все современные языки программирования высокого уровня 
обеспечивают поддержку нескольких парадигм программирования, и Python не является исключением.

### Классы и объекты
Проще говоря, класс - это план и шаблон объекта, а объект - это экземпляр класса. Хотя это объяснение немного 
скомконо и не понятно, мы, по крайней мере, можем видеть из него, что классы - это абстрактные концепции, а объекты 
- это конкретные вещи. В мире объектно-ориентированного программирования все является объектом. Объекты имеют 
  атрибуты и поведение. Каждый объект уникален и должен принадлежать к определенному классу (типу). Когда мы 
  извлекаем статические характеристики (атрибуты) и динамические характеристики (поведение) большого количества 
  объектов с общими характеристиками, мы можем определить нечто, называемое «классом».

### Класс определения

В Python вы можете использовать  ключевое слово для определения класса - "class", а затем определять методы в классе с 
помощью функций, которые вы изучили ранее, чтобы вы могли описать динамические характеристики объекта. Код выглядит 
следующим образом.

```Python
class Student(object):  # создаем класс студент

    # __init__ - это специальный метод, используемый для инициализации объекта при его создании 
    # С помощью этого метода мы можем привязать два атрибута имени и возраста к объекту студента
    def __init__(self, name, age):  # функция инициализации, где self - означает использовать свое собственное значение
        self.name = name  # атрибут имени привязаня к своему собстенному значению и является величной переменной
        self.age = age  # атрибут класса привязаня к своему собстенному значению и является величной переменной

    def study(self, course_name):  # функция вывода имени курса, где self - использует свое собственное значение
        print('%s Имя и изучаемый курс %s.' % (self.name, course_name))  # выводим имя студента и имя курса

    # PEP 8 требует, чтобы имя идентификатора было связано со всеми строчными буквами и несколькими словами с 
    # подчеркиванием, но некоторые программисты и компании предпочитают использовать номенклатуру верблюжьих 
    # регистров (идентификация верблюжьих регистров)
    def watch_movie(self): # функция соотношения возвраста и ограничений просмотра фильмов
        if self.age < 18:
            print('%s может смотреть только фильмы с возврастными ограничениями.' % self.name)
        else:
            print('%s может смотреть все фильмы.' % self.name)
```

> Описание: функции, написанные в классе, обычно называются (объектными) методами. Эти методы представляют собой 
> сообщения, которые объект может получать.

### Создавать и использовать объекты

После определения класса мы можем создать объект и отправить ему сообщение следующим образом.

```Python
def main():  # главная функция
    # Создаем объект студента и укажем его имя и возраст
    stu1 = Student('Олег', 38)  # stu1 - это объекта класса    
    stu1.study('Python Program Design')  # Укажем изучаемый курс этим студентом    
    stu1.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu1
    
    stu2 = Student('Руслан', 15)    # stu2 - это 2-й объект того же класса
    stu2.study('Мысль и нравственность')  # Укажем изучаемый курс этим студентом
    stu2.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu2


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    main()  # то выполняем главную функцию
```

### Проблемы с видимостью доступа

Для приведенного выше кода программисты с опытом программирования на C ++, Java, C # и т.д. Могут спросить, какие 
права доступа (также известные как видимость) у нас есть для Student привязки объектов name и age свойств. Поскольку 
во многих объектно-ориентированных языках программирования мы обычно устанавливаем свойства объекта как частные или 
защищенные. Проще говоря, внешний доступ не разрешен, а методы объекта обычно являются общедоступными, потому что 
общедоступный метод является сообщением, которое объект может принять. В Python существует только два типа 
разрешений на доступ к атрибутам и методам: общедоступный и частный. Если вы хотите, чтобы атрибут был частным, вы 
можете использовать два символа подчеркивания в качестве начала при именовании атрибута. 


Однако Python не гарантирует строго конфиденциальность частных атрибутов или методов с точки зрения синтаксиса. Он 
просто изменяет имена частных атрибутов и методов, чтобы предотвратить доступ к ним. Фактически, если вы знаете 
правила изменения имен, вы все равно можете доступ к ним. Они, следующий код может это проверить. Причину такой 
настройки можно объяснить известной поговоркой: «Все мы здесь взрослые по согласию». Потому что большинство 
программистов считают, что открытость лучше закрытости, и программисты несут ответственность за свои действия.

```Python
class Test:  # создаем класс ТЕСТ

    def __init__(self, foo):  # инициализируем класс в скобках указан (адрес хранения экземпляра класса, принимаемый аргумент)
        print(self)  # что же такое self? это адресс в памяти где хранится экземпляр
        print("получили переменную", foo)  # что такое foo - это переменная, принимает значение аргумента принимаемое классом, в нашем случае 'hello'
        self.__foo = foo  # создаем свойство классса, к которому можно обращаться не вызывая исполенние всех функций
        print('я выполнил метод класса __init__')  # печатает сообщение, это нам говорит о том что метод выполнено полностью
        

    def __bar(self):  # этот метод выводит на печать сохранненное свойство экземпляра класса self.__foo и печатает свой текст 
        print(self.__foo)  # печатает сохранненное свойство экземпляра класса self.__foo        
        print('я выполнил метод класса __bar')  # печатает сообщение, это нам говорит о том что метод выполнено полностью


def main():  # главная функция
    test = Test('hello')  # здесь мы создаем новую переменную равную экземпляру класса с передаваемым аргументом 'hello', проводим инициализацию класса (запускается метод __init__)

    # после этой команды мы увидим:
    # <__main__.Test object at 0x0000026646090850>
    # получили переменную hello
    # я выполнил метод класса __init__

     
    # Т.О. при обращении к экземпляру класса (объекту) всегда идет его инициализация (выполнение метода __init__)
    
    test  # если просто обратится (указать объект), то ничего не произойдет, сам по себе экземпляр класса ничего не выполняет, он только хранит экземпляр значения класса
    
    print(test)  # если попытаться распечатать экземпляр класса то мы на самом деле распечатаем его адресс хранения <__main__.Test object at 0x0000026646090850>
    test._Test__foo  # мы также можем обратится к отдельному свойству экземпляра класса, значению переменной, но оно само по себе ничего не делает
    test._Test__bar()  # выполняет метод __bar экземпляра класса Test

    # после этой команды мы увидим:
    # hello
    # я выполнил метод класса __bar
    
    print(test._Test__foo)  # здесь мы выводим на печать частный атрибут __foo класса _Test объекта test, т.о. распечатает только 'hello'

    # test.__bar()
    # если попытаться обратится к методу __bar напрямую, не указывая имя класса то получим ошибку
    # AttributeError: 'Test' object has no attribute '__bar'

    # test.__foo
    # или если попытаться обратится к отдельному свойству экземпляра класса напрямую, не указывая имя класса то получим ошибку
    # # AttributeError: 'Test' object has no attribute '__foo'
    # print(test.__foo)

if __name__ == "__main__":
    main()
```

На практике не рекомендуется устанавливать для свойства частное значение, потому что это сделает подкласс 
недоступным (будет обсуждаться позже). Поэтому большинство программистов Python следуют соглашению об именах, 
которое позволяет имени атрибута начинаться с одного подчеркивания, чтобы указать, что атрибут защищен. За 
пределами этого класса будьте осторожны при доступе к таким атрибутам. Этот подход не является грамматическим 
правилом. Атрибуты и методы, начинающиеся с одного символа подчеркивания, по-прежнему доступны для внешнего мира. 

### Объектно-ориентированный столб

У объектно-ориентированного подхода есть три столпа: 
1. инкапсуляция, 
2. наследование, 
3. полиморфизм. 
   Последние две концепции подробно объясняются в следующей главе. Здесь мы сначала поговорим о том, что такое 
   инкапсуляция. Мое собственное понимание инкапсуляции - «скрыть все детали реализации, которые могут быть скрыты, 
   и предоставить только простой интерфейс программирования для внешнего мира». Метод, который мы определили в 
   классе, фактически инкапсулирует данные и операцию с данными. После создания объекта нам нужно только отправить 
   сообщение (вызвать метод) объекту для выполнения кода в методе, что означает, что Вам нужно знать только имя 
   метода и переданные параметры (внешний вид метода), а не детали реализации метода (внутреннее представление метода).
   

### Упражнения

