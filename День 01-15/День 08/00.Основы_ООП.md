## Основы объектно-ориентированного программирования

Программисты, живущие в настоящее время, должны были слышать термин «объектно-ориентированное программирование», и 
некоторые люди часто спрашивают, могут ли они объяснить, что такое «объектно-ориентированное программирование» 
одним предложением. Давайте сначала рассмотрим более формальное утверждение.

«Составьте набор структур данных и методов, чтобы преобразовать их в объекты, сгруппировать объекты с одинаковым 
поведением в классы, скрыть внутренние детали с помощью инкапсуляции классов и реализовать специализацию классов с 
помощью наследования. Специализация классов и обобщения с помощью полиморфизма для достижения динамического 
назначения на основе типов объектов".

Ранее мы говорили, что «программа - это набор инструкций». Операторы, которые мы пишем в программе, при выполнении 
станут одной или несколькими инструкциями, а затем будут выполняться процессором. Конечно, чтобы упростить дизайн 
программы, мы ввели понятие функции, поместили в функцию относительно независимый и часто повторно используемый код,
и вам нужно вызывать функцию только тогда, когда эти функции необходимы; если функция слишком сложная, мы можем 
разделить ее на подфункции, чтобы уменьшить сложность системы. Но, сказав так много, я не знаю, обнаружили ли вы, что 
так называемое программирование заключается в том, что программисты управляют компьютером для выполнения различных 
задач в соответствии с тем, как он работает. Однако способ работы компьютера отличается от обычного человеческого 
мышления. Если вы программируете, вы должны отказаться от обычного человеческого мышления, чтобы угодить компьютеру. 
Но самое главное, что когда нам нужно разработать сложную систему, 
сложность кода затрудняет разработку и сопровождение, поэтому в конце 1960-х годов наступил «программный кризис». 
В индустрии начали появляться такие концепции, как «программная инженерия» и так далее.
Конечно, каждый в кругу программистов знает, что на самом деле не существует «серебряной пули», которая решает 
все проблемы. Что действительно вселяет надежду в разработчиков программного обеспечения, так это появление 
языка программирования Smalltalk, который родился в 1970-х годах. Объектно-ориентированный подход идеи 
программирования (прототип объектно-ориентированного программирования восходит к более раннему языку Simula). 
Согласно этой концепции программирования, данные в программе и функция управления данными представляют собой 
логическое целое, которое мы называем «объектами», и способ решения проблемы заключается в создании требуемых 
объектов и отправке различных объектов на сервер. В конце концов, совместная работа нескольких объектов позволяет 
нам создавать сложные системы для решения реальных проблем.

Примечание. Конечно, объектно-ориентированный подход - не «серебряная пуля» для решения всех проблем в 
разработке программного обеспечения, поэтому почти все современные языки программирования высокого уровня 
обеспечивают поддержку нескольких парадигм программирования, и Python не является исключением.

### Классы и объекты
Проще говоря, класс - это план и шаблон объекта, а объект - это экземпляр класса. Хотя это объяснение немного 
скомконо и не понятно, мы, по крайней мере, можем видеть из него, что классы - это абстрактные концепции, а объекты 
- это конкретные вещи. В мире объектно-ориентированного программирования все является объектом. Объекты имеют 
  атрибуты и поведение. Каждый объект уникален и должен принадлежать к определенному классу (типу). Когда мы 
  извлекаем статические характеристики (атрибуты) и динамические характеристики (поведение) большого количества 
  объектов с общими характеристиками, мы можем определить нечто, называемое «классом».

### Класс определения

В Python вы можете использовать  ключевое слово для определения класса - "class", а затем определять методы в классе с 
помощью функций, которые вы изучили ранее, чтобы вы могли описать динамические характеристики объекта. Код выглядит 
следующим образом.

```Python
class Student(object):  # создаем класс студент

    # __init__ - это специальный метод, используемый для инициализации объекта при его создании 
    # С помощью этого метода мы можем привязать два атрибута имени и возраста к объекту студента
    def __init__(self, name, age):  # функция инициализации, где self - означает использовать свое собственное значение
        self.name = name  # атрибут имени привязаня к своему собстенному значению и является величной переменной
        self.age = age  # атрибут класса привязаня к своему собстенному значению и является величной переменной

    def study(self, course_name):  # функция вывода имени курса, где self - использует свое собственное значение
        print('%s Имя и изучаемый курс %s.' % (self.name, course_name))  # выводим имя студента и имя курса

    # PEP 8 требует, чтобы имя идентификатора было связано со всеми строчными буквами и несколькими словами с 
    # подчеркиванием, но некоторые программисты и компании предпочитают использовать номенклатуру верблюжьих 
    # регистров (идентификация верблюжьих регистров)
    def watch_movie(self): # функция соотношения возвраста и ограничений просмотра фильмов
        if self.age < 18:
            print('%s может смотреть только фильмы с возврастными ограничениями.' % self.name)
        else:
            print('%s может смотреть все фильмы.' % self.name)
```

> Описание: функции, написанные в классе, обычно называются (объектными) методами. Эти методы представляют собой 
> сообщения, которые объект может получать.

### Создавать и использовать объекты

После определения класса мы можем создать объект и отправить ему сообщение следующим образом.

```Python
def main():  # главная функция
    # Создаем объект студента и укажем его имя и возраст
    stu1 = Student('Олег', 38)  # stu1 - это объекта класса    
    stu1.study('Python Program Design')  # Укажем изучаемый курс этим студентом    
    stu1.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu1
    
    stu2 = Student('Руслан', 15)    # stu2 - это 2-й объект того же класса
    stu2.study('Мысль и нравственность')  # Укажем изучаемый курс этим студентом
    stu2.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu2


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    main()  # то выполняем главную функцию
```

### Проблемы с видимостью доступа

Для приведенного выше кода программисты с опытом программирования на C ++, Java, C # и т.д. Могут спросить, какие 
права доступа (также известные как видимость) у нас есть для Student привязки объектов name и age свойств. Поскольку 
во многих объектно-ориентированных языках программирования мы обычно устанавливаем свойства объекта как частные или 
защищенные. Проще говоря, внешний доступ не разрешен, а методы объекта обычно являются общедоступными, потому что 
общедоступный метод является сообщением, которое объект может принять. В Python существует только два типа 
разрешений на доступ к атрибутам и методам: общедоступный и частный. Если вы хотите, чтобы атрибут был частным, вы 
можете использовать два символа подчеркивания в качестве начала при именовании атрибута. 


Однако Python не гарантирует строго конфиденциальность частных атрибутов или методов с точки зрения синтаксиса. Он 
просто изменяет имена частных атрибутов и методов, чтобы предотвратить доступ к ним. Фактически, если вы знаете 
правила изменения имен, вы все равно можете доступ к ним. Они, следующий код может это проверить. Причину такой 
настройки можно объяснить известной поговоркой: «Все мы здесь взрослые по согласию». Потому что большинство 
программистов считают, что открытость лучше закрытости, и программисты несут ответственность за свои действия.

```Python
class Test:  # создаем класс ТЕСТ

    def __init__(self, foo):  # инициализируем класс в скобках указан (адрес хранения экземпляра класса, принимаемый аргумент)
        print(self)  # что же такое self? это адресс в памяти где хранится экземпляр
        print("получили переменную", foo)  # что такое foo - это переменная, принимает значение аргумента принимаемое классом, в нашем случае 'hello'
        self.__foo = foo  # создаем свойство классса, к которому можно обращаться не вызывая исполенние всех функций
        print('я выполнил метод класса __init__')  # печатает сообщение, это нам говорит о том что метод выполнено полностью
        

    def __bar(self):  # этот метод выводит на печать сохранненное свойство экземпляра класса self.__foo и печатает свой текст 
        print(self.__foo)  # печатает сохранненное свойство экземпляра класса self.__foo        
        print('я выполнил метод класса __bar')  # печатает сообщение, это нам говорит о том что метод выполнено полностью


def main():  # главная функция
    test = Test('hello')  # здесь мы создаем новую переменную равную экземпляру класса с передаваемым аргументом 'hello', проводим инициализацию класса (запускается метод __init__)

    # после этой команды мы увидим:
    # <__main__.Test object at 0x0000026646090850>
    # получили переменную hello
    # я выполнил метод класса __init__

     
    # Т.О. при обращении к экземпляру класса (объекту) всегда идет его инициализация (выполнение метода __init__)
    
    test  # если просто обратится (указать объект), то ничего не произойдет, сам по себе экземпляр класса ничего не выполняет, он только хранит экземпляр значения класса
    
    print(test)  # если попытаться распечатать экземпляр класса то мы на самом деле распечатаем его адресс хранения <__main__.Test object at 0x0000026646090850>
    test._Test__foo  # мы также можем обратится к отдельному свойству экземпляра класса, значению переменной, но оно само по себе ничего не делает
    test._Test__bar()  # выполняет метод __bar экземпляра класса Test

    # после этой команды мы увидим:
    # hello
    # я выполнил метод класса __bar
    
    print(test._Test__foo)  # здесь мы выводим на печать частный атрибут __foo класса _Test объекта test, т.о. распечатает только 'hello'

    # test.__bar()
    # если попытаться обратится к методу __bar напрямую, не указывая имя класса то получим ошибку
    # AttributeError: 'Test' object has no attribute '__bar'

    # test.__foo
    # или если попытаться обратится к отдельному свойству экземпляра класса напрямую, не указывая имя класса то получим ошибку
    # # AttributeError: 'Test' object has no attribute '__foo'
    # print(test.__foo)

if __name__ == "__main__":
    main()
```

На практике не рекомендуется устанавливать для свойства частное значение, потому что это сделает подкласс 
недоступным (будет обсуждаться позже). Поэтому большинство программистов Python следуют соглашению об именах, 
которое позволяет имени атрибута начинаться с одного подчеркивания, чтобы указать, что атрибут защищен. За 
пределами этого класса будьте осторожны при доступе к таким атрибутам. Этот подход не является грамматическим 
правилом. Атрибуты и методы, начинающиеся с одного символа подчеркивания, по-прежнему доступны для внешнего мира. 

### Объектно-ориентированный столб

У объектно-ориентированного подхода есть три столпа: 
1. инкапсуляция, 
2. наследование, 
3. полиморфизм. 
   Последние две концепции подробно объясняются в следующей главе. Здесь мы сначала поговорим о том, что такое 
   инкапсуляция. Мое собственное понимание инкапсуляции - «скрыть все детали реализации, которые могут быть скрыты, 
   и предоставить только простой интерфейс программирования для внешнего мира». Метод, который мы определили в 
   классе, фактически инкапсулирует данные и операцию с данными. После создания объекта нам нужно только отправить 
   сообщение (вызвать метод) объекту для выполнения кода в методе, что означает, что Вам нужно знать только имя 
   метода и переданные параметры (внешний вид метода), а не детали реализации метода (внутреннее представление метода).
   

### Упражнения

#### Часы
```python
"""
Python 3.9 Часы
Название файла '01.часы.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-08
"""

import time  # модуль работы с временем
import os  # модуль работы с операционной системой


class Clock(object):  # создаем класс

    # Функции в Python не имеют понятия перегрузки
    # Поскольку параметры функций в Python не имеют типов и поддерживают параметры по умолчанию и параметры переменных
    # Используйте параметры ключевого слова, чтобы позволить конструктору передавать любое количество параметров
    # для реализации перегрузки конструктора на других языках
    def __init__(self, **kw):  # инициализируем класс (принимает именные ключи со значениями)
        if 'hour' in kw and 'minute' in kw and 'second' in kw:  # если класс получил на входе именные ключи со значениями
            self._hour = kw['hour']  # атрибуту час присваиваем значение именного аргумента  'hour'
            self._minute = kw['minute']  # атрибуту минута присваиваем значение именного аргумента  'minute'
            self._second = kw['second']  # атрибуту секундаа присваиваем значение именного аргумента  'second'
        else:  # в ином случае, если при запуске программы время пользователем не задавалось
            tm = time.localtime(time.time())  # то считываем текущее время из системы (обращаясь к модулю time)
            self._hour = tm.tm_hour  # атрибуту час присваиваем значение считанного из системы
            self._minute = tm.tm_min  # атрибуту секундаа присваиваем значение считанного из системы
            self._second = tm.tm_sec  # атрибуту секундаа присваиваем значение считанного из системы

    def run(self):  # метод вычисления изменения времени
        self._second += 1  # к текущему значению добавим 1 секунду
        if self._second == 60:  # если количество секунд = 60
            self._second = 0  # то начинаем отсчет секунд с нуля
            self._minute += 1  # и к текущемму значению минут добавим 1 минуту
            if self._minute == 60:  # если количество минут = 60
                self._minute = 0  # то начинаем отсчет минут с нуля
                self._hour += 1  # и к текущемму значению часов добавим 1 час
                if self._hour == 24:  # если количество часов = 24
                    self._hour = 0  # то начинаем отсчет часов с нуля

    def show(self):  # метод отображения времени
        return '%02d:%02d:%02d' % (self._hour, self._minute, self._second)  # возвращает значение времени в укзанном
        # формате по два символа на часы, минуты, секунды, разделенные двоеточием


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    # clock = Clock(hour=10, minute=5, second=58)
    clock = Clock()  # создаем экземпляр класса
    while True:  # бесконечный цикл (пока истина есть истина)
        os.system('cls')  # очищаем командную строку
        print(clock.show())  # печатаем значение времени, обращаясь к объекту класса clock методу show()
        time.sleep(1)  # время ожидание = 1 секунда
        clock.run()  # проводим расчет времени в следующую секунду

```
### Угадай число до 100
```python
"""
Python 3.9 Объектно-ориентированная версия игры в угадывание чисел
Название файла '02.угадай_число_до_100.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-08
"""

from random import randint  # загружаем модуль генерации произвольных чисел


class GuessMachine(object):  # создаем класс

    def __init__(self):  # проводим инициализацию класса
        self._answer = None  # определяем атрибут и присваиваем ему значение None
        self._counter = None  # определяем атрибут и присваиваем ему значение None
        self._hint = None  # определяем атрибут и присваиваем ему значение None

    def reset(self):  # метод генерации числа при начале работы программы
        self._answer = randint(1, 100)  # атрибуту итогового числа (ответ) присваиваем произвольное значение от 1 до 100
        self._counter = 0  # атрибуту число попыток присваиваем значение равное 0
        self._hint = None  # атрибут оценки ответа пользователя оставляем со значением None

    def guess(self, your_answer):  # метод обработки ответа (на входе аргумент - Ваше число)
        self._counter += 1  # число попыток увеличиваем на 1
        # проводим сравнение введенного нами числа и ответа
        if your_answer > self._answer:  # если ваше число меньше ответа
            self._hint = 'меньше'  # то присваиваем атрибуту оценки ответа пользователя - меньше
        elif your_answer < self._answer:  # если ваше число больше ответа
            self._hint = 'больше'  # то присваиваем атрибуту оценки ответа пользователя - больше
        else:  # иначе
            self._hint = 'Поздравляю, вы угадали'    # то присваиваем атрибуту оценки ответа пользователя - вы угадали
            return True  # возвращаем значение "истина"
        return False  # возвращаем значение "ложь"

    @property  # описываем свойство класса
    def counter(self):  # свойство число попыток
        return self._counter  # возвращает значение атрибута числа попыток

    @property  # описываем свойство класса
    def hint(self):  # свойство реакция на ответа пользователя
        return self._hint  # возвращает значение реакция на ответа пользователя


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    gm = GuessMachine()  # создаем экземпляр класса
    play_again = True  # задаем значение переменной сыграть еще раз = Истина
    while play_again:  # цикл действует пока переменная сыграть еще раз = истина
        game_over = False  # пеерменной конец игры присваеиваем значение = ложь
        gm.reset()  # обращаемся к экземпляру класса gm методу reset() -  который устанавливает начальные значения
        while not game_over:  # пока переменная конец игры не истина
            your_answer = int(input('Пожалуйста, введите '))  # приглашение ввести Ваше число, присваиваем переменной
            game_over = gm.guess(your_answer)  # передаем ваш ответ методу обработки guess
            print(gm.hint)  # печатаем результат ответа пользователя
        if gm.counter > 7:  # если число попыток больше 7
            print('«Ваш IQ недостаточен!»')  # то выводим сообщение
        play_again = input('Играть снова? (да | нет)') == 'да'  # ожидает ответ пользователя

```
### способ создать класс
```python
"""
Python 3.9 Другой способ создать класс
Название файла '03.способ_создать_класс.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-08
"""


def bar(self, name):  # функция имени (принимает на вход имя пользователя)
    self._name = name  # этот атрибут запоминает принятое функции имя


def foo(self, course_name):  # функция курса обучения (принимает на вход имя курса обучения)
    print('%s изучает %s.' % (self._name, course_name))  # выводит имя и курс обучения пользователя


def main():  # главная функция
    Student = type('Student', (object,), dict(__init__=bar, study=foo))  # создаем класс, и проводим его инициализацию
    stu1 = Student('Олег')  # создаем экземпляр класса
    stu1.study('Программирование на Python')  # задаем экземпляру класса свойтво его программа обучения


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    main()  # выполняем главную функцию

```
### прямоугольник
```python
"""
Python 3.9 Определите и используйте класс прямоугольника
Название файла '04.прямоугольник.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-08
"""


class Rect(object):  # создаем класс прямоугольника
    """Класс прямоугольника"""

    def __init__(self, width=0, height=0):  # инициализируем класс (принимает на входе 2 значения по умолчанию равны 0)
        """Метод инициализации"""
        self.__width = width  # задаем атрибут  ширина
        self.__height = height  # задаем атрибут высота

    def perimeter(self):  # метод расчета периметра
        """Рассчитать периметр"""
        return (self.__width + self.__height) * 2  # возвращает значение периметра

    def area(self):  # метод расчета площади
        """Рассчитать площадь"""
        return self.__width * self.__height  # возвращает значение площади

    def __str__(self):  # метод преобразования данных в строку, в случае обращения к экземпляру класса, именно такое
        # представление будет отображаться
        """Строковое выражение объекта Rectangle"""
        return 'прямоугольник[%f,%f]' % (self.__width, self.__height)  # возвращает строку прямоугольник с значениями

    def __del__(self):  # метод очищает данные и выводит строку
        """Анализатор"""
        print('Уничтожить прямоугольный объект')  # выводит строку


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    rect1 = Rect()  # создаем объект - экземпляр класса rect1
    print(rect1)  # выводит на печать объект rect1 (по умолчанию стороны его равны 0)
    print(rect1.perimeter())  # выводит на печать периметр объекта rect1
    print(rect1.area())  # выводит на печать площадь объекта rect1
    rect2 = Rect(3.5, 4.5)  # создаем объект - экземпляр класса rect2 с соотв. сторонами
    print(rect2)  # выводит на печать объект rect2
    print(rect2.perimeter())  # выводит на печать периметр объекта rect2
    print(rect2.area())  # выводит на печать площадь объекта rect2

```
### ученики
```python
"""
Python 3.9 Определите и используйте классы учащихся
Название файла '05.ученики.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-08
"""


def _foo():  # функция печати слова тест
    print('test')


class Student(object):  # создаем класс

    # __init__ - это специальный метод, используемый для инициализации объекта при его создании
    # С помощью этого метода мы можем привязать два атрибута имени и возраста к объекту ученик
    def __init__(self, name, age):  # проводим инициализацию класса, на входе 2 параметра имя и возвраст
        self.name = name  # создаем атрибут класса = полученному значению
        self.age = age  # создаем атрибут класса = полученному значению

    def study(self, course_name):  # создаем модуль курс обучения
        print('%sучится%s.' % (self.name, course_name))  # модуль печатате строку имя-учится-курс

    # PEP 8 требует, чтобы имя идентификатора было полностью в нижнем регистре, а несколько слов были соединены подчеркиванием
    # Но многие программисты и компании предпочитают использовать номенклатуру верблюжьих ящиков (логотип верблюжьих ящиков)
    def watch_movie(self): # функция соотношения возвраста и ограничений просмотра фильмов
        if self.age < 18:
            print('%s может смотреть только фильмы с возврастными ограничениями.' % self.name)
        else:
            print('%s может смотреть все фильмы.' % self.name)


def main():  # главная функция
    # Создаем объект студента и укажем его имя и возраст
    stu1 = Student('Олег', 38)  # stu1 - это объекта класса
    stu1.study('Python Program Design')  # Укажем изучаемый курс этим студентом
    stu1.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu1

    stu2 = Student('Руслан', 15)  # stu2 - это 2-й объект того же класса
    stu2.study('Мысль и нравственность')  # Укажем изучаемый курс этим студентом
    stu2.watch_movie()  # Проведем анализ возрвастных ограничений по просмотру фильмов watch_av к объекту stu2


if __name__ == '__main__':  # если запускаемая программа - эта (имя запущенной программы соответствует этой программе)
    main()  # выполняем главную функцию

```