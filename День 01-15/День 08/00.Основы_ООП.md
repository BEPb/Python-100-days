## Основы объектно-ориентированного программирования

Программисты, живущие в настоящее время, должны были слышать термин «объектно-ориентированное программирование», и некоторые люди часто спрашивают, могут ли они объяснить, что такое «объектно-ориентированное программирование» одним предложением. Давайте сначала рассмотрим более формальное утверждение.

«Составьте набор структур данных и методов, чтобы преобразовать их в объекты, сгруппировать объекты с одинаковым поведением в классы, скрыть внутренние детали с помощью инкапсуляции классов и реализовать специализацию классов с помощью наследования. (Специализация) и обобщения (обобщения) с помощью полиморфизма ( полиморфизм) для достижения динамического назначения на основе типов объектов ".

Ранее мы говорили, что « программа - это набор инструкций ». Операторы, которые мы пишем в программе, при выполнении станут одной или несколькими инструкциями, а затем будут выполняться процессором. Конечно, чтобы упростить дизайн программы, мы ввели понятие функции, поместили в функцию относительно независимый и часто повторно используемый код, и вам нужно вызывать функцию только тогда, когда эти функции необходимы; если функция функции слишком сложен и раздут, мы можем разделить функцию на подфункции, чтобы уменьшить сложность системы. Но, сказав так много, я не знаю, обнаружили ли вы, что так называемое программирование заключается в том, что программисты управляют компьютером для выполнения различных задач в соответствии с тем, как он работает. Однако способ работы компьютера отличается от обычного человеческого мышления. Если вы программируете, вы должны отказаться от обычного человеческого мышления, чтобы угодить компьютеру, и удовольствие от программирования намного меньше. каждый должен научиться программировать "Я могу только говорить об этом. Конечно, это не самые важные. Самое главное, что когда нам нужно разработать сложную систему, сложность кода затрудняет разработку и сопровождение, поэтому в конце 1960-х годов наступил « программный кризис ». В индустрии начали появляться такие концепции, как « программная инженерия » и так далее.
Конечно, каждый в кругу программистов знает, что на самом деле не существует « серебряной пули », которая решает упомянутые выше проблемы . Что действительно вселяет надежду в разработчиков программного обеспечения, так это появление языка программирования Smalltalk, который родился в 1970-х годах . Объектно-ориентированный подход идеи программирования (прототип объектно-ориентированного программирования восходит к более раннему языку Simula ). Согласно этой концепции программирования, данные в программе и функция управления данными представляют собой логическое целое, которое мы называем «объектами», и способ решения проблемы заключается в создании требуемых объектов и отправке различных объектов на сервер. В конце концов, совместная работа нескольких объектов позволяет нам создавать сложные системы для решения реальных проблем.

Примечание. Конечно, объектно-ориентированный подход - не последняя «серебряная пуля» для решения всех проблем в разработке программного обеспечения, поэтому почти все современные языки программирования высокого уровня обеспечивают поддержку нескольких парадигм программирования, и Python не является исключением.

### Классы и объекты
Проще говоря, класс - это план и шаблон объекта, а объект - это экземпляр класса. Хотя это объяснение немного похоже на использование концептов для объяснения концепций, мы, по крайней мере, можем видеть из этого предложения, что классы - это абстрактные концепции, а объекты - это конкретные вещи. В мире объектно-ориентированного программирования все является объектом. Объекты имеют атрибуты и поведение. Каждый объект уникален и должен принадлежать к определенному классу (типу). Когда мы извлекаем статические характеристики (атрибуты) и динамические характеристики (поведение) большого количества объектов с общими характеристиками, мы можем определить нечто, называемое «классом».

### Класс определения

В Python вы можете использовать classключевые слова для определения класса, а затем определять методы в классе с помощью функций, которые вы изучили ранее, чтобы вы могли описать динамические характеристики объекта. Код выглядит следующим образом.

```Python
class Student(object):

    # __init__ - это специальный метод, используемый для инициализации объекта при создании объекта 
    # С помощью этого метода мы можем привязать два атрибута имени и возраста к объекту студента
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))

    # PEP 8 требует, чтобы имя идентификатора было связано со всеми строчными буквами и несколькими словами с подчеркиванием 
    # Но некоторые программисты и компании предпочитают использовать номенклатуру верблюжьих регистров (идентификация верблюжьих регистров)
    def watch_movie(self):
        if self.age < 18:
            print('%s может смотреть только "Bear Infestation".' % self.name)
        else:
            print('%s смотрит фильм о любви к островной стране.' % self.name)
```

> Описание: функции, написанные в классе, обычно называются (объектными) методами.Эти методы представляют собой сообщения, которые объект может получать.

### Создавать и использовать объекты

После определения класса мы можем создать объект и отправить ему сообщение следующим образом.

```Python
def main():
    # # Создайте объект ученика и укажите имя и возраст
    stu1 = Student('Олег', 38)
    # 给对象发study消息
    stu1.study('Python Program Design')
    # Отправьте сообщение watch_av к объекту
    stu1.watch_movie()
    stu2 = Student('Руслан', 15)
    stu2.study('Мысль и нравственность')
    stu2.watch_movie()


if __name__ == '__main__':
    main()
```

### Проблемы с видимостью доступа

Для приведенного выше кода программисты с опытом программирования на C ++, Java, C # и т. Д. Могут спросить, какие права доступа (также известные как видимость) у нас есть для Studentпривязки объектов nameи ageсвойств. Поскольку во многих объектно-ориентированных языках программирования мы обычно устанавливаем свойства объекта как частные или защищенные. Проще говоря, внешний доступ не разрешен, а методы объекта обычно являются общедоступными (общедоступными), потому что общедоступный метод является сообщение, которое объект может принять. В Python существует только два типа разрешений на доступ к атрибутам и методам: общедоступный и частный. Если вы хотите, чтобы атрибут был частным, вы можете использовать два символа подчеркивания в качестве начала при именовании атрибута. Следующий код может проверить это.
```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    # AttributeError: 'Test' object has no attribute '__bar'
    test.__bar()
    # AttributeError: 'Test' object has no attribute '__foo'
    print(test.__foo)


if __name__ == "__main__":
    main()
```

Однако Python не гарантирует строго конфиденциальность частных атрибутов или методов с точки зрения синтаксиса. Он просто изменяет имена частных атрибутов и методов, чтобы предотвратить доступ к ним. Фактически, если вы знаете правила изменения имен, вы все равно можете доступ к ним. Они, следующий код может это проверить. Причину такой настройки можно объяснить известной поговоркой: «Все мы здесь взрослые по согласию ». Потому что большинство программистов считают, что открытость лучше закрытости, и программисты несут ответственность за свои действия.
```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    test._Test__bar()
    print(test._Test__foo)


if __name__ == "__main__":
    main()
```

На практике мы не рекомендуем устанавливать для свойства значение private, потому что это сделает подкласс недоступным (будет обсуждаться позже). Поэтому большинство программистов Python следуют соглашению об именах, которое позволяет имени атрибута начинаться с одного подчеркивания, чтобы указать, что атрибут защищен.Код за пределами этого класса должен быть осторожен при доступе к таким атрибутам. Этот подход не является грамматическим правилом. Атрибуты и методы, начинающиеся с одного символа подчеркивания, по-прежнему доступны для внешнего мира, поэтому чаще всего это намек или метафора. Для этого вы можете прочитать мое "Объяснение Python-тех лет в статья «Те ямы, в которые мы ступили» .
### Объектно-ориентированный столб

У объектно-ориентированного подхода есть три столпа: инкапсуляция, наследование и полиморфизм. Последние две концепции подробно объясняются в следующей главе Здесь мы сначала поговорим о том, что такое инкапсуляция. Мое собственное понимание инкапсуляции - «скрыть все детали реализации, которые могут быть скрыты, и предоставить (предоставить) только простой интерфейс программирования для внешнего мира». Метод, который мы определили в классе, фактически инкапсулирует данные и операцию с данными. После создания объекта нам нужно только отправить сообщение (вызвать метод) объекту для выполнения кода в методе, что означает, что мы Вам нужно знать только имя метода и переданные параметры (внешний вид метода), а не детали реализации метода (внутреннее представление метода).
### Упражнения

#### 练习1：定义一个类描述数字时钟。

参考答案：

```Python
from time import sleep


class Clock(object):
    """数字时钟"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法

        :param hour: 时
        :param minute: 分
        :param second: 秒
        """
        self._hour = hour
        self._minute = minute
        self._second = second

    def run(self):
        """走字"""
        self._second += 1
        if self._second == 60:
            self._second = 0
            self._minute += 1
            if self._minute == 60:
                self._minute = 0
                self._hour += 1
                if self._hour == 24:
                    self._hour = 0

    def show(self):
        """显示时间"""
        return '%02d:%02d:%02d' % \
               (self._hour, self._minute, self._second)


def main():
    clock = Clock(23, 59, 58)
    while True:
        print(clock.show())
        sleep(1)
        clock.run()


if __name__ == '__main__':
    main()
```

#### 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。

参考答案：

```Python
from math import sqrt


class Point(object):

    def __init__(self, x=0, y=0):
        """初始化方法
        
        :param x: 横坐标
        :param y: 纵坐标
        """
        self.x = x
        self.y = y

    def move_to(self, x, y):
        """移动到指定位置
        
        :param x: 新的横坐标
        "param y: 新的纵坐标
        """
        self.x = x
        self.y = y

    def move_by(self, dx, dy):
        """移动指定的增量
        
        :param dx: 横坐标的增量
        "param dy: 纵坐标的增量
        """
        self.x += dx
        self.y += dy

    def distance_to(self, other):
        """计算与另一个点的距离
        
        :param other: 另一个点
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return sqrt(dx ** 2 + dy ** 2)

    def __str__(self):
        return '(%s, %s)' % (str(self.x), str(self.y))


def main():
    p1 = Point(3, 5)
    p2 = Point()
    print(p1)
    print(p2)
    p2.move_by(-1, 2)
    print(p2)
    print(p1.distance_to(p2))


if __name__ == '__main__':
    main()
```

> **说明：** 本章中的插图来自于Grady Booch等著作的[《面向对象分析与设计》](https://item.jd.com/20476561918.html)一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。