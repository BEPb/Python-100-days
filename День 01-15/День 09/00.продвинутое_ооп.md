## Продвинутое объектно-ориентированное программирование

В предыдущих главах мы изучили вводные знания объектно-ориентированного программирования, зная, как определять 
классы, как создавать объекты и как отправлять сообщения объектам. Чтобы лучше использовать идеи 
объектно-ориентированного программирования для разработки программ, нам также необходимо иметь более глубокое 
понимание объектно-ориентированного программирования на Python.

### @property декоратор

Мы обсудили проблему разрешений доступа к атрибутам и методам в Python. Не рекомендуется 
обращаться к свойству напрямую. Если вы хотите получить доступ к свойству, вы можете использовать геттер свойства
(метод доступа) и установщик (модификатор). Метод для выполнения соответствующей операции. Если вы хотите сделать 
это, вы можете использовать оболочку @property для обертывания методов получения и установки, чтобы сделать доступ 
к свойствам безопасным и удобным. Код показан ниже.

```Python
class Person(object):

    def __init__(self, name, age):
        self._name = name
        self._age = age

    # Метод доступа -получателя
    @property
    def name(self):
        return self._name

    # Метод - getter-свойство  (метод доступа)
    @property
    def age(self):
        return self._age

    # Метод-модификатор-(установщик)
    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        if self._age <= 16:
            print('%sиграет в шахматы.' % self._name)
        else:
            print('%sиграет в покер.' % self._name)


def main():
    person = Person('Иван', 12)
    person.play()
    person.age = 22
    person.play()
    # person.name = 'Артем'  # AttributeError: can't set attribute


if __name__ == '__main__':
    main()
```

### \_\_slots\_\_ магия

Мы говорили об этом, я не знаю, осознали ли вы, что Python - это динамический язык. Как правило, динамические языки 
позволяют нам связывать новые свойства или методы с объектами во время работы программы. Конечно, мы также можем 
отвязать свойства и методы, которые уже были связаны. Но если нам нужно ограничить объект настраиваемого типа 
привязкой только к определенным атрибутам, мы можем ограничить его, определив переменную \_\_slots\_\_ в классе.  
Следует отметить, что ограничение \_\_slots\_\_ действует только для объектов текущего класса и не влияет на подклассы.

```Python
class Person(object):

    # Объекты класса Person могут быть привязаны только к атрибутам _name, _age и _gender
    __slots__ = ('_name', '_age', '_gender')

    def __init__(self, name, age):
        self._name = name
        self._age = age

    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        if self._age <= 16:
            print('%sиграет в шахматы.' % self._name)
        else:
            print('%sиграет в покер.' % self._name)


def main():
    person = Person('Иван', 22)
    person.play()

```

### Статические методы и методы классов

Раньше все методы, которые мы определили в классе, были методами объекта, что означает, что все эти методы 
представляют собой сообщения, отправленные объекту. Фактически, методы, которые мы пишем в классе, не обязательно 
должны быть всеми методами объекта. Например, мы определяем класс «треугольник», строим треугольник, передавая 
длину трех сторон, и предоставляем метод для вычисления периметра и площади, но передать в длины трех сторон может 
не позволить построить объект треугольника, поэтому мы можем написать метод, чтобы проверить, могут ли три стороны 
образовывать треугольник. Этот метод, очевидно, не является методом объекта, потому что при вызове этого метода 
объект треугольник не был создан (потому что не всегда три стороны смогут образовывать треугольник), поэтому этот метод 
принадлежит классу треугольника, а не объекту треугольника. Мы можем использовать статические методы для решения 
таких задач, код показан ниже.

```Python
from math import sqrt


class Triangle(object):

    def __init__(self, a, b, c):
        self._a = a
        self._b = b
        self._c = c

    @staticmethod
    def is_valid(a, b, c):
        return a + b > c and b + c > a and a + c > b

    def perimeter(self):
        return self._a + self._b + self._c

    def area(self):
        half = self.perimeter() / 2
        return sqrt(half * (half - self._a) *
                    (half - self._b) * (half - self._c))


def main():
    a, b, c = 3, 4, 5
    # Статические методы и методы класса вызываются, 
    if Triangle.is_valid(a, b, c):
        t = Triangle(a, b, c)
        print(t.perimeter())
        # Вы также можете вызвать метод объекта, отправив сообщение классу, 
        # но вы должны передать объект, который получает сообщение, в качестве параметра
        # print(Triangle.perimeter(t))
        print(t.area())
        # print(Triangle.area(t))
    else:
        print('Не получается сформировать треугольник.')


if __name__ == '__main__':
    main()
```

Подобно статическим методам, Python также может определять методы класса в классах. Первый параметр метода класса 
по соглашению называется cls, который представляет объект информации, связанный с текущим классом (сам класс также 
является объектом метаданных класса). С помощью этого параметра мы можем получить информацию, относящуюся к классу, 
и создать объект класса. Код выглядит следующим образом.
```Python
from time import time, localtime, sleep


class Clock(object):
    """Цифровые часы"""

    def __init__(self, hour=0, minute=0, second=0):
        self._hour = hour
        self._minute = minute
        self._second = second

    @classmethod
    def now(cls):
        ctime = localtime(time())
        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)

    def run(self):
        """вычисление времени"""
        self._second += 1
        if self._second == 60:
            self._second = 0
            self._minute += 1
            if self._minute == 60:
                self._minute = 0
                self._hour += 1
                if self._hour == 24:
                    self._hour = 0

    def show(self):
        """отображение времени"""
        return '%02d:%02d:%02d' % \
               (self._hour, self._minute, self._second)


def main():
    # создавать объекты по методу класса и системному времени
    clock = Clock.now()
    while True:
        print(clock.show())
        sleep(1)
        clock.run()


if __name__ == '__main__':
    main()
```

### Отношения между классами

Проще говоря, существует три типа отношений между классами: отношения is-a, has-a и use-a.

- Это отношение также называется наследованием или обобщением. Например, отношения между студентами и людьми, 
мобильными телефонами и электронными продуктами являются унаследованными отношениями.
- Связь «имеет-а» обычно называется ассоциацией, например отношениями между отделом и сотрудником, а отношения между 
автомобилем и двигателем - это отношения ассоциации; если отношения ассоциации представляют собой целую и частичную 
  ассоциацию, тогда мы назовем это отношением агрегации; если в дальнейшем ответственность несет целое часть 
  жизненного цикла (целое и часть неразделимы, и одно и то же существует одновременно), то это самая сильная 
  взаимосвязь, мы называем ее составной взаимосвязью.
- Отношение использования обычно называется зависимостью. Например, у водителя есть поведение (метод) вождения, где 
  (параметр) использует автомобиль, тогда отношения между водителем и автомобилем являются зависимостью.
Мы можем использовать то, что называется UML (Unified Modeling Language) для объектно-ориентированного 
  моделирования. Одна из важных задач - описать отношения между классами и классами с помощью стандартизованных 
  графических символов. Мы не будем здесь подробно знакомить с UML. Заинтересованные читатели могут сами прочитать 
  книгу «Основы объектно-ориентированного проектирования UML».

Используя эти отношения между классами, мы можем выполнять определенные операции на основе существующих классов или 
создавать новые классы на основе существующих классов. Это важные средства для достижения повторного использования 
кода. Повторное использование существующего кода может не только снизить нагрузку на разработку, но также облегчить 
управление и обслуживание кода. Это технические средства, которые мы все используем в нашей повседневной работе.

### Наследование и полиморфизм

Только что мы упомянули, что вы можете создавать новые классы на основе существующих классов. Один из способов - 
позволить одному классу напрямую наследовать свойства и методы другого класса, тем самым уменьшая написание 
повторяющихся кодов. Мы вызываем родительский класс, который предоставляет информацию о наследовании, который также 
называется суперклассом или базовым классом; тот, который предоставляет информацию о наследовании, мы называем его 
подклассом, который также называется производным классом. Помимо наследования свойств и методов, предоставляемых 
родительским классом, подкласс также может определять свои собственные уникальные свойства и методы. Следовательно, 
подкласс имеет больше возможностей, чем родительский класс. В реальной разработке мы часто используем объект 
подкласса для замены родительского объекта, который является обычным поведением в объектно-ориентированном 
программировании, и соответствующий принцип называется принципом подстановки Рихтера. Давайте сначала рассмотрим 
пример наследования.
```Python
class Person(object):

    def __init__(self, name, age):
        self._name = name
        self._age = age

    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        print('%sуспешно играет.' % self._name)

    def watch_av(self):
        if self._age >= 18:
            print('%sсмотрит фильмы без ограничений.' % self._name)
        else:
            print('%sсмотрит фильмы с ограничениями.' % self._name)


class Student(Person):

    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self._grade = grade

    @property
    def grade(self):
        return self._grade

    @grade.setter
    def grade(self, grade):
        self._grade = grade

    def study(self, course):
        print('%s%sизучает%s.' % (self._grade, self._name, course))


class Teacher(Person):

    def __init__(self, name, age, title):
        super().__init__(name, age)
        self._title = title

    @property
    def title(self):
        return self._title

    @title.setter
    def title(self, title):
        self._title = title

    def teach(self, course):
        print('%s%sведет%s.' % (self._name, self._title, course))


def main():
    stu = Student('Иван', 15, '287 группа')
    stu.study('Математика')
    stu.watch_av()
    t = Teacher('Александр', 38, 'информатика')
    t.teach('Python программирования')
    t.watch_av()


if __name__ == '__main__':
    main()
```

После того, как подкласс унаследует методы родительского класса, он может предоставить новую версию реализации 
существующим методам родительского класса. Это действие называется переопределением метода. Переписав метод, мы 
можем сделать одно и то же поведение родительского класса различными версиями реализации в подклассе. Когда мы 
вызываем этот метод, переопределенный подклассом, разные объекты подкласса будут показывать разное поведение. Это 
полиморфизм (полиморфизм).
```Python
from abc import ABCMeta, abstractmethod


class Pet(object, metaclass=ABCMeta):
    """домашние питомцы"""

    def __init__(self, nickname):
        self._nickname = nickname

    @abstractmethod
    def make_voice(self):
        """сделать голос"""
        pass


class Dog(Pet):
    """собака"""

    def make_voice(self):
        print('%s: гав...' % self._nickname)


class Cat(Pet):
    """кот"""

    def make_voice(self):
        print('%s: мяу...мяу...' % self._nickname)


def main():
    pets = [Dog('Шарик'), Cat('Мурзик'), Dog('Бобик')]
    for pet in pets:
        pet.make_voice()


if __name__ == '__main__':
    main()
```

В приведенном выше коде мы Pet рассматривали как абстрактный класс. Так называемый абстрактный класс - это 
класс, который не может создавать объекты. Этот тип класса существует специально для того, чтобы позволить другим 
классам наследовать его. На грамматическом уровне Python не обеспечивает поддержку абстрактных классов, таких как 
Java или C#, но мы можем добиться эффекта абстрактных классов с помощью метаклассов и оболочек abc-модулей. Если в 
классе есть абстрактные методы, то этот класс не может быть создан. • Изменить (создать объект). В приведенном выше 
коде два подкласса переписывают абстрактный метод в классе и дают разные версии реализации. Когда мы 
вызываем метод в функции, этот метод демонстрирует полиморфное поведение (тот же метод делает разные вещи).


### Упражнения
