"""
Множественное наследование
-С помощью множественного наследования вы можете предоставить класс объектов с множеством возможностей.
-Таким образом вы можете избежать создания слишком большого количества уровней сложных отношений наследования при разработке классов.
Название файла '06.множественное_наследование.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-09
"""


class Father(object):  # определяем класс

    def __init__(self, name):  # инициализация класса
        self._name = name

    def gamble(self):  # метод вывода строки
        print('%s играет в карты. ' % self._name)

    def eat(self):  # метод вывода строки
        print('%s ест и пьет.' % self._name)


class Monk(object):  # определяем класс

    def __init__(self, name):  # инициализация класса
        self._name = name

    def eat(self):  # метод вывода строки
        print('%s быстро ест. ' % self._name)

    def chant(self):  # метод вывода строки
        print('%s поет песни. ' % self._name)


class Musician(object):  # определяем класс

    def __init__(self, name):  # инициализация класса
        self._name = name

    def eat(self):  # метод вывода строки
        print('%s медленно жует. ' % self._name)

    def play_piano(self):  # метод вывода строки
        print('%s играет на пианино. ' % self._name)


# Попробуйте код ниже, чтобы увидеть разницу
# class Son(Monk, Father, Musician):
# class Son(Musician, Father, Monk):


class Son(Father, Monk, Musician):  # определяем класс, для которого родительским являются классы описанные выше

    def __init__(self, name):  # инициализация класса
        Father.__init__(self, name)
        Monk.__init__(self, name)
        Musician.__init__(self, name)


son = Son('Иванушка-царевич')  # создаем объект
son.gamble()  # вызываем метод которого изначально нет в этом классе, но он есть в родительском class Father
son.eat()  # вызываем метод которого изначально нет в этом классе, но он есть во всех родительских классах,
# но т.к. при определении класса в первую очередь указан class Father то и метод в первую очередь берется из этого
# класса, остальные игнорируются
son.chant()  # вызываем метод которого изначально нет в этом классе, но он есть в родительском class Monk
son.play_piano()  # вызываем метод которого изначально нет в этом классе, но он есть в родительском class Musician
