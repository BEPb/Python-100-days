[Вернуться на главную](https://github.com/BEPb/Python-100-days)


## Продвинутое объектно-ориентированное программирование

В предыдущих главах мы изучили вводные знания объектно-ориентированного программирования, зная, как определять 
классы, как создавать объекты и как отправлять сообщения объектам. Чтобы лучше использовать идеи 
объектно-ориентированного программирования для разработки программ, нам также необходимо иметь более глубокое 
понимание объектно-ориентированного программирования на Python. О-о-очень важная тема ограничения доступа к данным и 
методам класса извне - это основа механизма инкапсуляции.

### атрибуты класса python

В Python атрибуты класса могут быть объявлены внутри класса в виде переменных. Они могут быть доступны как через 
экземпляр класса, так и через сам класс. 

Пример:

```python
class MyClass:
    x = 5
    y = "hello"

obj = MyClass()
print(obj.x) # Выводит 5
print(MyClass.y) # Выводит hello
```

В этом примере переменные `x` и `y` являются атрибутами класса `MyClass`. Они могут быть доступны как у экземпляров 
этого класса, так и у самого класса.  

Кроме того, атрибуты класса могут быть инициализированы и изменены в методах класса.

Пример:

```python
class MyClass:
    x = 5
    y = "hello"

    def do_something(self):
        self.x = 10
        MyClass.y = "world"

obj = MyClass()
obj.do_something()
print(obj.x) # Выводит 10
print(MyClass.y) # Выводит world
```

В этом примере метод `do_something` устанавливает значение атрибута `x` у экземпляра класса `MyClass` равным 10, а 
также изменяет значение атрибута `y` у самого класса. 

### атрибуты экземпляра класса python

Атрибуты экземпляра класса в Python - это переменные, которые принадлежат объекту, созданному на основе этого класса.
Атрибуты могут быть установлены при создании экземпляра класса или после его создания. Доступ к атрибутам можно 
получить с помощью оператора доступа `.`.  

Пример создания класса с атрибутами экземпляра:

```python
class MyClass:
    def __init__(self, attribute1, attribute2):
        self.attribute1 = attribute1
        self.attribute2 = attribute2
```

Здесь `attribute1` и `attribute2` являются атрибутами экземпляра класса, которые устанавливаются при создании 
экземпляра. Их значения могут быть получены и изменены следующим образом: 

```python
my_object = MyClass("value1", "value2")
print(my_object.attribute1)  # выводит 'value1'
my_object.attribute2 = "new_value"
print(my_object.attribute2)  # выводит 'new_value'
```

### средства доступа к атрибутам экземпляра класса
Для доступа к атрибутам экземпляра класса Python используются точечная нотация. Например, если у вас есть экземпляр 
класса person: 

```python
class Person:
    def __init__(self, name):
        self.name = name

person = Person('John')
```
то вы можете получить доступ к атрибуту `name` объекта `person` следующим образом:

```python
print(person.name)
# выводит "John"
```

Также можно использовать функции `getattr()` и `setattr()` для доступа к атрибутам объекта.
Да, вы правы! Функции `getattr()` и `setattr()` позволяют получать и устанавливать атрибуты объекта экземпляра 
класса в Python. 

Функция `getattr()` позволяет получить значение атрибута объекта по его имени. Синтаксис:

```python
getattr(object, name[, default])
```

- `object` - объект, атрибут которого нужно получить
- `name` - имя атрибута, значение которого нужно получить
- `default` - необязательный параметр, который указывает значение, которое будет возвращено, если атрибут не найден

Функция `setattr()` позволяет устанавливать значение атрибута объекта по его имени. Синтаксис:

```python
setattr(object, name, value)
```

- `object` - объект, атрибут которого нужно установить
- `name` - имя атрибута, значение которого нужно установить
- `value` - значение, которое нужно установить

Пример:

```python
class MyClass:
    def __init__(self):
        self.my_attribute = 42

my_object = MyClass()

# Получение значения атрибута
my_value = getattr(my_object, 'my_attribute')
print(my_value)  # 42

# Установка значения атрибута
setattr(my_object, 'my_attribute', 100)
print(my_object.my_attribute)  # 100
```

### модификаторы атрибутов

Модификаторы атрибутов объекта экземпляра класса Python - это способы изменения значений атрибутов объектов, 
созданных на основе определенного класса.  

В Python существуют следующие модификаторы атрибутов объекта экземпляра класса:

1. Public - атрибуты с общедоступным доступом и могут быть модифицированы в любом месте программы.

2. Private - атрибуты с закрытым доступом и могут быть модифицированы только внутри класса.

3. Protected - атрибуты с ограниченным доступом, но могут быть модифицированы в наследуемых классах. 

Для каждого модификатора есть свой символ, который указывается перед именем атрибута. Например, для закрытого 
атрибута используется символ подчеркивания перед именем атрибута, например, `_attribute`.  

Чтобы получить доступ к закрытому атрибуту, используйте функцию `get_attribute()`, а для изменения значения - 
функцию `set_attribute()`.  

Если вы хотите создать атрибут с ограниченным доступом, используйте символ одного подчеркивания перед именем 
атрибута, например, `__attribute`. Такой атрибут будет защищен от случайного изменения.  

Обратите внимание, что в Python нет полноценной защиты данных, и все атрибуты можно модифицировать и извлекать, даже 
если они имеют закрытый доступ. 

Ниже приведены примеры:

1. `public` - атрибут, доступный для чтения и записи из любой части программы

```python
class MyClass:
  def __init__(self):
    self.public_attr = 10

my_obj = MyClass()
print(my_obj.public_attr) # 10
my_obj.public_attr = 20
print(my_obj.public_attr) # 20
```

2. `protected` - атрибут, доступный для чтения и записи только внутри класса и его потомков

```python
class MyClass:
  def __init__(self):
    self._protected_attr = 10

class MyChildClass(MyClass):
  def set_protected_attr(self, value):
    self._protected_attr = value
      
my_obj = MyClass()
print(my_obj._protected_attr) # 10
my_child_obj = MyChildClass()
my_child_obj.set_protected_attr(20)
print(my_child_obj._protected_attr) # 20
```

3. `private` - атрибут, доступный только для чтения и записи внутри класса

```python
class MyClass:
  def __init__(self):
    self.__private_attr = 10
    
  def get_private_attr(self):
    return self.__private_attr
  
  def set_private_attr(self, value):
    self.__private_attr = value

my_obj = MyClass()
print(my_obj.get_private_attr()) # 10
my_obj.set_private_attr(20)
print(my_obj.get_private_attr()) # 20
print(my_obj.__private_attr) # AttributeError: 'MyClass' object has no attribute '__private_attr'
```

### Использование __slots__ атрибутов объекта

Атрибут `__slots__` позволяет явно указать, какие атрибуты могут быть созданы и хранимы в экземпляре класса. 
Определяя атрибут `__slots__`, мы ограничиваем возможность создания новых атрибутов в экземпляре класса, что 
приводит к экономии памяти.  

В простейшем случае пример использования `__slots__` может выглядеть так:
```python
class Person:
    __slots__ = ['name', 'age']

    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person('John', 30)
```

В этом примере класс Person ограничивает возможность создания атрибутов `name` и `age`. Если попытаться создать 
новый атрибут, то будет возбуждено исключение `AttributeError`. 

Ограничение списка атрибутов экземпляра класса с помощью `__slots__` особенно полезно, когда нам нужно создать много 
экземпляров класса, и мы знаем заранее, какие атрибуты должны быть определены. Это может уменьшить объем памяти, 
который занимают экземпляры класса в памяти.  

Однако стоит помнить, что использование `__slots__` может иметь и недостатки. В частности, это может замедлять 
некоторые операции, такие как добавление новых атрибутов в экземпляр класса и использование наследования. Поэтому 
следует использовать `__slots__` с учетом требований к производительности.  


### Средство удаления атрибутов объекта

Для удаления атрибутов объекта в Python можно использовать оператор `del`. Например, чтобы удалить атрибут `name` у 
объекта `person`, можно написать следующий код: 

```python
del person.name
```

Если вы хотите удалить объявленную переменную, используя команду `del`, то вы можете сделать это так:

```
foo = 42
del foo
```

После выполнения этого кода переменная `foo` будет удалена, и ее использование в дальнейшем будет вызывать ошибку.

### декоратор класса 

В Python `@` используется для выполнения декораторов. Декораторы позволяют изменять поведение функции без изменения 
кода самой функции. Декоратор - это функция, которая принимает другую функцию и возвращает новую функцию, 
модифицированную согласно заданным правилам. Декораторы используются в Python для установки обработчиков ошибок, для 
логгирования и для управления доступом к ресурсам. Например, декоратор `@property` используется для создания свойств 
объекта, которые можно получить и/или задать с помощью обращения к атрибутам объекта.    

Декоратор класса в Python - это функция, которая принимает класс в качестве аргумента и возвращает измененную версию 
класса. Декораторы класса используются для модификации или расширения классов без изменения их исходного кода. Вот 
пример декоратора класса:  

```python
def my_decorator(cls):
    """
    Декоратор класса
    """
    class NewClass(cls):
        """
        Новый класс
        """
        def __init__(self, *args, **kwargs):
            print("Вызов конструктора класса")
            super().__init__(*args, **kwargs)
    
    return NewClass
```

Этот декоратор принимает класс в качестве аргумента и возвращает новый класс, который наследует исходный класс, но 
имеет новые или измененные методы и атрибуты. В данном примере, новый класс переопределяет конструктор и при 
создании экземпляра класса, он будет выводить текст "Вызов конструктора класса".   

Пример использования декоратора класса:

```python
@my_decorator
class MyClass:
    pass

obj = MyClass()
```

При создании экземпляра класса, будет вызван конструктор нового класса, и на экран будет выведено:

```
Вызов конструктора класса
```


### @property декоратор

Мы обсудили проблему разрешений доступа к атрибутам и методам в Python. По умолчанию ко всем методам и атрибутам 
класса мы можем получить доступ "ИЗ ВНЕ", т.е. вне класса, что может привести иногда к нежелательным последствиям, по 
этому не рекомендуется обращаться к свойству класса напрямую. Если вы хотите получить доступ к свойству, вы можете 
использовать геттер-свойства
(метод получения или доступа) и сеттер-свойство (метод модификатор или установщик). Вы можете 
использовать оболочку @property для обертывания методов геттера или оболочку @имя_геттера.setter для обертывания 
методов сеттера, чтобы сделать доступ к свойствам безопасным и удобным. Пример ниже.

```Python
class Person(object):  # создаем класс

    def __init__(self, name, age):  # проводим инициализацю класса (на входе два аргумента)
        self._name = name  # создаем атрибут self._name задаем его значение полученного аргумента name
        self._age = age  # создаем атрибут self._age задаем его значение полученного аргумента age
    
    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер или аксессор (устанавливает значение из вне класса)
    def name(self):  # метод имени (т.е. при обращении к методу имени - вы получите значение этого атрибута)
        return self._name  # возвращает значение атрибута имени

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер (от англ.get - взять) или аксессор (устанавливает значение из вне класса)
    def age(self):  # метод возвраста (т.е. при обращении к методу возвраста - вы получите значение этого атрибута)
        return self._age  # возвращает значение атрибута возвраста

    # символ '@' означает применение аннотации 
    @age.setter  # спец.метод (свойство) сеттер (от англ.set - установить)- модификатор (установщик) состоит из 
    # имении_свойства_геттера.setter
    def age(self, age):   # метод возвраста (при внесении изменений возвраста - вы производите замену значения 
      # этого атрибута)
        self._age = age    # изменяет значение атрибута возвраста

    def play(self):  # метод проверки возрастных ограничений
        if self._age <= 16:  # если значение возвраста меньше или равно 16
            print('%sиграет в шахматы.' % self._name)  # выводим сообщение с именем
        else:  # иначе
            print('%sиграет в покер.' % self._name)  # выводим сообщение с именем


def main():  # главная функция
    person = Person('Иван', 12)  # создаем объект
    person.play()  # используем метод проверки возврастных ограничений
    person.age = 22  # переопределяем новое значение возвраста Ивана
    person.play()  # повторно используем метод проверки возврастных ограничений, результат проверки изменился т.к. 
    # возвраст изменился
    # person.name = 'Антон'  # но если попытаться изменить атрибут имени, то это сделать не получится, т.к. свойство 
    # изменения (сеттер) для него не написано
    # person.name = 'Антон'  # AttributeError: can't set attribute


if __name__ == '__main__':  # проверка основной программы
    main()  # запуск главной функции
```

### \_\_slots\_\_ магия

Мы говорили об этом, я не знаю, осознали ли вы, что Python - это динамический язык. Как правило, динамические языки 
позволяют нам связывать новые свойства или методы с объектами во время работы программы. Конечно, мы также можем 
отвязать свойства и методы, которые уже были связаны. Но если нам нужно ограничить объект настраиваемого типа 
привязкой только к определенным атрибутам, мы можем ограничить его, определив переменную \_\_slots\_\_ в классе.  
Следует отметить, что ограничение \_\_slots\_\_ действует только для объектов текущего класса и не влияет на подклассы.

```Python
class Person(object):

    # Объекты класса Person могут быть привязаны только к атрибутам _name, _age и _gender
    __slots__ = ('_name', '_age', '_gender')

    def __init__(self, name, age):  # проводим инициализацю класса (на входе два аргумента)
        self._name = name  # создаем атрибут self._name задаем его значение полученного аргумента name
        self._age = age  # создаем атрибут self._age задаем его значение полученного аргумента age

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер или аксессор (устанавливает значение из вне класса)
    def name(self):  # метод имени (т.е. при обращении к методу имени - вы получите значение этого атрибута)
        return self._name  # возвращает значение атрибута имени

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер (от англ.get - взять) или аксессор (устанавливает значение из вне класса)
    def age(self):  # метод возвраста (т.е. при обращении к методу возвраста - вы получите значение этого атрибута)
        return self._age  # возвращает значение атрибута возвраста

    # символ '@' означает применение аннотации 
    @age.setter  # спец.метод (свойство) сеттер (от англ.set - установить)- модификатор (установщик) состоит из 
    # имении_свойства_геттера.setter
    def age(self, age):   # метод возвраста (при внесении изменений возвраста - вы производите замену значения 
      # этого атрибута)
        self._age = age    # изменяет значение атрибута возвраста

    def play(self):  # метод проверки возрастных ограничений
        if self._age <= 16:  # если значение возвраста меньше или равно 16
            print('%sиграет в шахматы.' % self._name)  # выводим сообщение с именем
        else:  # иначе
            print('%sиграет в покер.' % self._name)  # выводим сообщение с именем


def main():  # главная функция
    person = Person('Иван', 12)  # создаем объект
    person.play()  # используем метод проверки возврастных ограничений

```

### Методы, статические методы и методы классов

Синтаксис описания метода ничем не отличается от описания функции, разве что его положением внутри класса и 
характерным первым формальным параметром self, с помощью которого внутри метода можно ссылаться на сам экземпляр 
класса (название self является соглашением, которого придерживаются программисты на Python):

```python
class MyClass(object):
    def mymethod(self, x):
        return x == self._x
```

Раньше все методы, которые мы определили в классе, были методами объекта, что означает, что все эти методы 
представляют собой сообщения, отправленные объекту. Фактически, методы, которые мы пишем в классе, не обязательно 
должны быть всеми методами объекта. Например, мы определяем класс «треугольник», строим треугольник, передавая 
длину трех сторон, и предоставляем метод для вычисления периметра и площади, но даже если и передать длины всех трех 
сторон то это не всегда сможет 
позволить построить объект треугольника. Поэтому нам нужно написать метод, чтобы проверить, могут ли три стороны 
образовывать треугольник. Этот метод, очевидно, не является методом объекта, потому что при вызове этого метода 
объект треугольник не был создан, поэтому этот метод принадлежит классу треугольника, а не объекту треугольника. 
Мы можем использовать статические методы для решения таких задач, код показан ниже.

```Python
from math import sqrt  # импорт функции квадратный корень из модуля математических операций


class Triangle(object):  # определяем класс треугольника

    def __init__(self, a, b, c):  # инициализируем класс, на входе 3 аргумента
        self._a = a  # создаем атрибут стороны а = первому принимаемому аргументу
        self._b = b  # создаем атрибут стороны b = второму принимаемому аргументу
        self._c = c  # создаем атрибут стороны c = третьему принимаемому аргументу

    @staticmethod  # описываем свойство статического метода
    def is_valid(a, b, c):  # метод проверки возможно ли создать треугольник
        return a + b > c and b + c > a and a + c > b  # если 3 условия выполняются, то на выходе значение истина

    def perimeter(self):  # метод расчета периметра
        return self._a + self._b + self._c  # возвращает значение периметра

    def area(self):  # метод расчета площади
        half = self.perimeter() / 2  # вычисление полупериметра (промежуточная величина при расчете площади)
        return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))   # возвращает значение площади


def main():  # главная функция
    a, b, c = 3, 4, 5  # задаем значения сторон треугольника
    # Статические методы и методы класса вызываются, 
    if Triangle.is_valid(a, b, c):  # осуществляем проверку на возможность создать треугольник (если да на входе истина)
        t = Triangle(a, b, c)  # создаем экземпляр класса (объект)
        print(t.perimeter())  # выводим значение периметра
        # Вы тоже самое можете сделать, через обращение к классу
        # print(Triangle.perimeter(t))
        print(t.area())  # выводим значение площади
        # Вы тоже самое можете сделать, через обращение к классу
        # print(Triangle.area(t))
    else:  # иначе
        print('Не получается сформировать треугольник.')


if __name__ == '__main__':  # проверка запуска главной программы
    main()  # запускаем главную функцию
```

### статические методы класса

Статические методы в Python - это методы, которые могут вызываться через класс, а не через экземпляр класса. Они 
могут использоваться для выполнения общих операций, которые не требуют доступа к состоянию экземпляра. 

Чтобы определить статический метод в Python, нужно использовать декоратор `@staticmethod`. Например:

```python
class MyClass:
    @staticmethod
    def my_static_method(argument):
        print("This is my static method with argument", argument)
```

Затем этот метод можно вызвать через класс:

```python
MyClass.my_static_method("something")
```

Статические методы в Python могут быть полезны в различных сценариях, например, если вам нужно определить некоторую 
утилиту внутри класса или если вам нужно создать метод, который не принимает на вход экземпляр класса, но все еще 
может принимать аргументы.  

Статические методы в Python являются синтаксическими аналогами статических функций в основных языках 
программирования. Они не получают ни экземпляр (self), ни класс (cls) первым параметром. Для создания статического 
метода (только «новые» классы могут иметь статические методы) используется декоратор 'staticmethod'


Метод класса. Классовые методы в Python занимают промежуточное положение между статическими и обычными. В то время 
как обычные методы получают первым параметром экземпляр класса, а статические не получают ничего, в классовые 
методы передается класс. Возможность создания классовых методов является одним из следствий того, что в Python 
классы также являются объектами. Для создания классового (только «новые» классы могут иметь классовые методы) 
метода можно использовать декоратор 'classmethod'

Подобно статическим методам, Python также может определять методы класса. Первый параметр метода класса 
по соглашению называется cls, который представляет объект информации, связанный с текущим классом (сам класс также 
является объектом метаданных класса). С помощью этого параметра мы можем получить информацию, относящуюся к классу, 
и создать объект класса. Код выглядит следующим образом.
```Python
from time import time, localtime, sleep  # модуль работы с временем


class Clock(object):  # создаем класс
    """Цифровые часы"""

    def __init__(self, hour=0, minute=0, second=0):  # проводим инициализацию (устанавливаем значения по умолчанию = 0)
        self._hour = hour  # создаем атрибут присваиваем значение принимаего аргумента
        self._minute = minute  # создаем атрибут присваиваем значение принимаего аргумента
        self._second = second  # создаем атрибут присваиваем значение принимаего аргумента

    @classmethod  # определяем значение метод в классе
    def now(cls):  # метод принимает настоящее время
        ctime = localtime(time())  # создаем переменную которая принимает значение текущего времени
        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)  # переопределяем значения атрибутов класса 
    
    def run(self):  # метод вычисления изменения времени
        self._second += 1  # к текущему значению добавим 1 секунду
        if self._second == 60:  # если количество секунд = 60
            self._second = 0  # то начинаем отсчет секунд с нуля
            self._minute += 1  # и к текущемму значению минут добавим 1 минуту
            if self._minute == 60:  # если количество минут = 60
                self._minute = 0  # то начинаем отсчет минут с нуля
                self._hour += 1  # и к текущемму значению часов добавим 1 час
                if self._hour == 24:  # если количество часов = 24
                    self._hour = 0  # то начинаем отсчет часов с нуля

    def show(self):  # метод отображения времени
        return '%02d:%02d:%02d' % (self._hour, self._minute, self._second)  # возвращает значение времени в укзанном
        # формате по два символа на часы, минуты, секунды, разделенные двоеточием


def main():  # главная функция
    # создавать объекты по методу класса и системному времени
    clock = Clock()  # создаем экземпляр класса
    while True:  # бесконечный цикл (пока истина есть истина)
        print(clock.show())  # печатаем значение времени, обращаясь к объекту класса clock методу show()
        time.sleep(1)  # время ожидание = 1 секунда
        clock.run()  # проводим расчет времени в следующую секунду


if __name__ == '__main__':  # проверка запуска основной программы
    main()  # запуск главной функции
```


Методы класса в Python - это функции, которые определены внутри класса и связаны с экземплярами этого класса. Они 
могут быть вызваны на объектах этого класса и выполнять операции на этих объектах.  

Пример:

```python
class MyClass:
    def __init__(self, value):
        self.value = value

    def square(self):
        return self.value ** 2

my_obj = MyClass(4)
result = my_obj.square()
print(result) # выводит 16
```

В примере выше создается класс MyClass с методом square, который принимает значение атрибута объекта и возвращает 
его квадрат. Метод square вызывается на объекте my_obj, созданном из класса MyClass, и возвращает квадрат значения 
его атрибута value.   

Кроме метода __init__, который инициализирует объект, в Python есть множество стандартных методов классов, которые 
могут быть переопределены для изменения поведения объекта. К ним относятся, например: 

- __str__() - возвращает строковое представление объекта, используемое для вывода
- __eq__() - определяет равенство двух объектов
- __lt__() и __gt__() - определяют отношение порядка между объектами
- и многие другие. 

Переопределение стандартных методов классов может быть полезным для реализации собственной логики работы с объектами. 


### Методы в методе класса-экземпляра 

В Python метод класса-экземпляра - это метод, который определен в классе и связан с экземпляром класса. Метод 
класса-экземпляра можно вызывать только для объекта класса. Обычно он используется для доступа и изменения свойств 
объекта или выполнения каких-то операций, которые связаны с объектом.  

Методы класса-экземпляра объявляются с использованием декоратора @classmethod. Обычно первый аргумент метода 
класса-экземпляра - это cls, который ссылается на настоящий класс объекта, а не на экземпляр объекта.  

Пример:

```python
class MyClass:

    @classmethod
    def my_method(cls, arg1, arg2):
        print("Class method of MyClass")
        # Access class variables
        print(cls.var1)
        print(cls.var2)

    def __init__(self):
        self.var1 = "some value"
        self.var2 = "some other value"


obj = MyClass()
obj.my_method("arg1", "arg2")
```

Output:
```
Class method of MyClass
some value
some other value
```



### Перегрузка оператора класса

Перегрузка операторов класса в Python позволяет определить поведение операций для объектов класса, таких как 
сложение, вычитание, сравнение или вызов методов. Для этого используют специальные методы, которые начинаются и 
заканчиваются на двойное подчеркивание.  

Например, чтобы определить метод сложения для объекта класса, нужно использовать метод "__add__". Пример кода:



```python
class MyClass:
    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        return MyClass(self.value + other.value)

a = MyClass(2)
b = MyClass(3)
c = a + b
print(c.value) # выводит 5
```

В этом примере мы перегрузили метод "__add__", чтобы объекты класса MyClass можно было складывать поэлементно. При 
выполнении операции "+" для объектов a и b будет вызываться метод "__add__", в него будут передаваться значения, 
хранящиеся в a и b. В методе "__add__" мы просто складываем значения и создаем новый объект класса MyClass, который 
возвращаем в качестве результата.   

### описание операторов  класса  __ add__ / __sub__ / __or__ / __ getitem__ / __setitem__ / __len__ / __repr__ / __gt__ / __lt__ / __le__ / __ge__ / __eq__ / __ne__ / __contains__

1. `__add__(self, other)` - Оператор для сложения объектов. Можно переопределить для определенного класса.

Оператор `__add__` - это специальный метод в Python, который перегружает оператор сложения "+" для объектов класса. 
Он определяет, как выполняется операция сложения между двумя объектами класса. Как правило, функция `__add__` 
принимает два аргумента - `self` и `other`.   

Пример:

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x, y)
```

В данном примере оператор `__add__` сложения объектов класса `Vector` вычисляет новый вектор, который представляет 
собой сумму двух начальных векторов. Это достигается путем сложения соответствующих координат двух векторов. 

Пример применения:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __add__(self, other):
        return self.age + other.age
    
person1 = Person("John Smith", 30)
person2 = Person("Jane Doe", 25)
print(person1 + person2)
```

В этом примере оператор __add__ определен для класса Person и позволяет сложить возраст двух объектов типа Person. В 
результате выполнения этого кода на экране будет выведено число 55, которое представляет собой сумму возрастов 
объектов person1 и person2.  


2. `__sub__(self, other)` - Оператор для вычитания объектов. Можно переопределить для определенного класса.

Оператор класса __sub__ выполняет математическую операцию вычитания двух объектов класса. Он вызывается при 
использовании знака минус между объектами.  

Пример применения:

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

a = Vector(3, 4)
b = Vector(1, 2)
c = a - b
print(c.x, c.y) # Output: 2 2
```
В этом примере мы создали класс Vector, который имеет две переменные (x и y) и определили оператор класса __sub__, 
который позволяет вычитать два объекта класса Vector. 

Мы создали объекты класса Vector (a и b), а затем вычитаем объект b из объекта a, используя оператор "-". 
Результатом вычитания является новый объект класса Vector (c), который хранит разность векторов a и b. 

3. `__or__(self, other)` - Оператор для логического "или". Можно переопределить для определенного класса.

Оператор класса __or__ представляет логическое "или" и используется для объединения результатов двух операций в один 
объект. 

Пример использования оператора класса __or__:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __or__(self, other):
        """
        Оператор класса __or__ объединяет два объекта Person в новый объект, 
        который будет содержать имя и возраст из одного из объектов. Если в обоих 
        объектах одинаковые значение атрибутов, то берется значение из первого объекта.
        """
        return Person(self.name or other.name, self.age or other.age)
        

person1 = Person("John", 28)
person2 = Person(None, 30)

person3 = person1 | person2

print(person3.name) # Output: John
print(person3.age) # Output: 28
```

В этом примере оператор класса __or__ объединяет два объекта Person, переносит атрибуты из первого объекта, если они 
имеют значение, и резервирует атрибуты из второго объекта, если они отсутствуют в первом. В итоге создается новый 
объект Person с уже объединенными атриб  

4. `__getitem__(self, key)` - Оператор для доступа к элементам коллекции по индексу. Можно переопределить для 
   определенного класса. 

Оператор класса `__getitem__` - это специальный метод в Python, который позволяет получить доступ к элементам 
объекта как к элементам списка или словаря. Он вызывается при обращении к элементу объекта с помощью квадратных 
скобок.   

Пример применения оператора `__getitem__` может выглядеть так:

```python
class MyList:
    def __init__(self, data):
        self.data = data
        
    def __getitem__(self, index):
        return self.data[index]
        
my_list = MyList([1, 2, 3, 4, 5])
print(my_list[2])
```

В этом примере мы создали класс `MyList`, который имеет атрибут `data`, содержащий список чисел. Оператор 
`__getitem__` возвращает элемент списка `data` по указанному индексу `index`. Затем мы создали объект `my_list` и 
использовали оператор `[]` для получения третьего элемента списка.  

В результате выполнения этого кода будет выведено число `3`, так как мы обратились к третьему элементу списка `[1, 2,
3, 4, 5]`. 

5. `__setitem__(self, key, value)` - Оператор для изменения элемента коллекции по индексу. Можно переопределить для 
   определенного класса. 

Оператор `__setitem__` является одним из методов класса Python и определяет поведение объекта при присваивании 
значения элементу по индексу или ключу. Он вызывается при использовании оператора присваивания "[]=". 

Пример:

```python
class CustomList:
    def __init__(self):
        self.items = []
    
    def __setitem__(self, index, value):
        self.items[index] = value + 10

my_list = CustomList()
my_list[0] = 5
print(my_list.items)  # [15]
```

В этом примере мы создаем класс CustomList, который представляет собой список элементов, к каждому из которых при 
добавлении будет добавляться число 10. Метод `__setitem__` получает индекс и значение и преобразует значение, затем 
сохраняет его по указанному индексу в списке.  

Таким образом, при вызове `my_list[0] = 5` оператор `__setitem__` будет вызван, 5 будет преобразован в 15 и сохранен 
как первый элемент списка. После этого мы выводим список `items` и видим `[15]`. 

6. `__len__(self)` - Оператор для получения длины объекта. Можно переопределить для определенного класса.

Оператор класса `__len__` определяет поведение объекта при вызове функции `len()`. Этот оператор должен возвращать 
целое число, которое указывает на количество элементов в объекте.  

Пример:

```python
class MyList:
    def __init__(self, data):
        self.data = data
    
    def __len__(self):
        return len(self.data)

my_list = MyList([1, 2, 3, 4, 5])
print(len(my_list))   # выводит 5
```

В этом примере оператор `__len__` определен для класса `MyList`, который содержит список элементов. При вызове 
функции `len()` на экземпляре класса `MyList`, оператор `__len__` переопределяет поведение функции `len()`, 
возвращая длину списка внутри объекта.  

7. `__repr__(self)` - Оператор, который возвращает строковое представление объекта. Можно переопределить для 
   определенного класса. 

Метод `__repr__` является членом класса Python, который возвращает строку, представляющую объект. Эта строка должна 
быть действительной выражением Python, которое можно использовать для создания нового экземпляра того же класса.   

Пример:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
     
    def __repr__(self):
        return f"Person('{self.name}', {self.age})"
    
    def __str__(self):
        return f"{self.name} is {self.age} years old."
    
p = Person("John", 30)
print(p) # Output: John is 30 years old.
print(repr(p)) # Output: Person('John', 30)
```

Здесь мы переопределили метод `__repr__` для класса `Person`. Мы возвращаем строку, которая представляет объект 
Person. Мы можем использовать `repr()` для получения строкового представления объекта. Обратите внимание, что `str()
` вызывает метод `__str__`, а `repr()` вызывает метод `__repr__`.  

8. `__gt__(self, other)` - Оператор для сравнения двух объектов, проверка больше ли один объект другого.

Оператор `__gt__` (greater than) в Python является магическим методом, который позволяет определить, как один объект 
должен сравниваться с другим объектом в случае оператора сравнения "больше, чем" (>).  

Оператор `__gt__` должен возвращать `True`, если первый объект "больше" второго объекта, и `False` в противном случае.

Пример применения оператора `__gt__`:

```python
class Room:
  def __init__(self, size):
    self.size = size

  def __gt__(self, other):
    return self.size > other.size

room1 = Room(20)
room2 = Room(15)

if room1 > room2:
  print("Room 1 is bigger!")
else:
  print("Room 2 is bigger!")
```

В этом примере мы создали класс `Room`, содержащий только один атрибут `size`. Затем мы определили метод `__gt__`, 
который сравнивает два объекта класса `Room` и возвращает `True`, если первый объект `size` больше второго объекта 
`size`.   

Далее мы создали два объекта класса `Room` и использовали оператор `>` для сравнения их размеров. Как результат, 
наша программа выведет "Room 1 is bigger!", потому что `room1` имеет размер 20, а `room2` - размер 15.  

9. `__lt__(self, other)` - Оператор для сравнения двух объектов, проверка меньше ли один объект другого.

Оператор __lt__ (меньше) является одним из методов сравнения объектов в Python. Он определяет поведение объекта при 
сравнении с другим объектом, используя оператор < (меньше).  

Пример использования оператора __lt__:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

person1 = Person("John", 30)
person2 = Person("Mary", 25)

if person1 < person2:
    print(person1.name + " is younger than "+person2.name)
else:
    print(person2.name + " is younger than "+person1.name)
```

В этом примере мы создали класс Person с двумя атрибутами: name и age. Мы определили оператор __lt__, который 
сравнивает возраст двух объектов класса Person и возвращает True, если возраст первого объекта меньше возраста 
второго объекта, и False в обратном случае.   

Затем мы создали два экземпляра класса Person, person1 и person2, с разными именами и возрастами, а затем 
использовали оператор < для сравнения их возрастов. В зависимости от результата сравнения мы печатаем сообщение о 
том, кто из этих двух людей моложе.  

10. `__le__(self, other)` - Оператор для сравнения двух объектов, проверка меньше или равен ли один объект другому.

Оператор класса __le__ (less than or equal to) переопределяет оператор меньше или равно, который позволяет 
сравнивать объекты класса, определяя, является ли один объект меньше или равным другому.  

Пример использования оператора класса __le__:

```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __le__(self, other):
        return self.age <= other.age

student1 = Student("John", 20)
student2 = Student("Jane", 25)
student3 = Student("Jack", 18)

print(student1 <= student2)  # False
print(student1 <= student3)  # True
```

В этом примере создается класс Student с атрибутами name и age. Оператор класса __le__ переопределяется, чтобы 
сравнивать студентов по возрасту. Затем создаются три студента и производится сравнение при помощи оператора меньше 
или равно. В результате выводится False, потому что возраст student1 (20) больше возраста student2 (25), и True, 
потому что возраст student1 (20) меньше или равен возрасту student3 (18).   


11. `__ge__(self, other)` - Оператор для сравнения двух объектов, проверка больше или равен ли один объект другому.

Оператор класса __ge__ (greater than or equal to) используется для определения поведения объекта при сравнении его 
значений с другими объектами в выражении "больше или равно". Этот оператор возвращает булево значение True, если 
значение объекта больше или равно значению другого объекта, и False в противном случае.  

Пример применения:

```python
class Number:
    def __init__(self, value):
        self.value = value

    def __ge__(self, other):
        return self.value >= other.value

num1 = Number(5)
num2 = Number(10)

print(num1 >= num2) # False
print(num2 >= num1) # True
```

В этом примере мы создали класс Number и определили оператор класса __ge__, который сравнивает значения атрибута 
value объекта с другим объектом класса Number. Затем мы создали два объекта класса Number и проверили их значения с 
помощью оператора "больше или равно". Результаты сравнения были напечатаны на экране.  

12. `__eq__(self, other)` - Оператор для проверки равенства двух объектов.

Оператор `__eq__` - это специальный метод в Python, используемый для сравнения объектов по значению. Он вызывается, 
когда два объекта сравниваются оператором равенства (==). 

Оператор `__eq__` принимает два аргумента - `self` (первый объект) и `other` (второй объект), с которым происходит 
сравнение. Он должен вернуть `True`, если оба объекта равны, и `False` в противном случае. 

Пример использования оператора `__eq__`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __eq__(self, other):
        return self.age == other.age


person1 = Person("Alice", 25)
person2 = Person("Bob", 25)

print(person1 == person2) # True
```

В этом примере мы создали класс `Person`, который имеет два атрибута - имя и возраст. Метод `__eq__` сравнивает 
объекты по возрасту и возвращает `True`, если они равны. 

Затем мы создали два объекта класса `Person` - `person1` и `person2` . При сравнении этих объектов оператором `==`, 
он вызывает метод `__eq__` и возвращает `True`, поскольку они имеют одинаковый возраст.  

13. `__ne__(self, other)` - Оператор для проверки неравенства двух объектов.

Оператор класса `__ne__` используется для определения не равенства объектов. Он вызывается автоматически при 
использовании оператора `!=` между двумя объектами экземплярами класса. 

Вот пример применения оператора класса `__ne__`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __ne__(self, other):
        return not self.name == other.name and not self.age == other.age

# Создаем экземпляры класса
person1 = Person("Иван", 25)
person2 = Person("Анна", 30)

# Используем оператор !=
if person1 != person2:
    print("Эти два человека разные.")
else:
    print("Эти два человека одинаковые.")
```

В данном примере мы создали класс `Person` со свойствами `name` и `age`, и определили оператор класса `__ne__`, 
чтобы определить, являются ли два объекта экземплярами класса одинаковыми или разными. Затем мы создали два 
экземпляра класса `Person` - `person1` и `person2` - и использовали оператор `!=` для определения, разные ли они. В 
наш   

14. `__contains__(self, item)` - Оператор для проверки, содержит ли определенный элемент в объекте. Можно 
    переопределить для определенного класса. 

Оператор класса `__contains__` в Python позволяет определить, содержится ли определенный элемент в объекте. 

Оператор класса `__contains__` реализуется в виде метода `in` и принимает два аргумента: `self` и `item`. Метод 
должен возвращать `True`, если `item` содержится в объекте, и `False` в противном случае.  

Пример применения:

```python
class ShoppingCart:
    def __init__(self):
        self.products = []

    def add_product(self, product):
        self.products.append(product)

    def __contains__(self, item):
        return item in self.products


cart = ShoppingCart()
cart.add_product("apple")
cart.add_product("banana")
cart.add_product("pear")

print("apple" in cart)   # True
print("orange" in cart)   # False
```

В этом примере метод `__contains__` определяет, содержится ли элемент в списке продуктов корзины `ShoppingCart`. 
Если элемент содержится в списке, метод возвращает `True`, иначе возвращает `False`. Таким образом, мы можем 
использовать оператор `in` для проверки, добавлен ли элемент в корзину при запуске `print` команды.  


### Отношения между классами

Отношения между классами (объектами) могут быть различными. Они могут быть наследованиями, агрегациями, ассоциациями,
зависимостями и другими.  

- Наследование - это отношение, которое возникает между классами, где один класс наследуется от другого. 
  Родительский класс является базовым для дочернего, который наследует его свойства и методы.
- Агрегация - это отношение, где объект одного класса содержит в себе объекты другого класса. Агрегированный объект 
  может существовать и использоваться независимо от объекта-агрегатора.
- Ассоциация - это отношение, где объекты двух классов связаны между собой. Это может быть однонаправленная или 
  двунаправленная связь.
- Зависимость - это отношение, когда объект одного класса использует объект другого класса в своей работе. Если 
  объект-зависимый изменяется, это может повлиять на работу объекта-зависимого.  

Каждый тип отношений помогает программисту проектировать программное обеспечение и правильно использовать объекты в 
его работе, чтобы создавать более структурированный и эффективный код. 

#### Наследование

Классы в Python могут наследовать свойства и методы от других классов. Это позволяет создавать иерархию классов, 
облегчает повторное использование кода и упрощает разработку. 

В Python для реализации наследования классов используется следующий синтаксис:

```python
class ParentClass:
    # определение родительского класса

class ChildClass(ParentClass):
    # определение дочернего класса с наследованием от родительского класса
```

Дочерний класс `ChildClass` наследует все атрибуты и методы, объявленные в родительском классе `ParentClass`, и может добавлять собственные атрибуты и методы. 

Также можно наследовать от нескольких классов, для этого нужно просто указать список родительских классов через запятую:

```python
class ChildClass(ParentClass1, ParentClass2, ...):
    # определение дочернего класса с наследованием от нескольких родительских классов
```


Пример наследования классов:

```python
# определяем базовый класс Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hello(self):
        print(f"Привет, меня зовут {self.name}.")

# класс Employee наследует свойства и методы класса Person
class Employee(Person):
    def __init__(self, name, age, salary):
        super().__init__(name, age) # вызываем конструктор родительского класса
        self.salary = salary

    def show_salary(self):
        print(f"Моя зарплата {self.salary} долларов в месяц.")

# создаем экземпляр класса Employee
john = Employee("John", 30, 10000)
john.say_hello() # вызываем метод из класса Person
john.show_salary() # вызываем метод из класса Employee
```

В этом примере класс `Employee` наследует свойства и методы класса `Person`. При создании экземпляра класса 
`Employee` вызывается конструктор `__init__` класса `Person` с помощью метода `super()`. Таким образом, в 
конструкторе класса `Employee` мы можем использовать свойства и методы родительского класса `Person`, а также 
добавить свои собственные свойства, например, `salary`, и методы, например, `show_salary()`.   

Вот пример наследования классов в Python:

```python
class Animal: # базовый (родительский) класс
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass

class Dog(Animal): # класс-наследник
    def speak(self):
        return "Woof!"

class Cat(Animal): # класс-наследник
    def speak(self):
        return "Meow!"

dog = Dog("Rufus")
print(dog.name) # выводит "Rufus"
print(dog.speak()) # выводит "Woof!"

cat = Cat("Fluffy")
print(cat.name) # выводит "Fluffy"
print(cat.speak()) # выводит "Meow!"
```

В данном примере классы `Dog` и `Cat` наследуют атрибуты и методы класса `Animal`. Обратите внимание, что метод 
`speak` в классе `Animal` определен как пустой, и что в классах-наследниках `Dog` и `Cat` он переопределен. Класс 
`Dog` использует метод `speak` для вывода звука, которые издает собака, а класс `Cat` использует метод `speak` для 
вывода звука, которые издает кошка.   

Для вызова родительского метода класса в Python используется функция `super()`. Например, если у вас есть дочерний 
класс `Child`, унаследованный от родительского класса `Parent`, и вам нужно вызвать родительский метод 
`parent_method`, то вы можете сделать это следующим образом:  

```python
class Parent:
    def parent_method(self):
        print("parent_method called")

class Child(Parent):
    def child_method(self):
        super().parent_method()
        print("child_method called")

c = Child()
c.child_method() # вызовет parent_method и child_method
```

Обратите внимание, что при вызове метода родительского класса с помощью `super()`, не требуется указывать имя 
родительского класса. 

Для переписывания метода класса Python нужно воспользоваться следующим синтаксисом:

```python
class MyClass:
    def my_method(self):
        # старая реализация метода

    def my_method(self):
        # новая реализация метода
```

В данном примере мы переписываем метод `my_method()`. Старая реализация этого метода будет заменена на новую. 

Здесь важно учесть, что если у класса уже были экземпляры (объекты), то при переписывании метода, старый метод 
останется прежним для старых экземпляров, а новый метод будет использоваться только для новых экземпляров класса. 
Если необходимо обновить метод для всех экземпляров класса, то нужно изменять атрибуты с инстансами класса напрямую.   

Для определения типа класса в языке Python можно использовать функцию `type()`. Например, если у нас есть класс 
`MyClass`, чтобы увидеть его тип, можно ввести такой код: 

```python
class MyClass:
    pass
    
print(type(MyClass))
```

В результате выполнения этого кода в консоли будет выведено `classobj` для Python 2 или `type` для Python 3. Также 
можно вызвать функцию `type()` для экземпляра класса, чтобы получить его тип: 

```python
my_obj = MyClass()
print(type(my_obj))
```

В результате выполнения этого кода в консоли будет выведено `<class '__main__.MyClass'>`, где `__main__` - имя 
текущего модуля, а `MyClass` - имя класса. 


Для создания класса, который будет наследовать от другого класса (родительского), нужно указать имя родительского 
класса внутри определения нового класса. Кроме того, можно добавлять новые методы и атрибуты в новый класс. 

Пример создания класса, наследуемого от класса Gem:

```python
class Diamond(Gem):
    def __init__(self, name, size):
        super().__init__(name, size)
        self.color = "white"
        self.cut = "brilliant"
```

В этом примере класс Diamond наследуется от класса Gem, и имеет два дополнительных атрибута color и cut. Конструктор 
Diamond вызывает конструктор Gem с помощью функции super(). 

Теперь объекты класса Diamond будут иметь все атрибуты и методы класса Gem, а также новые атрибуты color и cut, 
определенные в классе Diamond. 


Алмазное наследование (diamond inheritance) - это ситуация, когда класс наследуется от двух классов, каждый из 
которых наследуется от одного и того же суперкласса. 


Например:

```python
class A:
    def do_something(self):
        print("doing something in A")

class B(A):
    def do_something(self):
        print("doing something in B")

class C(A):
    def do_something(self):
        print("doing something in C")

class D(B, C):
    pass
```

Здесь класс D наследуется от двух классов - B и C, каждый из которых наследуется от класса A. Если мы теперь 
создадим экземпляр класса D и вызовем метод do_something(): 

```python
d = D()
d.do_something()
```

то мы увидим вывод "doing something in B". Это происходит потому, что Python ищет метод do_something() в следующем 
порядке: D, B, C, A. Причем, если метод не найден в B, то он ищется в C, а затем в A. В данном случае, метод 
do_something() находится в классе B и вызывается из него.  

Алгоритм C3 (C3 linearization) - это алгоритм, который определяет порядок поиска в множественном наследовании. Он 
используется в Python (начиная с версии 2.3) и других языках, поддерживающих множественное наследование. 

Алгоритм C3 использует алгоритм линейного наследования (linearization), который строит одномерный порядок 
наследования для каждого класса. Из этих порядков строится "линеаризация" каждого класса в графе наследования, 
учитывая порядок приоритетов. Эта линеаризация будет использоваться для определения порядка поиска методов.  



Например, для классов A, B и C из примера выше, линейные порядки наследования будут выглядеть так:

- A: A
- B: B, A
- C: C, A
- D: D, B, C, A

Здесь мы видим, что порядок поиска методов для класса D будет следующим: D, B, C, A - тот же порядок, который мы 
использовали при объявлении класса D. 

Algorithms C3 реализован в Python в методе MRO (Method Resolution Order) и может быть использован для определения 
правильного порядка вызова методов при множественном наследовании. 

#### Агрегация

Агрегация, когда один объект входит в состав другого, или отношение «HAS-A» («имеет»), реализуется в Python с 
помощью ссылок. Python имеет несколько встроенных типов контейнеров: список, словарь, множество. Можно определить 
собственные классы контейнеров со своей логикой доступа к хранимым объектам. (Следует заметить, что в Python 
агрегацию можно считать разновидностью ассоциации, так реально объекты не вложены друг в друга в памяти и, более 
того, время жизни элемента может не зависеть от времени жизни контейнера.)


Следующий класс является примером контейнера-словаря, дополненного возможностью доступа к значениям при помощи 
синтаксиса доступа к атрибутам:

```python
class Storage(dict):  # создаем класс
    def __getattr__(self, key):  # метод добавить атрибут ключа словаря
        try:
            return self[key]
        except KeyError, k:
            raise AttributeError, k

    def __setattr__(self, key, value):  # метод добавить значения по ключу
        self[key] = value

    def __delattr__(self, key):  # метод удаления ключа
        try:
            del self[key]
        except KeyError, k:
            raise AttributeError, k

    def __repr__(self):
        return '<Storage ' + dict.__repr__(self) + '>'
```

Ассоциация классов в Python - это отношение между двумя классами, где один класс использует функциональность другого 
класса как свое свойство, метод или функциональность. Ассоциация может быть однонаправленной или двунаправленной.   

Пример ассоциации классов в Python:

```python
class Dog:
    def __init__(self, name):
        self.name = name

class Person:
    def __init__(self, name, dog):
        self.name = name
        self.pet = dog

dog1 = Dog("Buddy")
person1 = Person("Alice", dog1)
print(person1.pet.name) # выводит "Buddy"
```

В этом примере класс "Person" имеет атрибут "pet", который ссылается на объект класса "Dog". Это отношение является 
однонаправленной ассоциацией, так как класс "Dog" не имеет ссылки на класс "Person".  


Ассоциация и слабые ссылки. Отношение использования («USE-A») экземпляров одного класса другими является достаточно 
общим отношением. При использовании один класс обычно зависит от интерфейса другого класса (хотя эта зависимость 
может быть и взаимной). Если один объект использует другой, он обязательно содержит ссылку на него. Объекты могут 
ссылаться и друг на друга. В этом случае возникают циклические ссылки. Если ссылающиеся друг на друга объекты 
удалить, то они уже не могут быть удалены интерпретатором Python с помощью механизма подсчета ссылок. Удалением 
таких объектов занимается сборщик мусора.      

Ассоциацию объектов без присущих ссылкам проблем можно осуществить с помощью слабых ссылок. Слабые ссылки не 
препятствуют удалению объекта. 

Для работы со слабыми ссылками применяется модуль 'weakref'.
Модуль `weakref` в Python используется для создания слабых ссылок на объекты классов. Слабые ссылки представляют 
собой ссылки на объекты, которые не увеличивают счётчик ссылок на объект и не мешают ему быть удалённым сборщиком 
мусора, если на объект больше нет сильных ссылок. Примером использования модуля `weakref` может быть ассоциация 
классов.   

`weakref` позволяет связывать объекты классов так, чтобы они зависели друг от друга, но при этом предотвращает 
циклические ссылки. Вот пример: 

```python
import weakref

class MyClass:
    def __init__(self, name):
        self.name = name
        self.other = None

    def set_other(self, other):
        self.other = weakref.ref(other)

    def get_other(self):
        return self.other()

a = MyClass('A')
b = MyClass('B')

a.set_other(b)
b.set_other(a)

print(a.get_other().name) # 'B'
print(b.get_other().name) # 'A'

del a
print(b.get_other()) # None
```

Класс `MyClass` имеет атрибут `other`, который может быть связан с другим объектом класса `MyClass`. Метод 
`set_other` связывает два объекта, создавая слабую ссылку с помощью `weakref.ref`. Метод `get_other` возвращает 
объект, на который ссылается слабая ссылка.  

При удалении объекта `a` в конце примера, объект `b` больше не имеет сильной ссылки на `a`, так что слабая ссылка 
тоже удаляется, и метод `get_other` возвращает `None`. 

#### Пример зависимости классов в Python:

```python
class Person:
    def __init__(self, name):
        self.name = name

class Student(Person):
    def __init__(self, name, student_id):
        super().__init__(name)
        self.student_id = student_id

class Teacher(Person):
    def __init__(self, name, subject):
        super().__init__(name)
        self.subject = subject

class Class:
    def __init__(self, teacher, students):
        self.teacher = teacher
        self.students = students

teacher1 = Teacher("Mr. Smith", "Math")
student1 = Student("John", "123")
student2 = Student("Jane", "456")

my_class = Class(teacher1, [student1, student2])
```
В этом примере есть четыре класса: `Person`, `Student`, `Teacher` и `Class`. Каждый класс имеет свои поля и методы. 

Класс `Student` наследует от `Person`. Класс `Teacher` также наследует от `Person`. Класс `Class` имеет два поля: 
учителя и список студентов.  

При создании экземпляра класса `Class`, мы передаем экземпляр класса `Teacher` и список экземпляров класса `Student`.
Таким образом, класс `Class` зависит от классов `Teacher` и `Student`.  


### Наследование и полиморфизм

Только что мы упомянули, что вы можете создавать новые классы на основе существующих классов. Один из способов - 
позволить одному классу напрямую наследовать свойства и методы другого класса, тем самым уменьшая написание 
повторяющихся кодов. Мы вызываем родительский класс, который предоставляет информацию о наследовании, который также 
называется суперклассом или базовым классом; тот, который предоставляет информацию о наследовании, мы называем его 
подклассом или производным классом. Помимо наследования свойств и методов, предоставляемых 
родительским классом, подкласс также может определять свои собственные уникальные свойства и методы. Следовательно, 
подкласс имеет больше возможностей, чем родительский класс. В реальной разработке мы часто используем объект 
подкласса для замены родительского объекта, который является обычным поведением в объектно-ориентированном 
программировании, и соответствующий принцип называется принципом подстановки Рихтера. Давайте сначала рассмотрим 
пример наследования.
```Python
class Person(object):

    def __init__(self, name, age):
        self._name = name
        self._age = age

    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        print('%sуспешно играет.' % self._name)

    def watch_av(self):
        if self._age >= 18:
            print('%sсмотрит фильмы без ограничений.' % self._name)
        else:
            print('%sсмотрит фильмы с ограничениями.' % self._name)


class Student(Person):

    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self._grade = grade

    @property
    def grade(self):
        return self._grade

    @grade.setter
    def grade(self, grade):
        self._grade = grade

    def study(self, course):
        print('%s%s изучает %s.' % (self._grade, self._name, course))


class Teacher(Person):

    def __init__(self, name, age, title):
        super().__init__(name, age)
        self._title = title

    @property
    def title(self):
        return self._title

    @title.setter
    def title(self, title):
        self._title = title

    def teach(self, course):
        print('%s%sведет%s.' % (self._name, self._title, course))


def main():
    stu = Student('Иван', 15, '287 группа')
    stu.study('Математика')
    stu.watch_av()
    t = Teacher('Александр', 38, 'информатика')
    t.teach('Python программирования')
    t.watch_av()


if __name__ == '__main__':
    main()
```

После того, как подкласс унаследует методы родительского класса, он может предоставить новую версию реализации 
существующим методам родительского класса. Это действие называется переопределением метода. Переписав метод, мы 
можем сделать одно и то же поведение родительского класса различными версиями реализации в подклассе. Когда мы 
вызываем этот метод, переопределенный подклассом, разные объекты подкласса будут показывать разное поведение. Это 
полиморфизм.
```Python
from abc import ABCMeta, abstractmethod


class Pet(object, metaclass=ABCMeta):
    """домашние питомцы"""

    def __init__(self, nickname):
        self._nickname = nickname

    @abstractmethod
    def make_voice(self):
        """сделать голос"""
        pass


class Dog(Pet):
    """собака"""

    def make_voice(self):
        print('%s: гав...' % self._nickname)


class Cat(Pet):
    """кот"""

    def make_voice(self):
        print('%s: мяу...мяу...' % self._nickname)


def main():
    pets = [Dog('Шарик'), Cat('Мурзик'), Dog('Бобик')]
    for pet in pets:
        pet.make_voice()


if __name__ == '__main__':
    main()
```

В приведенном выше коде мы Pet рассматривали как абстрактный класс. Так называемый абстрактный класс - это 
класс, который не может создавать объекты. Этот тип класса существует специально для того, чтобы позволить другим 
классам наследовать его. На грамматическом уровне Python не обеспечивает поддержку абстрактных классов, таких как 
Java или C#, но мы можем добиться эффекта абстрактных классов с помощью метаклассов и оболочек abc-модулей. Если в 
классе есть абстрактные методы, то этот класс не может быть создан. • Изменить (создать объект). В приведенном выше 
коде два подкласса переписывают абстрактный метод в классе и дают разные версии реализации. Когда мы 
вызываем метод в функции, этот метод демонстрирует полиморфное поведение (тот же метод делает разные вещи).


Обычных возможностей объектно-ориентированного программирования хватает далеко не всегда. В некоторых случаях 
требуется изменить сам характер системы классов: расширить язык новыми типами классов, изменить стиль взаимодействия 
между классами и окружением, добавить некоторые дополнительные аспекты, затрагивающие все используемые в приложении 
классы, и т. п.   

При объявлении метакласса за основу можно взять класс 'type'. Пример:
```python
# описание метакласса
class myobject(type):
    # небольшое вмешательство в момент выделения памяти для класса
    def __new__(cls, name, bases, dict):
        print("NEW", cls.__name__, name, bases, dict)
        return type.__new__(cls, name, bases, dict)
    # небольшое вмешательство в момент инициализации класса
    def __init__(cls, name, bases, dict):
        print("INIT", cls.__name__, name, bases, dict)
        return super(myobject, cls).__init__(name, bases, dict)


# порождение класса на основе метакласса (заменяет оператор class)
MyObject = myobject("MyObject", (), {})


# обычное наследование другого класса из только что порожденного
class MySubObject(MyObject):
    def __init__(self, param):
        print(param)

# получение экземпляра класса
myobj = MySubObject("parameter")
```

### Устойчивость объектов
Объекты всегда имеют своё представление в памяти компьютера и их время жизни не больше времени работы программы. 
Однако зачастую необходимо сохранять данные между запусками приложения и/или передавать их на другие компьютеры. 
Одним из решений этой проблемы является устойчивость объектов (англ. object persistence) которая достигается с 
помощью хранения представлений объектов (сериализацией) в виде байтовых последовательностей и их последующего 
восстановления (десериализация).

Модуль pickle является наиболее простым способом «консервирования» объектов в Python.

Следующий пример показывает, как работает сериализация и десериализация:

```python
# сериализация
import pickle

p = set([1, 2, 3, 5, 8])
pickle.dumps(p)
'c__builtin__\nset\np0\n((lp1\nI8\naI1\naI2\naI3\naI5\natp2\nRp3\n.'

# де-сериализация
import pickle
p = pickle.loads('c__builtin__\nset\np0\n((lp1\nI8\naI1\naI2\naI3\naI5\natp2\nRp3\n.')
print(p)
#set([8, 1, 2, 3, 5])
```

Получаемая при сериализации строка может быть передана по сети, записана в файл или специальное хранилище объектов, 
а позже — прочитана. Сериализации поддаются не все объекты. Некоторые объекты (например, классы и функции) 
представляются своими именами, поэтому для десериализации требуется наличие тех же самых классов. Нужно отметить, 
что нельзя десериализовать данные из непроверенных источников с помощью модуля pickle, так как при этом возможны 
практически любые действия на локальной системе. При необходимости обмениваться данными по незащищенным каналам или 
с ненадежными источниками можно воспользоваться другими модулями для сериализации.

В основе сериализации объекта стоит представление его состояния. По умолчанию состояние объекта — это все, что 
записано в его полях. Пользовательские классы могут управлять сериализацией, предоставляя состояние объекта явным 
образом (методы __getstate__, __setstate__ и др.).

На стандартном для Python механизме сериализации построена работа модуля shelve (shelve (англ. глаг.) — ставить на 
полку; сдавать в архив). Модуль предоставляет функцию open. Объект, который она возвращает, работает аналогично 
словарю, но объекты сериализуются и сохраняются в файле: 

```python
import shelve
s = shelve.open("myshelve.bin")
s['abc'] = [1, 2, 3]
s.close()
# ..... 
s = shelve.open("myshelve.bin")
print(s['abc'])
# [1, 2, 3]
```


Примеры:
  - 01.Связь_между_объектами.py
  - 02.атрибуты.py
  - 03.атрибуты.py
  - 04.зависимости.py
  - 05.множественное_наследование.py
  - 06.множественное_наследование.py
  - 07.переопределение.py
  - 08.перегрузка_оператора.py
  - 09.унаследованные_приложения.py
  - 10.метод_экземпляра.py


[Вернуться на главную](https://github.com/BEPb/Python-100-days)

[К следующему занятию](https://github.com/BEPb/Python-100-days/tree/master/%D0%94%D0%B5%D0%BD%D1%8C%2001-15/%D0%94%D0%B5%D0%BD%D1%8C%20011/README.md)
