## Продвинутое объектно-ориентированное программирование

В предыдущих главах мы изучили вводные знания объектно-ориентированного программирования, зная, как определять 
классы, как создавать объекты и как отправлять сообщения объектам. Чтобы лучше использовать идеи 
объектно-ориентированного программирования для разработки программ, нам также необходимо иметь более глубокое 
понимание объектно-ориентированного программирования на Python. О-о-очень важная тема ограничения доступа к данным и 
методам класса извне - это основа механизма инкапсуляции.

### @property декоратор

Мы обсудили проблему разрешений доступа к атрибутам и методам в Python. По умолчанию ко всем методам и атрибутам 
класса мы можем получить доступ "ИЗ ВНЕ", т.е. вне класса, что может привести иногда к нежелательным последствиям, по 
этому не рекомендуется обращаться к свойству класса напрямую. Если вы хотите получить доступ к свойству, вы можете 
использовать геттер-свойства
(метод получения или доступа) и сеттер-свойство (метод модификатор или установщик). Вы можете 
использовать оболочку @property для обертывания методов геттера или оболочку @имя_геттера.setter для обертывания 
методов сеттера, чтобы сделать доступ к свойствам безопасным и удобным. Пример ниже.

```Python
class Person(object):  # создаем класс

    def __init__(self, name, age):  # проводим инициализацю класса (на входе два аргумента)
        self._name = name  # создаем атрибут self._name задаем его значение полученного аргумента name
        self._age = age  # создаем атрибут self._age задаем его значение полученного аргумента age
    
    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер или аксессор (устанавливает значение из вне класса)
    def name(self):  # метод имени (т.е. при обращении к методу имени - вы получите значение этого атрибута)
        return self._name  # возвращает значение атрибута имени

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер (от англ.get - взять) или аксессор (устанавливает значение из вне класса)
    def age(self):  # метод возвраста (т.е. при обращении к методу возвраста - вы получите значение этого атрибута)
        return self._age  # возвращает значение атрибута возвраста

    # символ '@' означает применение аннотации 
    @age.setter  # спец.метод (свойство) сеттер (от англ.set - установить)- модификатор (установщик) состоит из 
    # имении_свойства_геттера.setter
    def age(self, age):   # метод возвраста (при внесении изменений возвраста - вы производите замену значения 
      # этого атрибута)
        self._age = age    # изменяет значение атрибута возвраста

    def play(self):  # метод проверки возрастных ограничений
        if self._age <= 16:  # если значение возвраста меньше или равно 16
            print('%sиграет в шахматы.' % self._name)  # выводим сообщение с именем
        else:  # иначе
            print('%sиграет в покер.' % self._name)  # выводим сообщение с именем


def main():  # главная функция
    person = Person('Иван', 12)  # создаем объект
    person.play()  # используем метод проверки возврастных ограничений
    person.age = 22  # переопределяем новое значение возвраста Ивана
    person.play()  # повторно используем метод проверки возврастных ограничений, результат проверки изменился т.к. 
    # возвраст изменился
    # person.name = 'Антон'  # но если попытаться изменить атрибут имени, то это сделать не получится, т.к. свойство 
    # изменения (сеттер) для него не написано
    # person.name = 'Антон'  # AttributeError: can't set attribute


if __name__ == '__main__':  # проверка основной программы
    main()  # запуск главной функции
```

### \_\_slots\_\_ магия

Мы говорили об этом, я не знаю, осознали ли вы, что Python - это динамический язык. Как правило, динамические языки 
позволяют нам связывать новые свойства или методы с объектами во время работы программы. Конечно, мы также можем 
отвязать свойства и методы, которые уже были связаны. Но если нам нужно ограничить объект настраиваемого типа 
привязкой только к определенным атрибутам, мы можем ограничить его, определив переменную \_\_slots\_\_ в классе.  
Следует отметить, что ограничение \_\_slots\_\_ действует только для объектов текущего класса и не влияет на подклассы.

```Python
class Person(object):

    # Объекты класса Person могут быть привязаны только к атрибутам _name, _age и _gender
    __slots__ = ('_name', '_age', '_gender')

    def __init__(self, name, age):  # проводим инициализацю класса (на входе два аргумента)
        self._name = name  # создаем атрибут self._name задаем его значение полученного аргумента name
        self._age = age  # создаем атрибут self._age задаем его значение полученного аргумента age

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер или аксессор (устанавливает значение из вне класса)
    def name(self):  # метод имени (т.е. при обращении к методу имени - вы получите значение этого атрибута)
        return self._name  # возвращает значение атрибута имени

    # символ '@' означает применение аннотации
    @property  # спец.метод (свойство) геттер (от англ.get - взять) или аксессор (устанавливает значение из вне класса)
    def age(self):  # метод возвраста (т.е. при обращении к методу возвраста - вы получите значение этого атрибута)
        return self._age  # возвращает значение атрибута возвраста

    # символ '@' означает применение аннотации 
    @age.setter  # спец.метод (свойство) сеттер (от англ.set - установить)- модификатор (установщик) состоит из 
    # имении_свойства_геттера.setter
    def age(self, age):   # метод возвраста (при внесении изменений возвраста - вы производите замену значения 
      # этого атрибута)
        self._age = age    # изменяет значение атрибута возвраста

    def play(self):  # метод проверки возрастных ограничений
        if self._age <= 16:  # если значение возвраста меньше или равно 16
            print('%sиграет в шахматы.' % self._name)  # выводим сообщение с именем
        else:  # иначе
            print('%sиграет в покер.' % self._name)  # выводим сообщение с именем


def main():  # главная функция
    person = Person('Иван', 12)  # создаем объект
    person.play()  # используем метод проверки возврастных ограничений

```

### Методы, статические методы и методы классов

Синтаксис описания метода ничем не отличается от описания функции, разве что его положением внутри класса и 
характерным первым формальным параметром self, с помощью которого внутри метода можно ссылаться на сам экземпляр 
класса (название self является соглашением, которого придерживаются программисты на Python):

```python
class MyClass(object):
    def mymethod(self, x):
        return x == self._x
```

Раньше все методы, которые мы определили в классе, были методами объекта, что означает, что все эти методы 
представляют собой сообщения, отправленные объекту. Фактически, методы, которые мы пишем в классе, не обязательно 
должны быть всеми методами объекта. Например, мы определяем класс «треугольник», строим треугольник, передавая 
длину трех сторон, и предоставляем метод для вычисления периметра и площади, но даже если и передать длины всех трех 
сторон то это не всегда сможет 
позволить построить объект треугольника. Поэтому нам нужно написать метод, чтобы проверить, могут ли три стороны 
образовывать треугольник. Этот метод, очевидно, не является методом объекта, потому что при вызове этого метода 
объект треугольник не был создан, поэтому этот метод принадлежит классу треугольника, а не объекту треугольника. 
Мы можем использовать статические методы для решения таких задач, код показан ниже.

```Python
from math import sqrt  # импорт функции квадратный корень из модуля математических операций


class Triangle(object):  # определяем класс треугольника

    def __init__(self, a, b, c):  # инициализируем класс, на входе 3 аргумента
        self._a = a  # создаем атрибут стороны а = первому принимаемому аргументу
        self._b = b  # создаем атрибут стороны b = второму принимаемому аргументу
        self._c = c  # создаем атрибут стороны c = третьему принимаемому аргументу

    @staticmethod  # описываем свойство статического метода
    def is_valid(a, b, c):  # метод проверки возможно ли создать треугольник
        return a + b > c and b + c > a and a + c > b  # если 3 условия выполняются, то на выходе значение истина

    def perimeter(self):  # метод расчета периметра
        return self._a + self._b + self._c  # возвращает значение периметра

    def area(self):  # метод расчета площади
        half = self.perimeter() / 2  # вычисление полупериметра (промежуточная величина при расчете площади)
        return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))   # возвращает значение площади


def main():  # главная функция
    a, b, c = 3, 4, 5  # задаем значения сторон треугольника
    # Статические методы и методы класса вызываются, 
    if Triangle.is_valid(a, b, c):  # осуществляем проверку на возможность создать треугольник (если да на входе истина)
        t = Triangle(a, b, c)  # создаем экземпляр класса (объект)
        print(t.perimeter())  # выводим значение периметра
        # Вы тоже самое можете сделать, через обращение к классу
        # print(Triangle.perimeter(t))
        print(t.area())  # выводим значение площади
        # Вы тоже самое можете сделать, через обращение к классу
        # print(Triangle.area(t))
    else:  # иначе
        print('Не получается сформировать треугольник.')


if __name__ == '__main__':  # проверка запуска главной программы
    main()  # запускаем главную функцию
```
Статические методы в Python являются синтаксическими аналогами статических функций в основных языках 
программирования. Они не получают ни экземпляр (self), ни класс (cls) первым параметром. Для создания статического 
метода (только «новые» классы могут иметь статические методы) используется декоратор 'staticmethod'


Метод класса. Классовые методы в Python занимают промежуточное положение между статическими и обычными. В то время 
как обычные методы получают первым параметром экземпляр класса, а статические не получают ничего, в классовые 
методы передается класс. Возможность создания классовых методов является одним из следствий того, что в Python 
классы также являются объектами. Для создания классового (только «новые» классы могут иметь классовые методы) 
метода можно использовать декоратор 'classmethod'

Подобно статическим методам, Python также может определять методы класса. Первый параметр метода класса 
по соглашению называется cls, который представляет объект информации, связанный с текущим классом (сам класс также 
является объектом метаданных класса). С помощью этого параметра мы можем получить информацию, относящуюся к классу, 
и создать объект класса. Код выглядит следующим образом.
```Python
from time import time, localtime, sleep  # модуль работы с временем


class Clock(object):  # создаем класс
    """Цифровые часы"""

    def __init__(self, hour=0, minute=0, second=0):  # проводим инициализацию (устанавливаем значения по умолчанию = 0)
        self._hour = hour  # создаем атрибут присваиваем значение принимаего аргумента
        self._minute = minute  # создаем атрибут присваиваем значение принимаего аргумента
        self._second = second  # создаем атрибут присваиваем значение принимаего аргумента

    @classmethod  # определяем значение метод в классе
    def now(cls):  # метод принимает настоящее время
        ctime = localtime(time())  # создаем переменную которая принимает значение текущего времени
        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)  # переопределяем значения атрибутов класса 
    
    def run(self):  # метод вычисления изменения времени
        self._second += 1  # к текущему значению добавим 1 секунду
        if self._second == 60:  # если количество секунд = 60
            self._second = 0  # то начинаем отсчет секунд с нуля
            self._minute += 1  # и к текущемму значению минут добавим 1 минуту
            if self._minute == 60:  # если количество минут = 60
                self._minute = 0  # то начинаем отсчет минут с нуля
                self._hour += 1  # и к текущемму значению часов добавим 1 час
                if self._hour == 24:  # если количество часов = 24
                    self._hour = 0  # то начинаем отсчет часов с нуля

    def show(self):  # метод отображения времени
        return '%02d:%02d:%02d' % (self._hour, self._minute, self._second)  # возвращает значение времени в укзанном
        # формате по два символа на часы, минуты, секунды, разделенные двоеточием


def main():  # главная функция
    # создавать объекты по методу класса и системному времени
    clock = Clock()  # создаем экземпляр класса
    while True:  # бесконечный цикл (пока истина есть истина)
        print(clock.show())  # печатаем значение времени, обращаясь к объекту класса clock методу show()
        time.sleep(1)  # время ожидание = 1 секунда
        clock.run()  # проводим расчет времени в следующую секунду


if __name__ == '__main__':  # проверка запуска основной программы
    main()  # запуск главной функции
```

### Отношения между классами

Агрегация, когда один объект входит в состав другого, или отношение «HAS-A» («имеет»), реализуется в Python с 
помощью ссылок. Python имеет несколько встроенных типов контейнеров: список, словарь, множество. Можно определить 
собственные классы контейнеров со своей логикой доступа к хранимым объектам. (Следует заметить, что в Python 
агрегацию можно считать разновидностью ассоциации, так реально объекты не вложены друг в друга в памяти и, более 
того, время жизни элемента может не зависеть от времени жизни контейнера.)


Следующий класс является примером контейнера-словаря, дополненного возможностью доступа к значениям при помощи 
синтаксиса доступа к атрибутам:
```python
class Storage(dict):  # создаем класс
    def __getattr__(self, key):  # метод добавить атрибут ключа словаря
        try:
            return self[key]
        except KeyError, k:
            raise AttributeError, k

    def __setattr__(self, key, value):  # метод добавить значения по ключу
        self[key] = value

    def __delattr__(self, key):  # метод удаления ключа
        try:
            del self[key]
        except KeyError, k:
            raise AttributeError, k

    def __repr__(self):
        return '<Storage ' + dict.__repr__(self) + '>'
```
Ассоциация и слабые ссылки. Отношение использования («USE-A») экземпляров одного класса другими является достаточно общим отношением. При использовании один класс обычно зависит от интерфейса другого класса (хотя эта зависимость может быть и взаимной). Если один объект использует другой, он обязательно содержит ссылку на него. Объекты могут ссылаться и друг на друга. В этом случае возникают циклические ссылки. Если ссылающиеся друг на друга объекты удалить, то они уже не могут быть удалены интерпретатором Python с помощью механизма подсчета ссылок. Удалением таких объектов занимается сборщик мусора.

Ассоциацию объектов без присущих ссылкам проблем можно осуществить с помощью слабых ссылок. Слабые ссылки не препятствуют удалению объекта.

Для работы со слабыми ссылками применяется модуль 'weakref'.




### Наследование и полиморфизм

Только что мы упомянули, что вы можете создавать новые классы на основе существующих классов. Один из способов - 
позволить одному классу напрямую наследовать свойства и методы другого класса, тем самым уменьшая написание 
повторяющихся кодов. Мы вызываем родительский класс, который предоставляет информацию о наследовании, который также 
называется суперклассом или базовым классом; тот, который предоставляет информацию о наследовании, мы называем его 
подклассом или производным классом. Помимо наследования свойств и методов, предоставляемых 
родительским классом, подкласс также может определять свои собственные уникальные свойства и методы. Следовательно, 
подкласс имеет больше возможностей, чем родительский класс. В реальной разработке мы часто используем объект 
подкласса для замены родительского объекта, который является обычным поведением в объектно-ориентированном 
программировании, и соответствующий принцип называется принципом подстановки Рихтера. Давайте сначала рассмотрим 
пример наследования.
```Python
class Person(object):

    def __init__(self, name, age):
        self._name = name
        self._age = age

    @property
    def name(self):
        return self._name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, age):
        self._age = age

    def play(self):
        print('%sуспешно играет.' % self._name)

    def watch_av(self):
        if self._age >= 18:
            print('%sсмотрит фильмы без ограничений.' % self._name)
        else:
            print('%sсмотрит фильмы с ограничениями.' % self._name)


class Student(Person):

    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self._grade = grade

    @property
    def grade(self):
        return self._grade

    @grade.setter
    def grade(self, grade):
        self._grade = grade

    def study(self, course):
        print('%s%s изучает %s.' % (self._grade, self._name, course))


class Teacher(Person):

    def __init__(self, name, age, title):
        super().__init__(name, age)
        self._title = title

    @property
    def title(self):
        return self._title

    @title.setter
    def title(self, title):
        self._title = title

    def teach(self, course):
        print('%s%sведет%s.' % (self._name, self._title, course))


def main():
    stu = Student('Иван', 15, '287 группа')
    stu.study('Математика')
    stu.watch_av()
    t = Teacher('Александр', 38, 'информатика')
    t.teach('Python программирования')
    t.watch_av()


if __name__ == '__main__':
    main()
```

После того, как подкласс унаследует методы родительского класса, он может предоставить новую версию реализации 
существующим методам родительского класса. Это действие называется переопределением метода. Переписав метод, мы 
можем сделать одно и то же поведение родительского класса различными версиями реализации в подклассе. Когда мы 
вызываем этот метод, переопределенный подклассом, разные объекты подкласса будут показывать разное поведение. Это 
полиморфизм.
```Python
from abc import ABCMeta, abstractmethod


class Pet(object, metaclass=ABCMeta):
    """домашние питомцы"""

    def __init__(self, nickname):
        self._nickname = nickname

    @abstractmethod
    def make_voice(self):
        """сделать голос"""
        pass


class Dog(Pet):
    """собака"""

    def make_voice(self):
        print('%s: гав...' % self._nickname)


class Cat(Pet):
    """кот"""

    def make_voice(self):
        print('%s: мяу...мяу...' % self._nickname)


def main():
    pets = [Dog('Шарик'), Cat('Мурзик'), Dog('Бобик')]
    for pet in pets:
        pet.make_voice()


if __name__ == '__main__':
    main()
```

В приведенном выше коде мы Pet рассматривали как абстрактный класс. Так называемый абстрактный класс - это 
класс, который не может создавать объекты. Этот тип класса существует специально для того, чтобы позволить другим 
классам наследовать его. На грамматическом уровне Python не обеспечивает поддержку абстрактных классов, таких как 
Java или C#, но мы можем добиться эффекта абстрактных классов с помощью метаклассов и оболочек abc-модулей. Если в 
классе есть абстрактные методы, то этот класс не может быть создан. • Изменить (создать объект). В приведенном выше 
коде два подкласса переписывают абстрактный метод в классе и дают разные версии реализации. Когда мы 
вызываем метод в функции, этот метод демонстрирует полиморфное поведение (тот же метод делает разные вещи).


Обычных возможностей объектно-ориентированного программирования хватает далеко не всегда. В некоторых случаях требуется изменить сам характер системы классов: расширить язык новыми типами классов, изменить стиль взаимодействия между классами и окружением, добавить некоторые дополнительные аспекты, затрагивающие все используемые в приложении классы, и т. п.

При объявлении метакласса за основу можно взять класс 'type'. Пример:
```python
# описание метакласса
class myobject(type):
    
  # небольшое вмешательство в момент выделения памяти для класса
    def __new__(cls, name, bases, dict):
        print "NEW", cls.__name__, name, bases, dict
        return type.__new__(cls, name, bases, dict)
    
  # небольшое вмешательство в момент инициализации класса
    def __init__(cls, name, bases, dict):
        print "INIT", cls.__name__, name, bases, dict
        return super(myobject, cls).__init__(name, bases, dict)


# порождение класса на основе метакласса (заменяет оператор class)
MyObject = myobject("MyObject", (), {})


# обычное наследование другого класса из только что порожденного
class MySubObject(MyObject):
    def __init__(self, param):
        print param

# получение экземпляра класса
myobj = MySubObject("parameter")
```

### Устойчивость объектов
Объекты всегда имеют своё представление в памяти компьютера и их время жизни не больше времени работы программы. 
Однако зачастую необходимо сохранять данные между запусками приложения и/или передавать их на другие компьютеры. 
Одним из решений этой проблемы является устойчивость объектов (англ. object persistence) которая достигается с 
помощью хранения представлений объектов (сериализацией) в виде байтовых последовательностей и их последующего 
восстановления (десериализация).

Модуль pickle является наиболее простым способом «консервирования» объектов в Python.

Следующий пример показывает, как работает сериализация и десериализация:

```python
# сериализация
import pickle
p = set([1, 2, 3, 5, 8])
pickle.dumps(p)
'c__builtin__\nset\np0\n((lp1\nI8\naI1\naI2\naI3\naI5\natp2\nRp3\n.'

# де-сериализация
import pickle
p = pickle.loads('c__builtin__\nset\np0\n((lp1\nI8\naI1\naI2\naI3\naI5\natp2\nRp3\n.')
print(p)
#set([8, 1, 2, 3, 5])
```

Получаемая при сериализации строка может быть передана по сети, записана в файл или специальное хранилище объектов, 
а позже — прочитана. Сериализации поддаются не все объекты. Некоторые объекты (например, классы и функции) 
представляются своими именами, поэтому для десериализации требуется наличие тех же самых классов. Нужно отметить, 
что нельзя десериализовать данные из непроверенных источников с помощью модуля pickle, так как при этом возможны 
практически любые действия на локальной системе. При необходимости обмениваться данными по незащищенным каналам или 
с ненадежными источниками можно воспользоваться другими модулями для сериализации.

В основе сериализации объекта стоит представление его состояния. По умолчанию состояние объекта — это все, что 
записано в его полях. Пользовательские классы могут управлять сериализацией, предоставляя состояние объекта явным 
образом (методы __getstate__, __setstate__ и др.).

На стандартном для Python механизме сериализации построена работа модуля shelve (shelve (англ. глаг.) — ставить на 
полку; сдавать в архив). Модуль предоставляет функцию open. Объект, который она возвращает, работает аналогично 
словарю, но объекты сериализуются и сохраняются в файле: 

```python
import shelve
s = shelve.open("myshelve.bin")
s['abc'] = [1, 2, 3]
s.close()
# ..... 
s = shelve.open("myshelve.bin")
print(s['abc'])
# [1, 2, 3]
```