## Графический пользовательский интерфейс и разработка игр

### Графический интерфейс на основе модуля tkinter

GUI - это аббревиатура от Graphical User Interface.Графический интерфейс пользователя должен быть знаком людям, 
которые использовали компьютеры, и здесь нет необходимости вдаваться в подробности. Модуль разработки графического 
интерфейса Python по умолчанию - tkinter (в предыдущей версии Python 3 он назывался Tkinter). Из этого имени видно, 
что он основан на Tk. Tk - это набор инструментов, первоначально разработанный для Tcl, а затем перенесенный во 
многие другие языки сценариев, он предоставляет кроссплатформенные элементы управления с графическим интерфейсом. 
Конечно, Tk не является последним и лучшим выбором, и у него нет особенно мощных элементов управления с графическим 
интерфейсом. На самом деле разработка приложений с графическим интерфейсом - не лучшая работа Python. Если вам 
действительно нужно использовать Python для разработки приложений с графическим интерфейсом, wxPython, PyQt, PyGTK 
и т. д. модули - хороший выбор.

По сути, использование tkinter для разработки приложений с графическим интерфейсом требует выполнения следующих 5 
шагов:

1. Импортируйте то, что нам нужно, в модуль tkinter.
2. Создайте объект окна верхнего уровня и используйте его для размещения всего приложения с графическим интерфейсом 
   пользователя.
3. Добавьте компоненты GUI к объекту окна верхнего уровня.
4. Организуйте функции этих компонентов графического интерфейса с помощью кода.
5. Войдите в основной цикл событий (основной цикл).


Следующий код демонстрирует, как использовать tkinter для создания простого приложения с графическим интерфейсом.

```Python
import tkinter  # импорт модуля графического интерфейса
import tkinter.messagebox  # импорт модуля сообщений


def main():  # главная функция
    flag = True  # переменной присваивается значение истина

    # Изменить текст на этикетке
    def change_label_text():  # функция изменения текста
        nonlocal flag  # получает значение переменной
        flag = not flag  # смена значения переменной на противоположное
        color, msg = ('red', 'Привет, пользователь!')\
            if flag else ('blue', 'Прощай, пользователь!')
        label.config(text=msg, fg=color)  # меняет цвет текста и сам текст в окне

    # подтвердить выход
    def confirm_to_quit():
        if tkinter.messagebox.askokcancel('вопрос', 'вы уверены, что хотите выйти?'):  # создает окно подтверждения 
            # выхода
            top.quit()  # если ответ положительный то закрывает все окна

    # Создать окно верхнего уровня
    top = tkinter.Tk()
    # Установить размер окна
    top.geometry('440x160')
    # Установить заголовок окна
    top.title('окно')
    # Создать объект метки
    label = tkinter.Label(top, text='Программа запущена!', font='Arial -32', fg='red')
    label.pack(expand=1)
    # Создаем контейнер для кнопок
    panel = tkinter.Frame(top)
    # Создать объект кнопки
    button1 = tkinter.Button(panel, text='изменить', command=change_label_text)  # задаем реакцию на эту кнопку - это
    # запуск функции Изменить текст на этикетке

    # Создать объект кнопки
    button1.pack(side='left')
    button2 = tkinter.Button(panel, text='выход', command=confirm_to_quit)  # задаем реакцию на эту кнопку - это
    # запуск функции выхода из программы
    button2.pack(side='right')
    panel.pack(side='bottom')   
    tkinter.mainloop()  # Создаем объект окна, основной обработчик 


if __name__ == '__main__':  # если запущена эта программа
    main()  # выполняем главную функцию
```

Следует отметить, что приложения с графическим интерфейсом пользователя обычно управляются событиями. Причина входа 
в основной цикл обработки событий состоит в том, чтобы отслеживать возникновение различных событий, таких как мышь 
и клавиатура, и выполнять соответствующий код для обработки события, поскольку событие будет продолжаться. 
Следовательно, такой цикл должен работать и ждать следующего события. С другой стороны, Tk предоставляет три 
менеджера компоновки для размещения элементов управления. Элементы управления могут быть размещены с помощью 
менеджера компоновки. Три менеджера компоновки: Placer (размер и размещение элемента управления указывается 
разработчиком), Packer (автоматически заполняется элемент управления в соответствующее положение) и сетка 
(разместите элемент управления на основе координат сетки), я не буду здесь вдаваться в подробности.


### Используйте Pygame для разработки игр

Pygame - это модуль Python с открытым исходным кодом, специально используемый для разработки мультимедийных 
приложений (например, видеоигр), который включает поддержку изображений, звуков, видео, событий, столкновений и т. 
Д. Pygame, построенный на SDL, на основе SDL - это кроссплатформенная библиотека для разработки мультимедиа, 
использующая язык C, широко используется в разработке игр, симуляторов, игроков и т. Д. Pygame позволяет 
разработчикам игр больше не быть привязанными к основному языку и может уделять больше внимания функциям и логике игры.

Далее, давайте завершим простую игру. Название игры - «Большой мяч ест маленький мяч». Конечно, цель не в завершении 
этой игры и не в том, чтобы научиться пользоваться Pygame. Самое главное, это понять, как 
использовать фронт в процессе работы объектно-ориентированного программирования, научиться использовать эту идею 
программирования для решения реальных проблем.


#### Сделайте игровое окно, рисование в окне, Загрузить изображение, Реализуйте эффект анимации

Вы можете рисовать в окне с помощью функции модуля рисования в pygame. Графика, которую можно рисовать, включает: 
линии, прямоугольники, многоугольники, круги, эллипсы, дуги и т. Д. Следует отметить, что система координат экрана 
должна установить верхний левый угол экрана в качестве начала координат (0, 0), справа - положительное направление 
оси x, а вниз - положительное направление оси y, выражая позицию или устанавливая размер, наши единицы измерения по 
умолчанию - это пиксели. Так называемый пиксель - это точка на экране. Вы можете использовать программное 
обеспечение для просмотра изображений, чтобы попытаться увеличить изображение в несколько раз, чтобы увидеть эти 
точки. Представление цвета в pygame использует представление трех основных цветов цветового света, то есть значение 
RGB цвета указывается через кортеж или список, и каждое значение находится в диапазоне от 0 до 255, потому что 
каждый основной цвет использует 8-битный (бит) Три цвета эквивалентны в общей сложности 24 битам, что часто 
называют «24-битным представлением цвета».


Если вам нужно загрузить изображение непосредственно в окно, вы можете использовать функцию модуля изображения в 
pygame для загрузки изображения, а затем blit визуализировать изображение с помощью метода объекта окна, полученного 
ранее. Код показан ниже.

Что касается слова «анимация», то оно всем знакомо. На самом деле, для достижения анимационных эффектов сам принцип 
очень прост. Он заключается в непрерывном воспроизведении прерывистых изображений. Добейтесь нужного количества 
кадров в секунду - получите анимацию. Если вы 
хотите заставить мяч в приведенном выше коде двигаться, вы можете использовать переменную, чтобы указать положение 
мяча, изменить положение мяча в цикле, а затем обновить все окно.


```Python
import pygame


def main():  # главная функция
    # Определить контейнер, используемый для хранения всех шаров
    balls = []
    # Инициализировать импортированный модуль pygame
    pygame.init()
    # Инициализировать окно для отображения и установить размер окна
    screen = pygame.display.set_mode((800, 600))
    print(screen.get_width())
    print(screen.get_height())
    # Установить заголовок текущего окна
    pygame.display.set_caption('большой мяч ест маленький мяч')
    # Определить переменные для представления положения мяча на экране
    x, y = 50, 50
    running = True
    # Открываем цикл обработки событий для обработки происходящих событий
    while running:
        # Получить события из очереди сообщений и обработать их
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                x, y = event.pos
                radius = randint(10, 100)
                sx, sy = randint(-10, 10), randint(-10, 10)
                color = Color.random_color()
                ball = Ball(x, y, radius, sx, sy, color)
                balls.append(ball)
        screen.fill((255, 255, 255))
        for ball in balls:
            if ball.alive:
                ball.draw(screen)
            else:
                balls.remove(ball)
        pygame.display.flip()
        
        # Менять положение шара каждые 50 миллисекунд и обновлять окно
        pygame.time.delay(50)
        for ball in balls:
            ball.move(screen)
            for other in balls:
                ball.eat(other)


if __name__ == '__main__':  # если запущена эта программа
    main()  # выполнить главную функцию
```

#### Проверка на удар, Обработка событий

Обычно в игре много объектов, и "столкновение" между этими объектами неизбежно, например, снаряд попадает в  самолет,
ящик падает на землю и т. Д. Обнаружение столкновений является  важной проблемой, с которой необходимо иметь дело в 
большинстве игр. Модуль спрайтов (анимационных спрайтов) pygame  обеспечивает поддержку обнаружения столкновений. 
Здесь мы пока не будем вводить функции, предоставляемые модулем  спрайтов на самом деле очень просто определить, 
сталкиваются ли два маленьких шарика, просто проверьте, меньше  ли расстояние между центром сферы, чем сумма 
радиусов двух шариков. Чтобы делать больше маленьких шариков,  мы можем обрабатывать события мыши, чтобы создавать 
маленькие шарики случайного цвета, размера и скорости движения  одним щелчком мыши. Конечно, для этого мы можем 
взять то, что мы изучили до объектно-ориентированного знания применяются.

События мыши могут обрабатываться в цикле type событий, тип события может определяться pos свойствами объекта 
события, а положение щелчка мыши может быть получено из свойств.  Если вы хотите обрабатывать события клавиатуры в 
этом месте, подход аналогичен подходу к событиям мыши.

```Python
from enum import Enum, unique
from math import sqrt
from random import randint

import pygame


@unique
class Color(Enum):
    """цвет"""

    RED = (255, 0, 0)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    GRAY = (242, 242, 242)

    @staticmethod
    def random_color():
        """Получить случайные цвета"""
        r = randint(0, 255)
        g = randint(0, 255)
        b = randint(0, 255)
        return (r, g, b)


class Ball(object):
    """мяч"""

    def __init__(self, x, y, radius, sx, sy, color=Color.RED):
        """Метод инициализации"""
        self.x = x
        self.y = y
        self.radius = radius
        self.sx = sx
        self.sy = sy
        self.color = color
        self.alive = True

    def move(self, screen):
        """двигаться"""
        self.x += self.sx
        self.y += self.sy
        if self.x - self.radius <= 0 or self.x + self.radius >= screen.get_width():
            self.sx = -self.sx
        if self.y - self.radius <= 0 or self.y + self.radius >= screen.get_height():
            self.sy = -self.sy

    def eat(self, other):
        """Ешьте другие мячи"""
        if self.alive and other.alive and self != other:
            dx, dy = self.x - other.x, self.y - other.y
            distance = sqrt(dx ** 2 + dy ** 2)
            if distance < self.radius + other.radius \
                    and self.radius > other.radius:
                other.alive = False
               	self.radius = self.radius + int(other.radius * 0.146)

    def draw(self, screen):
        """Нарисуйте мяч на окне"""
        pygame.draw.circle(screen, self.color,
                           (self.x, self.y), self.radius, 0)
```

Соединив два вышеуказанных фрагмента кода вместе, мы завершили игру «большой мяч ест маленький мяч» (как показано 
на рисунке ниже). Если быть точным, это не игра, но мы прошли базовые знания по созданию small game. Этот пример 
показывает всем, что, обладая этими знаниями, вы можете начать свой путь к разработке мини-игр.  Фактически, в 
приведенном выше коде есть много областей, заслуживающих улучшения. Например,  код для обновления окна и перемещения 
мяча не следует помещать в цикл событий. После изучения знаний о  многопоточности используйте фоновый поток для 
обработки эти вещи. Это лучший выбор. Если мы хотим улучшить  взаимодействие с пользователем, мы также можем 
добавить в игру фоновую музыку и воспроизводить звуковые эффекты,  когда мяч сталкивается с мячом. Используя микшер 
и музыкальные модули pygame, мы можем легко это сделать. Вы можете  это сделать  сами поймите это знание. На самом 
деле, если вы хотите узнать больше о pygame, лучший учебник - это официальный сайт  pygame. Если у вас нет проблем 
со своим английским, вы можете проверить это. Если вы хотите разрабатывать 3D-игры,  pygame кажется вам неадекватным.
Читатели, интересующиеся разработкой 3D-игр, могут захотеть взглянуть на Panda3D.