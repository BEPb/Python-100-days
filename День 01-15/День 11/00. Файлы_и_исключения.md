## Файлы и исключения

Фактическая разработка часто сталкивается с операциями сцены сохранения данных , и наиболее простой способ сохранения данных - сохранить данные в файл. Говоря о слове «файл», возможно, сначала необходимо популяризировать знания о файловой системе , но здесь мы не тратим впустую перо и чернила, чтобы представить эту концепцию, пожалуйста, поймите это через Википедию.

Реализовать операции чтения и записи файлов в Python на самом деле очень просто. С помощью встроенных openфункций Python мы можем указать имя файла, режим работы, информацию о кодировке и т. Д., Чтобы получить объект файла операции, а затем прочитать и записать файл. Упомянутый здесь режим работы относится к типу файла, который нужно открыть (символьный файл или двоичный файл) и какой операции (чтение, запись или добавление) необходимо выполнить, как показано в следующей таблице.
| 操作模式 | 具体含义                         |
| -------- | -------------------------------- |
| `'r'`    | Читать (по умолчанию)                    |
| `'w'`    | Запись (предыдущее содержимое будет обрезано первым)       |
| `'x'`    | Напишите, если файл уже существует, будет сгенерировано исключение |
| `'a'`    | Добавить, записать содержимое в конец существующего файла |
| `'b'`    | Двоичный режим                      |
| `'t'`    | Текстовый режим (по умолчанию)                 |
| `'+'`    | Обновление (как чтение, так и запись)         |


### Чтение и запись текстовых файлов

При чтении текстового файла вам необходимо 'open' указать имя файла с путем при использовании функции (можно 
использовать относительный путь или абсолютный путь) и установить режим файла 'r'(если не указан, то также значение по умолчанию 'r'), а затем encodingуказать кодировка через параметр (если не указано, значение по умолчанию - Нет, тогда при чтении файла используется кодировка операционной системы по умолчанию), если не гарантируется, что кодировка, используемая при сохранении файла, соответствует кодировке указан параметром кодирования, то он может быть не в состоянии. Символ был декодирован и чтение не удалось. В следующем примере показано, как читать простой текстовый файл.

```Python
def main():
    f = open('99.txt', 'r', encoding='utf-8')
    print(f.read())
    f.close()


if __name__ == '__main__':
    main()
```

Обратите внимание на приведенный выше код.Если openфайл, указанный функцией, не существует или не может быть открыт, это вызовет ненормальное состояние и вызовет сбой программы. Чтобы сделать код надежным и отказоустойчивым, мы можем использовать механизм исключений Python для правильной обработки кода, который может возникнуть во время выполнения, как показано ниже.
```Python
def main():
    f = None
    try:
        f = open('99.txt', 'r', encoding='utf-8')
        print(f.read())
    except FileNotFoundError:
        print('Невозможно открыть указанный файл!')
    except LookupError:
        print('Указана неизвестная кодировка!')
    except UnicodeDecodeError:
        print('Ошибка декодирования при чтении файла!')
    finally:
        if f:
            f.close()


if __name__ == '__main__':
    main()
```

В Python мы можем поместить tryкод, который может иметь условия во время выполнения, в блок кода, и за tryодним или несколькими блоками кода может следовать блок кода, exceptчтобы отловить возможные аномальные условия. Например, в процессе чтения файла выше он будет срабатывать, FileNotFoundErrorесли файл не может быть найден , и будет указана неизвестная кодировка LookupError. Если файл не может быть декодирован указанным способом при чтении файла, он будет запущен UnicodeDecodeErrorМы tryпроследили три exceptотдельных процесса обработки Три разных аномальных состояния. Наконец, мы используем finallyблок кода, чтобы закрыть открытый файл и освободить внешние ресурсы, полученные в программе. Поскольку finallyкод блока будет выполняться независимо от того, является ли программа нормальной или ненормальной (даже когда функция sysмодуля вызывается для exitвыхода в среде Python finallyблок будет выполнен, т.к. exitфункция по существу вызывает SystemExitисключение), поэтому мы обычно называем finallyблок «всегда выполнять блок кода», он больше всего подходит для освобождения внешних ресурсов. Если вы не finallyхотите закрывать файловый объект в блоке кода для освобождения ресурсов, вы также можете использовать синтаксис контекста, чтобы withуказать контекст файлового объекта с помощью ключевых слов и автоматически освободить файловые ресурсы при выходе из контекста. Код показан ниже .

```Python
def main():
    try:
        with open('99.txt', 'r', encoding='utf-8') as f:
            print(f.read())
    except FileNotFoundError:
        print('Невозможно открыть указанный файл!')
    except LookupError:
        print('Указана неизвестная кодировка!')
    except UnicodeDecodeError:
        print('Ошибка декодирования при чтении файла!')


if __name__ == '__main__':
    main()
```

Помимо использования readметода файлового объекта для чтения файла, вы также можете использовать for-inцикл для построчного чтения или использовать readlinesметод для построчного чтения файла в контейнер списка.Код показан ниже.
```Python
import time


def main():
    # Прочитать все содержимое файла сразу
    with open('99.txt', 'r', encoding='utf-8') as f:
        print(f.read())

    # Прочитать построчно через цикл for-in
    with open('99.txt', mode='r') as f:
        for line in f:
            print(line, end='')
            time.sleep(0.5)
    print()

    # Прочитать файл и прочитать его в списке построчно
    with open('99.txt') as f:
        lines = f.readlines()
    print(lines)


if __name__ == '__main__':
    main()
```

Также очень просто записать текстовую информацию в файл, просто openукажите имя файла и установите режим файла при использовании функции 'w'. Обратите внимание: если вам нужно добавить содержимое файла, вы должны установить режим 'a'. Если файл для записи не существует, он автоматически создаст файл, а не вызовет исключение. В следующем примере показано, как записать простые числа от 1 до 9999 в три файла соответственно (простые числа от 1 до 99 хранятся в a.txt, а простые числа от 100 до 999 хранятся в b.txt. Простые числа от 1000 -9999 хранятся в c.txt).

```Python
from math import sqrt


def is_prime(n):
    """Функция для определения простых чисел"""
    assert n > 0
    for factor in range(2, int(sqrt(n)) + 1):
        if n % factor == 0:
            return False
    return True if n != 1 else False


def main():
    filenames = ('a.txt', 'b.txt', 'c.txt')
    fs_list = []
    try:
        for filename in filenames:
            fs_list.append(open(filename, 'w', encoding='utf-8'))
        for number in range(1, 10000):
            if is_prime(number):
                if number < 100:
                    fs_list[0].write(str(number) + '\n')
                elif number < 1000:
                    fs_list[1].write(str(number) + '\n')
                else:
                    fs_list[2].write(str(number) + '\n')
    except IOError as ex:
        print(ex)
        print('Произошла ошибка при записи файла!')
    finally:
        for fs in fs_list:
            fs.close()
    print('Операция выполнена!')


if __name__ == '__main__':
    main()
```

### Чтение и запись двоичных файлов

Знать, как читать и писать текстовые файлы, очень просто для чтения и записи двоичных файлов.Следующий код реализует функцию копирования файлов изображений.


```Python
def main():
    try:
        with open('000.jpg', 'rb') as fs1:
            data = fs1.read()
            print(type(data))  # <class 'bytes'>
        with open('001.jpg', 'wb') as fs2:
            fs2.write(data)
    except FileNotFoundError as e:
        print('Указанный файл не может быть открыт.')
    except IOError as e:
        print('Произошла ошибка при чтении и записи файла.')
    print('Выполнение программы завершено.')


if __name__ == '__main__':
    main()
```

### Чтение и запись файлов JSON

Из приведенного выше объяснения мы уже знаем, как сохранять текстовые и двоичные данные в файл. Тогда возникает еще один вопрос. Что, если вы хотите сохранить данные в виде списка или словаря в файл? Ответ - сохранить данные в формате JSON. JSON - это аббревиатура от "JavaScript Object Notation". Первоначально это был буквальный синтаксис для создания объектов на языке JavaScript. Теперь он широко используется для межплатформенного и межъязыкового обмена данными. Причина очень проста, потому что JSON также является обычным текстом.Нет проблем с обработкой обычного текста в любой системе или языке программирования. В настоящее время JSON в основном заменил XML как стандарт де-факто для обмена данными между гетерогенными системами. Дополнительную информацию о JSON можно найти на официальном веб-сайте JSON . На этом веб-сайте вы также можете узнать об инструментах или сторонних библиотеках, которые каждый язык может использовать для обработки формата данных JSON. Ниже приведен простой пример. JSON.

```JSON
{
    "name": "Иван",
    "age": 35,
    "qq": 954458,
    "friends": ["Костя", "Саша"],
    "cars": [
        {"brand": "BYD", "max_speed": 180},
        {"brand": "Audi", "max_speed": 280},
        {"brand": "Benz", "max_speed": 320}
    ]
}
```

Возможно, вы заметили, что приведенный выше JSON фактически совпадает со словарем в Python. Фактически, легко найти соответствие между типом данных JSON и типом данных Python, как показано в следующих двух таблицах.

| JSON                | Python       |
| ------------------- | ------------ |
| object              | dict         |
| array               | list         |
| string              | str          |
| number (int / real) | int / float  |
| true / false        | True / False |
| null                | None         |

| Python                                 | JSON         |
| -------------------------------------- | ------------ |
| dict                                   | object       |
| list, tuple                            | array        |
| str                                    | string       |
| int, float, int- & float-derived Enums | number       |
| True / False                           | true / false |
| None                                   | null         |

Мы можем использовать модуль json в Python для сохранения словаря или списка в файл в формате JSON.Код показан ниже.

```Python
import json


def main():
    mydict = {
        'name': 'Иван',
        'age': 34,
        'qq': 9571158,
        'friends': ['Костя', 'Саша'],
        'cars': [
            {'brand': 'BYD', 'max_speed': 180},
            {'brand': 'Audi', 'max_speed': 280},
            {'brand': 'Benz', 'max_speed': 320}
        ]
    }
    try:
        with open('data.json', 'w', encoding='utf-8') as fs:
            json.dump(mydict, fs)
    except IOError as e:
        print(e)
    print('Сохранение данных завершено!')


if __name__ == '__main__':
    main()
```

Модуль json в основном выполняет еще четыре важные функции, а именно:

- `dump` -Сериализовать объекты Python в файлы в формате JSON
- `dumps` -Обработка объектов Python в строки формата JSON
- `load` -Десериализовать данные JSON в файле в объект
- `loads` -Десериализовать содержимое строки в объект Python

Здесь есть две концепции: одна называется сериализацией, а другая - десериализацией. В бесплатной энциклопедии Википедия эти две концепции объясняются следующим образом: «Сериализация в обработке данных информатики означает преобразование структур данных или состояний объектов в форму, которая может быть сохранена или передана. При необходимости ее можно восстановить в исходное состояние, и когда байты извлекаются из сериализованных данных, эти байты могут использоваться для создания копии (копии) исходного объекта. Противоположность этому процессу, то есть из серии байтов. Операция извлечения структуры данных в этом десериализация ".

В настоящее время подавляющее большинство сетевых служб передачи данных (или так называемого сетевого API) основано на протоколе HTTP для предоставления данных в формате JSON. Зная протокол HTTP, вы можете увидеть Руань Ифэна, преподавателя «Приступая к работе с протоколом HTTP». " , если вы хотите разобраться в внутреннем мире. Для служб передачи данных в Интернете вы можете проверить Сводные данные и данные аватаров и другие веб-сайты. Для иностранцев посетите веб-сайт поиска {API} . В следующем примере показано, как использовать модуль запросов (достаточно упакованный сторонний модуль доступа к сети) для доступа к сетевым API для получения внутренних новостей, а также как анализировать данные JSON и отображать заголовки новостей через модуль json. В этом примере используется внутренний информация, предоставленная Tianxing Data Интерфейс данных новостей, APIKey, в котором вам нужно перейти на веб-сайт, чтобы подать заявку.

```Python
import requests
import json


def main():
    resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&num=10')
    data_model = json.loads(resp.text)
    for news in data_model['newslist']:
        print(news['title'])


if __name__ == '__main__':
    main()
```

Для достижения сериализации и десериализации в Python, помимо использования модуля json, вы также можете использовать модули pickle и shelve, но эти два модуля используют уникальный протокол сериализации для сериализации данных, поэтому сериализованные данные могут быть распознаны только Python . Для получения соответствующих знаний об этих двух модулях вы можете сами посмотреть информацию в Интернете. Кроме того, если вы хотите узнать больше о механизме исключений Python, вы можете прочитать статью «Резюме: обработка исключений в Python» о segmentfault . Эта статья не только знакомит с использованием механизмов исключений в Python, но и резюмирует серию Лучшие практики, стоит прочитать.