## Файлы и исключения

Фактическая разработка часто сталкивается с операциями сохранения данных, и наиболее простой способ 
сохранения данных - сохранить данные в файл. Говоря о слове «файл», возможно, сначала необходимо популяризировать 
знания о файловой системе, но здесь мы не тратим впустую перо и чернила, чтобы представить эту концепцию.

Реализовать операции чтения и записи файлов в Python на самом деле очень просто. С помощью встроенных `open` функций 
Python мы можем указать имя файла, режим работы, информацию о кодировке и т. д., Чтобы получить объект файла 
операции, а затем прочитать и записать файл. Упомянутый здесь режим работы относится к типу файла, который нужно 
открыть (символьный файл или двоичный файл) и какой операции (чтение, запись или добавление) необходимо выполнить, 
как показано в следующей таблице.


| Режим  | Расшифровка                         |
| -------- | -------------------------------- |
| `'r'`    | Читать (по умолчанию)                    |
| `'w'`    | Запись (предыдущее содержимое будет обрезано первым)       |
| `'x'`    | Напишите, если файл уже существует, будет сгенерировано исключение |
| `'a'`    | Добавить, записать содержимое в конец существующего файла |
| `'b'`    | Двоичный режим                      |
| `'t'`    | Текстовый режим (по умолчанию)                 |
| `'+'`    | Обновление (как чтение, так и запись)         |


### Чтение и запись текстовых файлов

При чтении текстового файла вам необходимо служебную команду (функцию) 'open' и указать имя файла с путем его 
размещения. При использовании этой функции (можно указывать относительный путь или абсолютный путь) и установить 
режим файла 'r'(если не указан, то этот режим по умолчанию 'r'), а затем  указать кодировка через 
параметр `encoding` (если не указано, значение по умолчанию - Нет, тогда при чтении файла используется кодировка 
операционной системы по умолчанию). В следующем примере показано, как читать простой текстовый файл.

```Python
def main():  # главная функция
    f = open('99.txt', 'r', encoding='utf-8')  # переменной присваем значение открытого текстового файла в режиме 
    # чтения, utf-8 - кодировки
    print(f.read())  # результат чтения файла выведем на экран
    f.close()  # чтобы закрыть открытый файл и освободить внешние ресурсы (выгрузить его из памяти переменной)


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

Обратите внимание на приведенный выше код. Если `open` файл, указанный функцией, не существует или не может быть 
открыт, это вызовет сбой программы. Чтобы сделать код надежным и отказоустойчивым, мы можем использовать механизм 
исключений Python для правильной обработки кода, который может возникнуть во время выполнения, как показано ниже.
```Python
def main():  # главная функция
    f = None
    try:
        f = open('99.txt', 'r', encoding='utf-8')
        print(f.read())
    except FileNotFoundError:
        print('Невозможно открыть указанный файл!')
    except LookupError:
        print('Указана неизвестная кодировка!')
    except UnicodeDecodeError:
        print('Ошибка декодирования при чтении файла!')
    finally:
        if f:
            f.close()  # чтобы закрыть открытый файл и освободить внешние ресурсы (выгрузить его из памяти переменной)

if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

В Python-программе мы можем поместить проверку на наличие ошибки при открытии файла, так называемый `try` код, который 
умеет обрабатывать ошибки. Каждай ошибка имеет свое имя, по умолчанию ошибка приводит к закрытию программы. Например, в 
процессе чтения файла будет срабатывать, FileNotFoundError если файл не может быть найден, и будет указана 
неизвестная кодировка LookupError. Если файл не может быть декодирован указанным способом при чтении файла, то он 
получит ошибку UnicodeDecodeError. Создадим проверку на наличие ошибки при открытии файла, функция `try` проверяет 
открылся ли файл без ошибок, если ошибка есть то вызывает исключение `except`, сколько ошибок может возникнуть 
столько исключений  `except` мы должны создать. В таком случае программа не прекратит свою работу, а продолжит и 
выполнит свой алгоритм в данной ситуации.

```Python
def main():  # главная функция
    try:  # блок проверки на ошибки
        with open('99.txt', 'r', encoding='utf-8') as f:  # открытие файла, его значение присваивается переменной f
            print(f.read())  # вывести на экран текст файла
    except FileNotFoundError:  # исключение при получении ошибки
        print('Невозможно открыть указанный файл!')  # сообщение о типе ошибки
    except LookupError:  # исключение при получении ошибки
        print('Указана неизвестная кодировка!')  # сообщение о типе ошибки
    except UnicodeDecodeError:  # исключение при получении ошибки
        print('Ошибка декодирования при чтении файла!')  # сообщение о типе ошибки

if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

Помимо использования `read` метода файлового объекта для чтения файла, вы также можете использовать `for-in` цикл для 
построчного чтения файла или использовать `readlines` метод для построчного чтения файла в контейнер списка.Код показан 
ниже.
```Python
import time


def main():  # главная функция
    # Прочитать все содержимое файла сразу
    with open('99.txt', 'r', encoding='utf-8') as f:
        print(f.read())

    # Прочитать построчно через цикл for-in
    with open('99.txt', mode='r') as f:
        for line in f:
            print(line, end='')
            time.sleep(0.5)
    print()

    # Прочитать файл и прочитать его в списке построчно
    with open('99.txt') as f:
        lines = f.readlines()
    print(lines)


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

Также очень просто записать текстовую информацию в файл, при открытии файла функции open укажите имя файла и установите 
режим файла с атрибутом 'w'. Обратите внимание: если вам нужно добавить содержимое файла, вы должны установить режим 
'a'. Если файл для записи не существует, он автоматически создаст файл, а не вызовет исключение. В следующем 
примере показано, как записать простые числа от 1 до 9999 в три файла соответственно (простые числа от 1 до 99 
хранятся в a.txt, а простые числа от 100 до 999 хранятся в b.txt. Простые числа от 1000 -9999 хранятся в c.txt).

```Python
from math import sqrt


def is_prime(n):
    """Функция для определения простых чисел"""
    assert n > 0
    for factor in range(2, int(sqrt(n)) + 1):
        if n % factor == 0:
            return False
    return True if n != 1 else False


def main():  # главная функция
    filenames = ('a.txt', 'b.txt', 'c.txt')
    fs_list = []
    try:
        for filename in filenames:
            fs_list.append(open(filename, 'w', encoding='utf-8'))
        for number in range(1, 10000):
            if is_prime(number):
                if number < 100:
                    fs_list[0].write(str(number) + '\n')
                elif number < 1000:
                    fs_list[1].write(str(number) + '\n')
                else:
                    fs_list[2].write(str(number) + '\n')
    except IOError as ex:
        print(ex)
        print('Произошла ошибка при записи файла!')
    finally:
        for fs in fs_list:
            fs.close()  # чтобы закрыть открытый файл и освободить внешние ресурсы (выгрузить его из памяти переменной)
    print('Операция выполнена!')


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

### Чтение и запись двоичных файлов

Полученные знания как читать и писать текстовые файлы, поможет очень просто разобраться в чтении и записи двоичных 
файлов. Следующий код реализует функцию копирования файлов изображений.

```Python
def main():  # главная функция
    try:
        with open('000.jpg', 'rb') as fs1:
            data = fs1.read()
            print(type(data))  # <class 'bytes'>
        with open('001.jpg', 'wb') as fs2:
            fs2.write(data)
    except FileNotFoundError as e:
        print('Указанный файл не может быть открыт.')
    except IOError as e:
        print('Произошла ошибка при чтении и записи файла.')
    print('Выполнение программы завершено.')


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

### Чтение и запись файлов JSON

Из приведенного выше объяснения мы уже знаем, как сохранять текстовые и двоичные данные в файл. Тогда возникает еще 
один вопрос. Что, если вы хотите сохранить данные в виде списка или словаря в файл? Ответ - сохранить данные в 
формате JSON. JSON - это аббревиатура от "JavaScript Object Notation". Первоначально это был буквальный синтаксис 
для создания объектов на языке JavaScript. Теперь он широко используется для межплатформенного и межъязыкового 
обмена данными. Причина очень проста, потому что JSON также является обычным текстом. Нет проблем с обработкой 
обычного текста в любой системе или языке программирования. В настоящее время JSON в основном заменил XML как 
стандарт де-факто для обмена данными между гетерогенными системами. Дополнительную информацию о JSON можно найти на 
официальном веб-сайте JSON . Ниже приведен простой пример. JSON.

```JSON
{
    "name": "Иван",
    "age": 35,
    "qq": 954458,
    "friends": ["Костя", "Саша"],
    "cars": [
        {"brand": "BYD", "max_speed": 180},
        {"brand": "Audi", "max_speed": 280},
        {"brand": "Benz", "max_speed": 320}
    ]
}
```

Возможно, вы заметили, что приведенный выше JSON фактически совпадает со словарем в Python. Фактически, легко найти 
соответствие между типом данных JSON и типом данных Python, как показано в следующих двух таблицах.

| JSON                | Python       |
| ------------------- | ------------ |
| object              | dict         |
| array               | list         |
| string              | str          |
| number (int / real) | int / float  |
| true / false        | True / False |
| null                | None         |

| Python                                 | JSON         |
| -------------------------------------- | ------------ |
| dict                                   | object       |
| list, tuple                            | array        |
| str                                    | string       |
| int, float, int- & float-derived Enums | number       |
| True / False                           | true / false |
| None                                   | null         |

Мы можем использовать модуль json в Python для сохранения словаря или списка в файл в формате JSON.Код показан ниже.

```Python
import json


def main():  # главная функция
    mydict = {  # создаем сложный словарь с вложенными списками и еще одним вложенным словарем
        'name': 'Иван',
        'age': 34,
        'qq': 9571158,
        'friends': ['Костя', 'Саша'],
        'cars': [
            {'brand': 'BYD', 'max_speed': 180},
            {'brand': 'Audi', 'max_speed': 280},
            {'brand': 'Benz', 'max_speed': 320}
        ]
    }
    try:
        with open('data.json', 'w', encoding='utf-8') as fs:  # октрытие файла и его значение присваеиваем переменнной
            json.dump(mydict, fs)  # дополняем перемеенную, нашим словарем
    except IOError as e:  # в случае возникновения ошибки
        print(e)  # выводит сообщение об ошибке
    print('Сохранение данных завершено!')


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

Модуль json в основном выполняет еще четыре важные функции, а именно:

- `dump` -Сериализовать объекты Python в файлы в формате JSON
- `dumps` -Обработка объектов Python в строки формата JSON
- `load` -Десериализовать данные JSON в файле в объект
- `loads` -Десериализовать содержимое строки в объект Python

Главное две концепции: одна называется сериализацией, а другая - десериализацией. Сериализация в обработке 
данных информатики означает преобразование структур данных или состояний объектов в форму, которая может быть 
сохранена или передана. Противоположность этому процессу, называется десериализацией.

В настоящее время подавляющее большинство сетевых служб передачи данных (или так называемого сетевого API) основано 
на протоколе HTTP для предоставления данных в формате JSON. В 
следующем примере показано, как использовать модуль запросов для доступа к сетевым API и получения внутренних 
новостей, а также как анализировать данные JSON и отображать заголовки новостей через модуль json. В этом примере 
используется внутренний информация, предоставленная сервисом Tianxing Data. Для того что бы программа заработала Вам 
необходимо получить APIKey, подав заявку на этот сайт.


```Python
import requests
import json


def main():  # главная функция
    resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&num=10')
    data_model = json.loads(resp.text)
    for news in data_model['newslist']:
        print(news['title'])


if __name__ == '__main__':  # если запущена эта программа как главный файл
    main()  # то выполнить главную функцию
```

Для достижения сериализации и десериализации в Python, помимо использования модуля json, вы также можете 
использовать модули pickle и shelve, но эти два модуля используют уникальный протокол сериализации 
данных, поэтому сериализованные данные могут быть распознаны только Python. 