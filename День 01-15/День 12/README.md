[Вернуться на главную](https://github.com/BEPb/Python-100-days)

### Расширенные манипуляции со строками - escape-символы

Escape-символы в Python используются для представления специальных символов внутри строковых литералов. Основные 
escape-символы в Python приведены ниже:

- \n: символ новой строки
- \t: символ табуляции
- \\: обратный слэш
- \': апостроф
- \": кавычка

Пример использования escape-символов:

```python
# символ новой строки
print("Hello\nworld")

# символ табуляции
print("Hello\tworld")

# обратный слэш
print("I\'m a programmer")

# апостроф или кавычка
print("He said, \"I'm a programmer\"")
```

В результате выполнения кода мы получим следующий вывод:

```
Hello
world
Hello  world
I'm a programmer
He said, "I'm a programmer"
```

Исходные строки:

Строки в Python могут быть определены в кавычках одинарных, двойных или тройных (для многострочных строк).

Примеры:

```python
str1 = 'это строка в одинарных кавычках'
str2 = "это строка в двойных кавычках"
str3 = '''это многострочная строка
состоящая из нескольких строк'''
```

Методы соединения строк:

1. Оператор "+" может использоваться для объединения строк

Пример:

```python
str1 = 'Hello'
str2 = 'World'
print(str1 + str2) # вывод: HelloWorld
```

2. Метод join() может быть использован для соединения списка строк в одну строку.

Пример:

```python
list1 = ['apple', 'banana', 'orange']
str1 = ', '.join(list1)
print(str1) # вывод: apple, banana, orange
```

3. Использование форматирования строк с {} в качестве заполнительных символов.

Пример:

```python
price = 10
qty = 5
product = 'apple'
print('Я купил {} {} за {} рублей.'.format(qty, product, price)) # вывод: Я купил 5 apple за 10 рублей.
```

Методы разделения строк:

1. Метод split() может быть использован для разделения строки на список подстрок.

Пример:

```python
str1 = 'apple, banana, orange'
list1 = str1.split(', ')
print(list1) # вывод: ['apple', 'banana', 'orange']
```

2. Метод partition() может быть использован для разделения строки на кортеж с тремя элементами: строка до 
   разделителя, разделитель и строка после разделителя. 

Пример:

```python
str1 = 'apple, banana, orange'
tuple1 = str1.partition(', ')
print(tuple1) # вывод: ('apple', ', ', 'banana, orange')
```


Модуль `pyperclip` предоставляет простой способ работать с буфером обмена и упрощает копирование и вставку текста в Python.

Пример использования модуля `pyperclip`:

```python
import pyperclip

# Копируем текст в буфер
pyperclip.copy('Текст для копирования')

# Вставляем текст из буфера
text = pyperclip.paste()

print(text)  # Выводит 'Текст для копирования'
```

В Python есть несколько различных способов работы со строками, но основным типом данных для работы со строками 
является `str`. Он представляет собой неизменяемую последовательность символов Unicode.  

В Python также есть два модуля, которые могут использоваться для работы со строками: `StringIO` и `string`. 

Модуль `StringIO` предоставляет возможность использования строковых данных в качестве файловых объектов. С помощью 
`StringIO` можно создавать и изменять строки, так же как и в файле. 

Модуль `string` предоставляет набор функций для работы со строками, таких как разбиение и объединение строк, 
изменение регистра символов и т.д. 

Манипуляции со строками представляют собой манипуляции с отдельными символами строки или набором символов, а также 
самих строк. Методы Python, которые можно использовать для работы со строками, включают `split()`, `join()`, `replace
()`, `strip()`, `startswith()`, `endswith()`, `lower()`, `upper()`, `count()` и многие другие.   

Строки в Python являются неизменяемыми объектами, так что их значения нельзя изменить после того, как они были 
созданы. Это означает, что если потребуется изменить строку, то необходимо создать новую строку с измененным значением. 

Однако, если требуется изменять значение строки без создания новых объектов, можно использовать модуль `array`. 
Объекты массивов позволяют изменять значение элементов по индексу, как это делается в списке. Для создания объекта 
массива используют конструктор `array` из модуля `array`.  

Кроме того, в Python есть так называемые переменные символы (англ. variable-length character), к которым относятся 
строки, байтовые строки (bytes) и байтовые массивы (bytearrays). Эти типы данных могут содержать произвольное 
количество символов или байтов, которые могут изменяться в любое время.  

Например:

```python
# Создание переменной символов
my_string = "Hello, World!"

# Изменение значения переменной символов
my_string = "Hello, Python!"
``` 

Также, можно использовать методы строк, которые возвращают новые объекты строк с измененным значением, например:

```python
my_string = "Hello, World!"
new_string = my_string.replace("World", "Python")
```

В результате выполнения этого кода, будет создана новая строка `new_string` с измененным значением, то есть "Hello, 
Python!". Исходная строка `my_string` останется неизменной. 

Трансформации символов или изменения строк, в зависимости от способа реализации, могут быть дорогой операцией, 
поэтому при работе со строками, где требуется множество изменений, лучше использовать специальные инструменты, такие 
как `StringIO`. Этот модуль позволяет использовать строки, как будто они являются файлами, и изменять их, используя 
стандартные методы работы с текстовыми файлами.   


Вот пример кода на Python с использованием модуля `StringIO` и методов строки:

```python
import StringIO

# создаем объект StringIO и записываем в него строку
string_io = StringIO.StringIO()
string_io.write("hello world!")

# считываем из объекта StringIO и выводим на экран
string_io.seek(0)
print(string_io.read())

# заменяем подстроку "world" на "Python"
string_io.seek(0)
processed_string = string_io.read().replace("world", "Python")

# выводим обработанную строку на экран
print(processed_string)
```

Этот код создает объект `StringIO`, записывает в него строку "hello world!" и затем считывает ее в переменную. Затем 
он заменяет подстроку "world" на "Python" в этой переменной и выводит обработанную строку на экран. 


## Регулярные выражения

### Знания о регулярных выражениях

При написании программ или веб-страниц, обрабатывающих строки, часто возникает необходимость найти строки, которые 
соответствуют определенным сложным правилам. Регулярные выражения - это инструменты, используемые для описания этих 
правил. Другими словами, регулярные выражения - это инструмент который определяет режим сопоставления строк (как 
проверить, соответствует ли строка определенному шаблону или извлечь и заменить часть, которая соответствует 
шаблону из строки). Если вы использовали поиск файлов в операционной системе Windows и использовали подстановочные 
знаки (* и ?) при указании имен файлов, регулярные выражения также являются аналогичным инструментом для 
сопоставления текста, но имеют гораздо больше возможностей по настройке. Более точно описать свои 
потребности при поиске намного сложнее, чем ввод подстановочного знака. Так же, как 
изучение языка программирования), например, вы можете написать регулярное выражение, чтобы найти все, начинающиеся 
с 0, за которыми следуют 2–3 числа, затем дефис «-» и, наконец, 7 или 8 цифр. Строка чисел (например, 028-12345678 
или 0813-7654321). Вначале компьютеры были созданы для выполнения 
математических операций. Обработанная информация представляла собой в основном числовые значения. Сегодня 
информация, которую мы обрабатываем в нашей повседневной работе, представляет собой в основном текстовые данные. Мы 
надеемся, что компьютеры могут распознавать и обрабатывать текст, который соответствует определенным шаблонам. 
Регулярные выражения очень важны. Почти все языки программирования сегодня обеспечивают поддержку операций с 
регулярными выражениями. Пайтон поддерживает операции с регулярными выражениями через модуль `re` в стандартной 
библиотеке.


Регулярные выражения (RegExp, regex) - это инструмент для поиска и манипуляции текстом на основе определенного 
шаблона. Они используются в различных языках программирования, включая Python, для поиска и фильтрации текста. 

Метасимволы - это специальные символы, которые представляют собой шаблоны. Они могут использоваться для поиска 
определенных паттернов, например, символ "." используется для поиска любого символа в строке. 

Экранирование - это процесс использования обратного слеша для отмены специального значения метасимволов. Например, 
если вы хотите найти точку в тексте, вы можете использовать "\.". 

Квантификаторы - это специальные символы, которые указывают, сколько раз должен повторяться предыдущий элемент. 
Например, символ "*" может указывать, что предыдущий элемент должен повторяться 0 или более раз. 

Пример использования регулярных выражений в Python:

```python
import re

text = "Hello, my name is John. My email is john@example.com."

pattern = r'\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b'

emails = re.findall(pattern, text)

print(emails)
```

В этом примере мы используем модуль re для поиска электронных адресов в строке text. Мы определяем шаблон с помощью 
метасимволов и квантификаторов, а затем используем функцию findall для поиска всех совпадений. Результатом будет 
список электронных адресов, найденных в тексте.  

Для работы с регулярными выражениями в Python необходимо импортировать модуль `re`. Для группировки элементов 
регулярного выражения используется скобочная нотация. Утверждения нулевой ширины позволяют задавать условия, которые 
должны быть выполнены, но не входят в сопоставляемое выражение. Ленивое сопоставление используется для нахождения 
наименьшего возможного совпадения в строке.   

Вот пример, который демонстрирует эти понятия:

```python
import re

# Группировка элементов регулярного выражения
string1 = "John Smith, 35, male"
match1 = re.search(r"(\w+) (\w+), (\d+), (\w+)", string1)
print(match1.group(1))  # John
print(match1.group(2))  # Smith
print(match1.group(3))  # 35
print(match1.group(4))  # male

# Утверждения нулевой ширины
string2 = "Hello, world!"
match2 = re.findall(r"\b\w+\b(?!,)", string2)
print(match2)  # ['Hello', 'world']

# Ленивое сопоставление
string3 = "Apples and oranges and bananas"
match3 = re.search(r"\w+? and \w+", string3)
print(match3.group())  # Apples and oranges
```

В этом примере мы сначала находим четыре группы в строке (имя, фамилия, возраст и пол). Затем мы используем 
утверждения нулевой ширины, чтобы найти все слова в строке, которые не заканчиваются запятой. Наконец, мы используем 
ленивое сопоставление, чтобы найти наименьшее возможное совпадение в строке.  


Вот небольшой пример, который демонстрирует использование модуля `re` для поиска всех вхождений слова 
"apple" в строке.  

```python
import re

text = "I have an apple, he has an apple, she has an apple. We all love apples!"

pattern = r"apple"

matches = re.findall(pattern, text)

print(matches)
```

Результат работы программы будет следующим:

```
['apple', 'apple', 'apple', 'apples']
```

Здесь мы импортируем модуль `re`, создаем строку, которую будем анализировать, и определяем шаблон регулярного 
выражения `r"apple"`, который описывает строку "apple". Затем мы вызываем функцию `findall()` из модуля `re`, 
которая находит все вхождения шаблона в строке и возвращает список соответствующих строк. В этом примере, список 
`matches` содержит все вхождения слова "apple" из исходной строки.   




Мы можем рассмотреть следующий вопрос: мы откуда-то получили строку (например, текстовый файл или новость в 
Интернете) и надеемся найти в строке номер мобильного телефона и номер стационарного телефона. Конечно, мы можем 
установить номер мобильного телефона как 11-значное число (обратите внимание, что это не случайное 11-значное число,
потому что вы никогда не видели номер мобильного телефона, такой как "25012345678"), и номер стационарного телефона 
будет таким же как и в случае с шаблоном, описанным в предыдущем абзаце, использование регулярных выражений для 
выполнения этой задачи будет очень проблематичным.

Краткое изложение некоторых основных символов регулярных выражений.


| условное обозначение	| объяснять	                                                             | Пример	             |                                              
| ------------------ |------------------------------------------------------------------------|---------------------| 
| .                  | Один  любой символ, кроме новой строки \n.                             | b.t                 | 
| \\w                | Соответствие букв / цифр / знаков подчеркивания                        | b\\wt               | 
| \\s                | Соответствовать пробельным символам (включая \ r, \ n, \ t и т. Д.)    | love\\syou          | 
| \\d                | Совпадение чисел                                                       | \\d\\d              | 
| \\b                | Сопоставить границы слов                                               | \\bThe\\b           | 
| ^                  | Соответствует началу строки                                            | ^The                | 
| $                  | Соответствует конец строки                                             | .exe$               | 
| \\W                 | Соответствие без букв / цифр / подчеркивания                           | b\\Wt               | 
| \\S                 | Соответствовать непробельным символам                                  | love\\Syou          | 
| \\D                 | Совпадение без цифр                                                    | \\d\\D              | 
| \\B                 | Сопоставить границы без слов                                           | \\Bio\\B            |  
| []                 | Соответствует любому одиночному символу из набора символов             | [aeiou]             | 
| [^]                | Соответствует любому одиночному символу, не входящему в набор символов | [^aeiou]            | 
| *                  | Совпадение 0 или более раз                                             | \\w*                | 
| +                  | Совпадение 1 или более раз                                             | \\w+                |  
| ?                  | Совпадение 0 или 1 раз                                                 | \\w?                |    
| {N}                | Совпадение N раз                                                       | \\w{3}              | 
| {M,}               | Матч не менее M раз                                                    | \\w{3,}             |  
| {M,N}              | Соответствовать не  менее M раз и не более N раз                       | \\w{3,6}            |  
| \|                                                                        | Ветвь               | foo\|bar         | 
| (?#)               | Аннотации                                                              |                     |  
| (exp)              | Сопоставьте опыт и захват в автоматически названную группу             |                     |   
| (?&lt;name&gt;exp) | Сопоставьте exp и захватите группу с именем name                       |                     | 
| (?:exp)            | Соответствует exp, но не захватывает совпадающий текст                 |                     | 
| (?=exp)            | Соответствует позиции до exp                                           | \\b\\w+(?=ing)      | 
| (?<=exp)           | Соответствует позиции за exp                                           | (?<=\\bdanc)\\w+\\b | 
| (?!exp)            | Позиция без опыта после матча                                          |                     | 
| (?<!exp)           | Сопоставьте позицию, которая не является экспозицией впереди           |                     | 
| *?                 | Повторите столько раз, сколько возможно, но как можно реже             | a.\*b<br>a.\*?b     | 
| +?                 | Повторите 1 или более раз, но как можно реже.                          |                     |    
| ??                 | Повторите 0 или 1 раз, но повторяйте как можно реже.                   |                     |  
| {M,N}?             | Повторите от M до N раз, но повторяйте как можно реже.                 |                     |  
| {M,}?              | Повторите более M раз, но повторяйте как можно реже                    |                     |  

> Примечание. Если сопоставляемый символ является специальным символом в регулярном выражении, вы можете 
> использовать символ слеша `\` для экранирования, например, если вы хотите сопоставить десятичную точку, вы можете 
> написать `\.` , потому что запись напрямую символа точки `.` в регулярных выражениях будет соответствовать любому 
> символу.


### Поддержка регулярных выражений в Python

Python предоставляет модуль `re` для поддержки операций, связанных с регулярными выражениями. Ниже приведены 
основные функции модуля `re`.


| функция	| иллюстрировать                                                     |
| -------------------------------------------- | ------------------------------------------------------------ |
| compile(pattern, flags=0)                    | Скомпилируйте регулярное выражение и верните объект регулярного выражения                            |
| match(pattern, string, flags=0)              | Используйте регулярное выражение, чтобы успешно сопоставить строку и вернуть соответствующий объект, в противном случае оно вернет None         |
| search(pattern, string, flags=0)             | Первое вхождение шаблона регулярного выражения в строку поиска возвращает соответствующий объект успешно, в противном случае возвращается None. |
| split(pattern, string, maxsplit=0, flags=0)  | Разделите строку с помощью разделителя шаблонов, указанного в регулярном выражении, и верните список              |
| sub(pattern, repl, string, count=0, flags=0) | Замените шаблон, который соответствует регулярному выражению в исходной строке, на указанную строку. Вы можете использовать count, чтобы указать количество замен. |
| fullmatch(pattern, string, flags=0)          | Версия функции сопоставления с точным соответствием (от начала до конца строки)                |
| findall(pattern, string, flags=0)            | Найдите все шаблоны, которые соответствуют регулярному выражению в строке, и верните список строк        |
| finditer(pattern, string, flags=0)           | Найдите все шаблоны в строке, которые соответствуют регулярному выражению, и верните итератор          |
| purge()                                      | Очистить кеш от неявно скомпилированных регулярных выражений                               |
| re.I / re.IGNORECASE                         | Игнорировать токены соответствия регистра                                           |
| re.M / re.MULTILINE                          | Многострочный тег соответствия                                                 |

> Примечание. Эти функции в упомянутом выше модуле `re` также могут быть заменены объектами регулярных выражений в 
> реальной разработке. Если регулярное выражение необходимо использовать повторно, сначала скомпилируйте регулярное 
> выражение с помощью функции компиляции `Formula` и создайте объект регулярного выражения. 

Ниже мы используем серию примеров, чтобы показать вам, как использовать регулярные выражения в Python.

#### Убедитесь, что введенное имя пользователя и номер QQ действительны, и дайте соответствующую подсказку.

```Python
"""
Python 3.10 Убедитесь, что введенное имя пользователя и номер QQ действительны, и дайте соответствующую подсказку.
Имя пользователя должно состоять из букв, цифр или знаков подчеркивания и иметь длину от 6 до 20 символов.
Номер QQ - это число от 5 до 12, и первая цифра не может быть 0.
Название файла '03.проверка_имени.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-10
"""

import re  # подключаем модуль регулярных выражений

def main():  # главная функция
    username = input('Пожалуйста, введите имя пользователя: ')
    qq = input('Пожалуйста, введите номер QQ: ')
    m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)  # проверка имени написано буквами или цифрами не менее 6 и не
    # более 20 симоволов, если имя не соответствуюет то переменная получает значение ЛОЖЬ (folse)
    if not m1:
        print('Пожалуйста, введите действительное имя пользователя.')
    m2 = re.match(r'^[1-9]\d{4,11}$', qq)
    if not m2:
        print('Пожалуйста, введите действительный номер QQ.')  # проверка номера - цифры не менее 4 и не более 11
        # символов
    if m1 and m2:  # если все данные введены правильно
        print('Введенная вами информация действительна!')

if __name__ == '__main__':  # если запущена это программа как главная
    main()  # запускаем главную функцию
```

> Напоминание: запись «исходной строки» используется при написании регулярного выражения выше `(r` добавляется перед 
> строкой). Так называемая «исходная строка» означает, что каждый символ в строке имеет свое исходное значение. 
> Более конкретно, в строке нет так называемых escape-символов. Поскольку в регулярных выражениях есть много 
> метасимволов и мест, которые необходимо экранировать, если вы не используете исходную строку, вам нужно записать 
> обратную косую черту как `\\`. Например, `\d`, представляющий число, должно быть записано как `\\d`.

#### извлеките номер домашнего мобильного телефона из фрагмента текста.

```Python
"""
Python 3.10 регулярное выражение
Название файла '04.регулярное_выражение.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-10
"""
import re  # подключаем модуль регулярных выражений


def main():  # главная функция
    # Создайте объект регулярного выражения, используя упреждающий просмотр и проверку, чтобы убедиться, что перед и после номера мобильного телефона не должно быть чисел.
    pattern = re.compile(r'(?<=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)')
    sentence = '''
    Важно то, что 8130123456789 раз мой мобильный номер 13512346789,
    Это не 15600998765, это 110 или 119, номер мобильного телефона Ваньки - 15600998765.
    '''
    
    mylist = re.findall(pattern, sentence) # Найдем все совпадения и сохраним их в списке
    print(mylist)  # выведем список
    print('--------Великолепный разделитель--------')
    # Используйте функцию поиска, чтобы указать место поиска, чтобы найти все совпадения
    for temp in pattern.finditer(sentence):
        print(temp.group())
    print('--------Великолепный разделитель--------')
    # Используйте функцию поиска, чтобы указать место поиска, чтобы найти все совпадения
    m = pattern.search(sentence)
    while m:
        print(m.group())
        m = pattern.search(sentence, m.end())


if __name__ == '__main__':  # если запущена это программа как главная
    main()  # запускаем главную функцию
```

> Примечание. Вышеупомянутые регулярные выражения для сопоставления номеров домашних мобильных телефонов 
> недостаточно хороши, потому что числа, начинающиеся с 14, равны только 145 или 147, а указанные выше регулярные 
> выражения не учитывают это. Для сопоставления номеров домашних мобильных телефонов лучше регулярное выражение 
> Формула: (?<=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)

#### Заменить недопустимый контент в строке

```Python
"""
Python 3.10 Фильтрация нежелательного содержания
Название файла '05.фильтрация.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-10
"""
import re  # подключаем модуль регулярных выражений


def main():  # главная функция
    sentence = 'Ты туп? Я имел твоего дядю. Пошел ты на хутор.'  # переменной присваиваем значение строки
    purified = re.sub('[имел]|на хутор|сволочь|глупо[туп]|урод',
                      '*', sentence, flags=re.IGNORECASE)  # производим замену запретных символов
    print(purified)  # выведем на экран полученный результат


if __name__ == '__main__':  # если запущена это программа как главная
    main()  # запускаем главную функцию
```

> Описание: В функциях модуля `re`, связанных с регулярным выражением, есть параметр flags, который представляет 
> метку сопоставления регулярного выражения. Вы можете использовать эту метку, чтобы указать, следует ли 
> игнорировать регистр при сопоставлении, выполнять ли сопоставление нескольких строк, и следует ли отображать 
> отладочную информацию. Если вам нужно указать несколько значений для параметра flags, вы можете использовать 
> побитовый оператор или для наложения, например `flags=re.I | re.M.`

####  разделение длинной строки

```Python
"""
Python 3.10 Разделение строки на множество строк (список) разделенными запятой или точкой
Название файла '06.разделение_строки.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-10
"""

import re  # подключаем модуль регулярных выражений


def main():  # главная функция
    poem = 'Луна светит перед окном, предположительно, изморозь на земле. Глядя вверх на яркую луну, глядя на родной город. '
    sentence_list = re.split(r'[，,.]', poem)  # сравнение строки и символов разделителей, результат сохраняется в список

    for string in sentence_list:  # выведем результат на экран, каждый элемент списка с новой строки
        print(string)  # печать строки


if __name__ == '__main__':  # если запущена это программа как главная
    main()  # запускаем главную функцию
```

### Послесловие

Если вы хотите участвовать в разработке приложений для поисковых роботов, то регулярные выражения должны быть очень 
хорошим помощником, потому что они могут помочь нам быстро обнаружить определенный шаблон, который мы указываем в 
коде веб-страницы, и извлечь нужную нам информацию. Конечно, иногда нелегко написать правильное и подходящее регулярное 
выражение, поэтому при реальной разработке приложения-краулера многие люди будут выбирают Beautiful Soup или Lxml 
для сопоставления и извлечения информации. Первый прост и удобен, но имеет низкую производительность, а второй прост 
в использовании и имеет хорошую производительность, но установка вызывает некоторые затруднения. Мы познакомим вас 
с этим содержимым в более поздней теме про поискового робота.


Пример:
- 01.операции_строки.py
- 02.переворот_строки.py
- 03.проверка_имени.py
- 04.регулярное_выражение.py
- 05.фильтрация.py
- 06.разделение_строки.py

[Вернуться на главную](https://github.com/BEPb/Python-100-days)

[К следующему занятию](https://github.com/BEPb/Python-100-days/blob/master/%D0%94%D0%B5%D0%BD%D1%8C%2001-15/%D0%94%D0%B5%D0%BD%D1%8C%2013/README.md)
