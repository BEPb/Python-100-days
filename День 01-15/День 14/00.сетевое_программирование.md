## Начало работы с сетевым программированием

### Фундамент компьютерной сети

Компьютерная сеть - это общий термин для систем, которые связаны между собой независимыми компьютерами. Основная 
цель построения компьютерной сети - реализовать связь и совместное использование ресурсов между несколькими 
компьютерами. Сегодняшние компьютерные сети имеют бесчисленное количество устройств и пользователей компьютерных 
сетей, и компьютерную сеть также можно назвать «сложной гигантской системой». Для такой системы мы не можем четко 
объяснить ее в одной или двух статьях.

#### TCP/IP модель

Основой сетевой коммуникации являются соотв. протоколы, которые обычно разрабатываются Инженерной 
группой Интернета (IETF). Так называемый «протокол» - это набор соглашений, которым обе стороны коммуникационного 
оборудования должны выполнять, например, как установить соединение, как распознать друг друга и т. д. Три 
элемента сетевого протокола: синтаксис, семантика и время. Основой Интернета, который мы используем сегодня, 
является набор протоколов TCP/IP. Так называемый набор протоколов представляет собой серию протоколов и их моделей 
связи. В отличие от семиуровневой модели OSI/RM, выпущенной Международной организацией по стандартизации. TCP/IP 
представляет собой четырехуровневую модель, то есть модель логически разделяет используемую нами сеть на четыре 
уровня, снизу вверх: 
- уровень сетевого интерфейса,
- сетевой уровень, 
- транспортный уровень,
- прикладной уровень.

IP обычно переводится в Интернет-протокол, который обслуживает сетевой уровень и в основном реализует функции 
адресации и маршрутизации. Каждый хост, который обращается к сети, должен иметь свой собственный IP-адрес, и этот 
IP-адрес является идентификатором хоста в компьютерной сети. Конечно, из-за отсутствия адресов IPv4 IP-адреса, 
которые мы обычно получаем при серфинге в Интернете в домах, офисах и других общественных местах, которые могут 
получить доступ в Интернет, являются не единственными IP-адресами в мире.
Полное название TCP - это протокол управления передачей. Он основан на услугах адресации и маршрутизации, 
предоставляемых IP, и отвечает за обеспечение сквозной надежной передачи. Протокол TCP называется надежным 
протоколом передачи, потому что TCP обещает три вещи для звонящего. 


1. Данные не будут потеряны или переданы некорректно (это может быть достигнуто с помощью механизмов подтверждения, 
   контрольной суммы и повторной передачи).
2. Управление потоком (согласование скорости передачи данных между отправителем и получателем через скользящее окно).
3. Контроль перегрузки (уменьшение перегрузки сети за счет времени RTT и контроля скользящих окон).



Формат JSON
JSON ( J AVA S cript O bject N otation ) - это облегченный язык обмена данными, который упрощает чтение текста 
(обычного текста) на основе значений атрибутов, используемых для передачи или состоящих из последовательности 
значений объекта данных. Хотя JSON изначально был просто буквальным синтаксисом для создания объектов в Javascript, 
теперь это формат данных, не зависящий от языка. Многие языки программирования поддерживают создание и анализ 
данных в формате JSON, а также встроенный модуль json в Python. Предоставляет эту функцию. Поскольку JSON - это 
текст, а его XML как применим для обмена данными между разнородными системами, а по сравнению с XML, JSON еще более 
легкий и элегантный. Ниже приведены XML и JSON, которые выражают одну и ту же информацию, и преимущества JSON 
довольно интуитивно понятны.

#### JSON

```XML
<?xml version="1.0" encoding="UTF-8"?>
<message>
	<from>Alice</from>
	<to>Bob</to>
	<content>Will you marry me?</content>
</message>
```


```JSON
{
    "from": "Alice",
    "to": "Bob",
    "content": "Will you marry me?"
}
```

#### библиотека запросов
request - это третья библиотека, которая использует сеть на основе протокола HTTP. На ее официальном веб-сайте есть 
такое предложение, чтобы представить ее: «Запросы - это единственная HTTP-библиотека Python без ГМО, которой могут 
безопасно пользоваться люди». Проще говоря, используйте запросы. Библиотеки могут легко использовать HTTP, чтобы 
избежать недостатков безопасности, избыточного кода и «повторного изобретения колеса» (отраслевая идиома, обычно 
используемая в области разработки программного обеспечения для обозначения воссоздания существующего или 
оптимизированного базового метода). Мы уже использовали эту библиотеку в предыдущей статье. Затем мы будем 
использовать запросы для реализации интерфейса сетевых данных доступа и получения от него ссылки для загрузки 
изображения красоты, а затем загрузим изображение красоты в локальный пример программы. Программа использует сеть, 
предоставляемая Tianxing Data API.

Сначала мы можем установить запросы и зависимые от них библиотеки через pip.

```Shell
pip install requests
```

Если вы используете PyCharm в качестве инструмента разработки, вы можете писать прямо в коде import requests, а 
затем использовать функцию восстановления кода для автоматической загрузки и установки запросов.


```Python
"""
Python 3.9 Многопоточное скачивание
Название файла '01.Многопоточное_скачивание.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from threading import Thread

import requests


class DownloadHanlder(Thread):

    def __init__(self, url):
        super().__init__()
        self.url = url

    def run(self):
        filename = self.url[self.url.rfind('/') + 1:]
        resp = requests.get(self.url)
        with open('/Users/Downloads/' + filename, 'wb') as f:
            f.write(resp.content)


def main():
    # Получение сетевых ресурсов через функцию get модуля запросов
    resp = requests.get(
        'http://api.tianapi.com/meinv/?key=772a81a51ae5c780251b1f98ea431b84&num=10')
    # Разобрать данные в формате JSON, возвращенные сервером, в словарь
    data_model = resp.json()
    for mm_dict in data_model['newslist']:
        url = mm_dict['picUrl']
        # Реализуйте загрузку изображений через многопоточность
        DownloadHanlder(url).start()


if __name__ == '__main__':
    main()
```

#### Программирование сокетов на основе протокола транспортного уровня
Термин сокет очень неясен и незнаком многим людям, не разбирающимся в сетевом программировании. Фактически, проще 
говоря, сокет - это набор библиотек разработки приложений, написанных на языке C , в основном используемых для 
реализации межпроцессного взаимодействия и cетевое программирование широко используется при разработке сетевых 
приложений. В Python вы также можете использовать службы передачи, предоставляемые транспортным уровнем на основе 
сокетов, и разрабатывать свои собственные сетевые приложения на их основе. Сокеты, используемые в реальной 
разработке, можно разделить на три категории: сокеты потоков (сокеты TCP), сокеты дейтаграмм и необработанные сокеты.

#### Сокет TCP
Так называемый TCP-сокет - это программный интерфейс, который использует службу передачи, предоставляемую 
протоколом TCP, для реализации сетевого взаимодействия. В Python вы можете использовать сокеты TCP, создав объект 
сокета и указав атрибут типа как SOCK_STREAM. Поскольку хост может иметь несколько IP-адресов и может быть настроен 
с несколькими различными службами, как серверная программа, он должен быть привязан к указанному IP-адресу и порту после создания объекта сокета. Порт здесь не физическое устройство, а расширение IP-адреса для различения различных служб. Например, мы обычно привязываем службу HTTP к порту 80, в то время как служба базы данных MySQL привязана к порту 3306 по умолчанию, так что когда сервер получает Когда пользователь запрашивает его, номер порта может использоваться, чтобы определить, запрашивал ли пользователь услугу, предоставляемую сервером HTTP или сервером базы данных. Диапазон значений порта составляет 0 ~ 65535, и порты ниже 1024 обычно называются «известными портами» (порты, зарезервированные для «известных служб», таких как FTP, HTTP, SMTP и т. Д., А в некоторых местах они также называются «известными портами») известные порты ". Известные порты"), пользовательские службы обычно не используют эти порты, если только пользовательские службы не являются широко известными службами, такими как HTTP или FTP.

Следующий код реализует сервер, который предоставляет время и дату.

```Python
"""
Python 3.9 временной-сервер
Название файла '02.временной-сервер.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""

from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime


def main():
    # 1. Создайте объект сокета и укажите, какой транспортный сервис использовать.
    # family=AF_INET - IPv4 адрес
    # family=AF_INET6 - IPv6 адрес
    # type=SOCK_STREAM - TCP сокет
    # type=SOCK_DGRAM - UDP сокет
    # type=SOCK_RAW - raw сокет
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.Привязать IP-адрес и порт (чтобы различать разные сервисы)
    server.bind(('192.168.1.2', 6789))
    # 3.Включите мониторинг-прослушивание клиентских подключений к серверу.
    server.listen(512)
    print('Сервер запускается и начинает слушать...')
    # 4.Получение соединения клиента по шлейфу и выполнение соответствующей обработки (предоставление услуг)
    while True:
        # Метод accept - это метод блокировки, если к серверу не подключен клиент
        # Этот метод заблокирует код и не будет выполняться вниз
        # метод accept возвращает первый элемент кортежа - это клиентский объект
        # Второй элемент - это адрес клиента (состоит из двух частей: IP и порт)
        client, addr = server.accept()
        print(str(addr) + 'Подключено к серверу.')
        # 5.Отправить данные
        client.send(str(datetime.now()).encode('utf-8'))
        # 6.Отключитесь
        client.close()


if __name__ == '__main__':
    main()
```

После запуска серверной программы мы можем получить доступ к серверу через telnet системы Windows, и результат 
показан на рисунке ниже.

```Shell
telnet 192.168.1.2 6789
```


Конечно, мы также можем реализовать функцию TCP-клиента через программу Python. По сравнению с программой-сервером, 
программа-клиент намного проще. Код показан ниже.


```Python
"""
Python 3.9 временной-клиент
Название файла '03.временной-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from socket import socket


def main():
    client = socket()
    client.connect(('192.168.1.9', 6789))
    print(client.recv(1024).decode('utf-8'))
    client.close()


if __name__ == '__main__':
    main()

```

Следует отметить, что указанный выше сервер не использует многопоточность или асинхронную обработку ввода-вывода, 
что означает, что, когда сервер взаимодействует с одним клиентом, другие клиенты могут только ждать в очереди. 
Очевидно, что такой сервер не может удовлетворить наши потребности: необходимый нам сервер способен одновременно 
принимать и обрабатывать несколько пользовательских запросов. Давайте спроектируем файловый сервер, который использует 
технологию многопоточности для обработки нескольких пользовательских запросов.Сервер будет отправлять изображение 
клиенту, подключенному к серверу.
Серверный код:

```Python
"""
Python 3.9 файловый-сервер
Название файла '04.файловый-сервер.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from socket import socket, SOCK_STREAM, AF_INET
from base64 import b64encode
from json import dumps
from threading import Thread


def main():
   # Пользовательский класс потока
   class FileTransferHandler(Thread):

      def __init__(self, cclient):
         super().__init__()
         self.cclient = cclient

      def run(self):
         my_dict = {}
         my_dict['filename'] = '99.guido.jpg'
         # JSON - это простой текст и не может переносить двоичные данные
         # Таким образом, двоичные данные изображения должны быть обработаны в кодировке base64
         my_dict['filedata'] = data
         # Преобразование словаря в строку JSON с помощью функции дампа
         json_str = dumps(my_dict)
         # Отправить строку JSON
         self.cclient.send(json_str.encode('utf-8'))
         self.cclient.close()

   # 1. Создайте объект сокета и укажите, какой транспортный сервис использовать.
   server = socket()
   # 2. Привязать IP-адрес и порт (чтобы различать разные сервисы)
   server.bind(('192.168.1.2', 5566))
   # 3. Включите мониторинг-прослушивание клиентских подключений к серверу.
   server.listen(512)
   print('Сервер запускается и начинает слушать .....')
   with open('99.guido.jpg', 'rb') as f:
      # Обработать двоичные данные в base64 и затем декодировать их в строку
      data = b64encode(f.read()).decode('utf-8')
   while True:
      client, addr = server.accept()
      # Используйте словарь (пара ключ-значение) для сохранения различных данных для отправки
      # Позже словарь может быть преобразован в формат JSON и передан по сети
      FileTransferHandler(client).start()


if __name__ == '__main__':
   main()

```

Код клиента:

```Python
"""
Python 3.9 файловый-клиент
Название файла '05.файловый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from socket import socket
from json import loads
from base64 import b64decode


def main():
    client = socket()
    client.connect(('192.168.1.2', 5566))
    # Определить объект, который сохраняет двоичные данные
    in_data = bytes()
    # Поскольку я не знаю, насколько велики данные, отправляемые сервером, я получаю 1024 байта каждый раз
    data = client.recv(1024)
    while data:
        # Объединить полученные данные
        in_data += data
        data = client.recv(1024)
        # Декодировать полученные двоичные данные в строку JSON и преобразовать в словарь
        # Функция  # load - преобразовать строки JSON в объекты словаря.
    my_dict = loads(in_data.decode('utf-8'))
    filename = my_dict['filename']
    filedata = my_dict['filedata'].encode('utf-8')
    with open('/Users/admin/' + filename, 'wb') as f:
        # Декодировать данные формата base64 в двоичные данные и записывать их в файл
        f.write(b64decode(filedata))
    print('Картинка сохранена.')


if __name__ == '__main__':
    main()
```

В этом случае мы использовали JSON в качестве формата передачи данных (передаваемые данные сериализуются и 
десериализуются через формат JSON), но JSON не может нести двоичные данные, поэтому двоичные данные изображения 
обрабатываются в кодировке Base64. Base64 - это метод кодирования, который использует 64 символа для представления 
всех двоичных данных. Реорганизуя двоичные данные в группы по 6 бит, вы можете просто использовать цифры 0–9, буквы 
верхнего и нижнего регистра, а также "+" и "/" A всего 64 символа представляют 64 состояния от 000000 до 111111. В 
Википедии есть подробное объяснение кодировки Base64, и читатели, не знакомые с Base64, могут прочитать его сами.

> Примечание. Приведенный выше код предназначен в основном для объяснения связанного содержания сетевого 
> программирования, поэтому он не имеет отношения к ненормальным условиям. Читателям предлагается добавить код 
> обработки исключений, чтобы повысить надежность программы.

#### UDP-сокет

В дополнение к надежному протоколу передачи TCP, транспортный уровень также имеет очень легкий протокол передачи, 
называемый протоколом дейтаграмм пользователя, или сокращенно UDP. И TCP, и UDP - это протоколы, которые 
предоставляют услуги сквозной передачи. Разница между ними такая же, как между вызовом и отправкой текстового 
сообщения. Последнее не дает никаких обещаний относительно надежности и доступности передача, что позволяет 
избежать квитирования по TCP. Но увы не предусматривает повторную передачу, поэтому в сценариях, которые 
делают упор на производительность, а не на целостность данных (например, передача сетевых аудио- и видеоданных), 
UDP может быть лучшим выбором. Вы можете заметить что при просмотре онлайн-видео иногда будут 
зависания, а иногда будут размытые экраны. Это не что иное, как часть передачи данных или неправильная передача. Вы 
также можете использовать сокеты UDP для создания сетевых приложений на Python, мы не будем вдаваться в подробности 
об этом, и заинтересованные читатели могут изучить их самостоятельно.
UDP-сервер:
```python
"""
Python 3.9 Сервер Socket-Echo на основе протокола UDP
Название файла '08.сервер_udp.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from socket import *


server = socket(AF_INET, SOCK_DGRAM)
server.bind(('localhost', 6789))
while True:
    data, addr = server.recvfrom(1024)
    server.sendto(data, addr)
server.close()

```
UDP-клиент:
```python
"""
Python 3.9 Socket-Create Echo клиент на основе протокола UDP
Название файла '09.клиент_udp.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""

from socket import *

client = socket(AF_INET, SOCK_DGRAM)
while True:
    data_str = input('Пожалуйста, введите: ')
    client.sendto(data_str.encode('utf-8'), ('localhost', 6789))
    data, addr = client.recvfrom(1024)
    data_str = data.decode('utf-8')
    print('Ответ сервера:', data_str)
    if data_str == 'bye':
        break
client.close()
```

### Разработка веб-приложений

### Отправить электронное письмо 
Сегодня с развитием программного обеспечения для обмена мгновенными сообщениями электронная почта по-прежнему 
остается одним из наиболее широко используемых приложений в Интернете. Компания отправляет заявителю уведомление 
о приеме на работу, веб-сайт отправляет пользователю ссылку для активации учетной записи, а банк продвигает свои 
финансовые продукты среди клиентов и т. д. Практически все это делается по электронной почте, и эти задачи 
должны выполняться программой автоматически.

Подобно тому, как мы можем использовать HTTP (протокол передачи гипертекста) для посещения веб-сайтов, мы 
можем отправлять письма для использования SMTP (простой протокол передачи почты). SMTP также основан на надежной 
службе передачи данных, предоставляемой TCP (протокол управления передачей). протокол, который определяет детали 
того, как отправитель почты взаимодействует с почтовым сервером, а модуль smtplib в Python упрощает эти операции до 
нескольких простых функций.

Следующий код демонстрирует, как отправлять почту в Python.

```Python
"""
Python 3.9 почтовый-клиент SMTP-протокол
Название файла '14.почтовый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""
from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def main():
    message = MIMEMultipart()
    text_content = MIMEText('текст сообщения', 'plain', 'utf-8')
    message['Subject'] = Header('Здравствуте!', 'utf-8')
    message.attach(text_content)

    with open('/Users/admin/Desktop/hello.txt', 'rb') as f:
        txt = MIMEText(f.read(), 'base64', 'utf-8')
        txt['Content-Type'] = 'text/plain'
        txt['Content-Disposition'] = 'attachment; filename=hello.txt'
        message.attach(txt)
    with open('/Users/admin/Desktop/hi.xlsx', 'rb') as f:
        xls = MIMEText(f.read(), 'base64', 'utf-8')
        xls['Content-Type'] = 'application/vnd.ms-excel'
        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'
        message.attach(xls)

    smtper = SMTP('smtp.222.com')
    # smtper.starttls()
    sender = 'abcdefg@222.com'
    receivers = ['uvwxyz@qq.com']
    smtper.login(sender, 'secretpass')
    smtper.sendmail(sender, receivers, message.as_string())
    smtper.quit()
    print('почта отправлена!')


if __name__ == '__main__':
    main()

```

Если вы хотите отправить электронное письмо с вложениями, вы можете выполнить следующие действия.

```Python
"""
Python 3.9 почтовый-сервер SMTP-протокол
Название файла '14.почтовый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2021-11-13
"""

from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart




def main():
    message = MIMEMultipart()
    text_content = MIMEText('текст сообщения', 'plain', 'utf-8')
    message['Subject'] = Header('Здравствуте!', 'utf-8')
    message.attach(text_content)

    with open('/Users/admin/Desktop/hello.txt', 'rb') as f:
        txt = MIMEText(f.read(), 'base64', 'utf-8')
        txt['Content-Type'] = 'text/plain'
        txt['Content-Disposition'] = 'attachment; filename=hello.txt'
        message.attach(txt)
    with open('/Users/admin/Desktop/hi.xlsx', 'rb') as f:
        xls = MIMEText(f.read(), 'base64', 'utf-8')
        xls['Content-Type'] = 'application/vnd.ms-excel'
        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'
        message.attach(xls)

    smtper = SMTP('smtp.222.com')
    # smtper.starttls()
    sender = 'abcdefg@222.com'
    receivers = ['uvwxyz@qq.com']
    smtper.login(sender, 'secretpass')
    smtper.sendmail(sender, receivers, message.as_string())
    smtper.quit()
    print('почта отправлена!')


if __name__ == '__main__':
    main()

```
