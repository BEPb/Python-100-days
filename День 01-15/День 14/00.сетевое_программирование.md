## Начало работы с сетевым программированием

### Фундамент компьютерной сети

Компьютерная сеть - это общий термин для систем, которые связаны между собой независимыми компьютерами.Основная цель построения компьютерной сети - реализовать связь и совместное использование ресурсов между несколькими компьютерами. Сегодняшние компьютерные сети имеют бесчисленное количество устройств и пользователей компьютерных сетей, и компьютерную сеть также можно назвать «сложной гигантской системой». Для такой системы мы не можем четко объяснить ее в одной или двух статьях. Заинтересованные читатели могут прочитать классическую «Компьютерную сеть» Эндрю С. Таненбаума или «Компьютерная сеть: метод сверху вниз» в соавторстве с Курозом и Россом, чтобы узнать о компьютерных сетях.


#### TCP/IP модель

Основой сетевой коммуникации являются протоколы сетевой коммуникации, которые обычно разрабатываются Инженерной группой Интернета (IETF). Так называемый «протокол» - это набор соглашений, которым обе стороны коммуникационного компьютера должны следовать вместе, например, как установить соединение, как распознать друг друга и т. Д. Три элемента сетевого протокола: синтаксис, семантика и время. Основой Интернета, который мы используем сегодня, является набор протоколов TCP / IP. Так называемый набор протоколов представляет собой серию протоколов и их моделей связи. Мы обычно называем этот набор вещей моделью TCP / IP. В отличие от семиуровневой модели OSI / RM, выпущенной Международной организацией по стандартизации, TCP / IP представляет собой четырехуровневую модель, то есть модель логически разделяет используемую нами сеть на четыре уровня, снизу вверх: Уровень сетевого интерфейса, сетевой уровень, транспортный уровень и прикладной уровень показаны на рисунке ниже.

IP обычно переводится в Интернет-протокол, который обслуживает сетевой уровень и в основном реализует функции адресации и маршрутизации. Каждый хост, который обращается к сети, должен иметь свой собственный IP-адрес, и этот IP-адрес является идентификатором хоста в компьютерной сети. Конечно, из-за отсутствия адресов IPv4 IP-адреса, которые мы обычно получаем при серфинге в Интернете в домах, офисах и других общественных местах, которые могут получить доступ в Интернет, являются не единственными IP-адресами в мире, но и внутренними IP-адресами. в виде локальной сети (LAN) . трансляция сетевых адресов службы (NAT) мы можем также обеспечить доступ к сети. В компьютерной сети имеется большое количество сетевых релейных устройств, называемых « маршрутизаторами » . Они хранят и пересылают пакеты данных, которые мы отправляем в сеть, так что данные из источника могут наконец найти путь к месту назначения. Эта функция это так называемая маршрутизация.

Полное название TCP - это протокол управления передачей. Он основан на услугах адресации и маршрутизации, предоставляемых IP, и отвечает за обеспечение сквозной надежной передачи. Протокол TCP называется надежным протоколом передачи, потому что TCP обещает три вещи для звонящего. Одно:

Данные не будут потеряны или переданы некорректно (это может быть достигнуто с помощью механизмов подтверждения, контрольной суммы и повторной передачи).
Управление потоком (согласование скорости передачи данных между отправителем и получателем через скользящее окно).
Контроль перегрузки (уменьшение перегрузки сети за счет времени RTT и контроля скользящих окон).
Режим сетевого приложения
Режим C / S и режим B / S. Здесь C относится к клиенту (клиенту), обычно приложению, которое необходимо установить в операционной системе хоста; и B относится к браузеру, который устанавливается по умолчанию почти во всех графических операционных системах. S (сервер) может быть достигнут через C или B. В Интернете есть много статей о сравнении и обсуждении этих двух устройств, поэтому мы не будем больше тратить здесь перо и чернила.
Модель децентрализованного сетевого приложения. Независимо от того, B / S или C / S, наличие сервера обязательно. Сервер является центром всей модели приложения. Децентрализованные сетевые приложения обычно не имеют фиксированного сервера или фиксированного клиента. Все пользователи приложение может использоваться как ресурсы.Провайдер может также выступать в качестве посетителя ресурса.
Доступ к сетевым ресурсам на основе протокола HTTP
HTTP (протокол передачи гипертекста)
HTTP это аббревиатура Hyper-Text Transfer Protocol (Hyper-Text Transfer Proctol) Интерпретация HTTP на Википедии:.. Hyper-Text Transfer Protocol представляет собой протокол прикладного уровня для распределенных, совместных и гипермедиа информационных систем Это основа обмен данными во всемирной паутине . Первоначальная цель HTTP - предоставить метод публикации и получения HTML- страниц . Ресурсы, запрашиваемые через HTTP или HTTPS (протокол безопасности передачи гипертекста) , идентифицируются с помощью URI ( унифицированного идентификатора ресурса ). Для получения дополнительной информации о HTTP мы рекомендуем прочитать «Введение в протокол HTTP» г-на Руана Ифэна . Проще говоря, через HTTP мы можем получать (символьные) ресурсы в сети и сетевые API, которые часто используются при разработке ( в том числе место также называется сетевым интерфейсом данных) основан на HTTP для реализации передачи данных.

Формат JSON
JSON ( J AVA S cript O bject N otation ) - это облегченный язык обмена данными, который упрощает чтение текста (обычного текста) на основе значений атрибутов, используемых для передачи или состоящих из последовательности значений объекта данных. Хотя JSON изначально был просто буквальным синтаксисом для создания объектов в Javascript, теперь это формат данных, не зависящий от языка. Многие языки программирования поддерживают создание и анализ данных в формате JSON, а также встроенный модуль json в Python. Предоставляет эту функцию. Поскольку JSON - это текст, а его XML как применим для обмена данными между разнородными системами, а по сравнению с XML, JSON еще более легкий и элегантный. Ниже приведены XML и JSON, которые выражают одну и ту же информацию, и преимущества JSON довольно интуитивно понятны.

#### JSON

```XML
<?xml version="1.0" encoding="UTF-8"?>
<message>
	<from>Alice</from>
	<to>Bob</to>
	<content>Will you marry me?</content>
</message>
```


```JSON
{
    "from": "Alice",
    "to": "Bob",
    "content": "Will you marry me?"
}
```

#### библиотека запросов
request - это третья библиотека, которая использует сеть на основе протокола HTTP. На ее официальном веб-сайте есть такое предложение, чтобы представить ее: «Запросы - это единственная HTTP-библиотека Python без ГМО, которой могут безопасно пользоваться люди». Проще говоря, используйте запросы. Библиотеки могут легко использовать HTTP, чтобы избежать недостатков безопасности, избыточного кода и «повторного изобретения колеса» (отраслевой идиома, обычно используемая в области разработки программного обеспечения для обозначения воссоздания существующего или оптимизированного базового метода). Мы уже использовали эту библиотеку в предыдущей статье. Затем мы будем использовать запросы для реализации интерфейса сетевых данных доступа и получения от него ссылки для загрузки изображения красоты, а затем загрузим изображение красоты в локальный пример программы. Программа использует сеть, предоставляемая Tianxing Data API.

Сначала мы можем установить запросы и зависимые от них библиотеки через pip.

```Shell
pip install requests
```

Если вы используете PyCharm в качестве инструмента разработки, вы можете писать прямо в коде import requests, а затем использовать функцию восстановления кода для автоматической загрузки и установки запросов.


```Python
from time import time
from threading import Thread

import requests


# 继承Thread类创建自定义的线程类
class DownloadHanlder(Thread):

    def __init__(self, url):
        super().__init__()
        self.url = url

    def run(self):
        filename = self.url[self.url.rfind('/') + 1:]
        resp = requests.get(self.url)
        with open('/Users/Hao/' + filename, 'wb') as f:
            f.write(resp.content)


def main():
    # 通过requests模块的get函数获取网络资源
    # 下面的代码中使用了天行数据接口提供的网络API
    # 要使用该数据接口需要在天行数据的网站上注册
    # 然后用自己的Key替换掉下面代码的中APIKey即可
    resp = requests.get(
        'http://api.tianapi.com/meinv/?key=APIKey&num=10')
    # 将服务器返回的JSON格式的数据解析为字典
    data_model = resp.json()
    for mm_dict in data_model['newslist']:
        url = mm_dict['picUrl']
        # 通过多线程的方式实现图片下载
        DownloadHanlder(url).start()


if __name__ == '__main__':
    main()
```

Программирование сокетов на основе протокола транспортного уровня
Термин сокет очень неясен и незнаком многим людям, не разбирающимся в сетевом программировании. Фактически, проще говоря, сокет - это набор библиотек разработки приложений, написанных на языке C , в основном используемых для реализации межпроцессного взаимодействия и Сетевое программирование широко используется при разработке сетевых приложений. В Python вы также можете использовать службы передачи, предоставляемые транспортным уровнем на основе сокетов, и разрабатывать свои собственные сетевые приложения на их основе. Сокеты, используемые в реальной разработке, можно разделить на три категории: сокеты потоков (сокеты TCP), сокеты дейтаграмм и необработанные сокеты.

Сокет TCP
Так называемый TCP-сокет - это программный интерфейс, который использует службу передачи, предоставляемую протоколом TCP, для реализации сетевого взаимодействия. В Python вы можете использовать сокеты TCP, создав объект сокета и указав атрибут типа как SOCK_STREAM. Поскольку хост может иметь несколько IP-адресов и может быть настроен с несколькими различными службами, как серверная программа, он должен быть привязан к указанному IP-адресу и порту после создания объекта сокета. Порт здесь не физическое устройство, а расширение IP-адреса для различения различных служб. Например, мы обычно привязываем службу HTTP к порту 80, в то время как служба базы данных MySQL привязана к порту 3306 по умолчанию, так что когда сервер получает Когда пользователь запрашивает его, номер порта может использоваться, чтобы определить, запрашивал ли пользователь услугу, предоставляемую сервером HTTP или сервером базы данных. Диапазон значений порта составляет 0 ~ 65535, и порты ниже 1024 обычно называются «известными портами» (порты, зарезервированные для «известных служб», таких как FTP, HTTP, SMTP и т. Д., А в некоторых местах они также называются «известными портами») известные порты ". Известные порты"), пользовательские службы обычно не используют эти порты, если только пользовательские службы не являются широко известными службами, такими как HTTP или FTP.

Следующий код реализует сервер, который предоставляет время и дату.

```Python
from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime


def main():
    # 1.创建套接字对象并指定使用哪种传输服务
    # family=AF_INET - IPv4地址
    # family=AF_INET6 - IPv6地址
    # type=SOCK_STREAM - TCP套接字
    # type=SOCK_DGRAM - UDP套接字
    # type=SOCK_RAW - 原始套接字
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.绑定IP地址和端口(端口用于区分不同的服务)
    # 同一时间在同一个端口上只能绑定一个服务否则报错
    server.bind(('192.168.1.2', 6789))
    # 3.开启监听 - 监听客户端连接到服务器
    # 参数512可以理解为连接队列的大小
    server.listen(512)
    print('服务器启动开始监听...')
    while True:
        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)
        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行
        # accept方法返回一个元组其中的第一个元素是客户端对象
        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)
        client, addr = server.accept()
        print(str(addr) + '连接到了服务器.')
        # 5.发送数据
        client.send(str(datetime.now()).encode('utf-8'))
        # 6.断开连接
        client.close()


if __name__ == '__main__':
    main()
```

После запуска серверной программы мы можем получить доступ к серверу через telnet системы Windows, и результат показан на рисунке ниже.

```Shell
telnet 192.168.1.2 6789
```


Конечно, мы также можем реализовать функцию TCP-клиента через программу Python. По сравнению с программой-сервером, программа-клиент намного проще. Код показан ниже.


```Python
from socket import socket


def main():
    # 1.创建套接字对象默认使用IPv4和TCP协议
    client = socket()
    # 2.连接到服务器(需要指定IP地址和端口)
    client.connect(('192.168.1.2', 6789))
    # 3.从服务器接收数据
    print(client.recv(1024).decode('utf-8'))
    client.close()


if __name__ == '__main__':
    main()
```

Следует отметить, что указанный выше сервер не использует многопоточность или асинхронную обработку ввода-вывода, что означает, что, когда сервер взаимодействует с одним клиентом, другие клиенты могут только ждать в очереди. Очевидно, что такой сервер не может удовлетворить наши потребности: необходимый нам сервер способен одновременно принимать и обрабатывать несколько пользовательских запросов. Давайте спроектируем сервер, который использует технологию многопоточности для обработки нескольких пользовательских запросов.Сервер будет отправлять изображение клиенту, подключенному к серверу.
Серверный код:

```Python
from socket import socket, SOCK_STREAM, AF_INET
from base64 import b64encode
from json import dumps
from threading import Thread


def main():
    
    # 自定义线程类
    class FileTransferHandler(Thread):

        def __init__(self, cclient):
            super().__init__()
            self.cclient = cclient

        def run(self):
            my_dict = {}
            my_dict['filename'] = 'guido.jpg'
            # JSON是纯文本不能携带二进制数据
            # 所以图片的二进制数据要处理成base64编码
            my_dict['filedata'] = data
            # 通过dumps函数将字典处理成JSON字符串
            json_str = dumps(my_dict)
            # 发送JSON字符串
            self.cclient.send(json_str.encode('utf-8'))
            self.cclient.close()

    # 1.创建套接字对象并指定使用哪种传输服务
    server = socket()
    # 2.绑定IP地址和端口(区分不同的服务)
    server.bind(('192.168.1.2', 5566))
    # 3.开启监听 - 监听客户端连接到服务器
    server.listen(512)
    print('服务器启动开始监听...')
    with open('guido.jpg', 'rb') as f:
        # 将二进制数据处理成base64再解码成字符串
        data = b64encode(f.read()).decode('utf-8')
    while True:
        client, addr = server.accept()
        # 启动一个线程来处理客户端的请求
        FileTransferHandler(client).start()


if __name__ == '__main__':
    main()
```

Код клиента:

```Python
from socket import socket
from json import loads
from base64 import b64decode


def main():
    client = socket()
    client.connect(('192.168.1.2', 5566))
    # 定义一个保存二进制数据的对象
    in_data = bytes()
    # 由于不知道服务器发送的数据有多大每次接收1024字节
    data = client.recv(1024)
    while data:
        # 将收到的数据拼接起来
        in_data += data
        data = client.recv(1024)
    # 将收到的二进制数据解码成JSON字符串并转换成字典
    # loads函数的作用就是将JSON字符串转成字典对象
    my_dict = loads(in_data.decode('utf-8'))
    filename = my_dict['filename']
    filedata = my_dict['filedata'].encode('utf-8')
    with open('/Users/Hao/' + filename, 'wb') as f:
        # 将base64格式的数据解码成二进制数据并写入文件
        f.write(b64decode(filedata))
    print('图片已保存.')


if __name__ == '__main__':
    main()
```

В этом случае мы использовали JSON в качестве формата передачи данных (передаваемые данные сериализуются и десериализуются через формат JSON), но JSON не может нести двоичные данные, поэтому двоичные данные изображения обрабатываются в кодировке Base64. Base64 - это метод кодирования, который использует 64 символа для представления всех двоичных данных. Реорганизуя двоичные данные в группы по 6 бит, вы можете просто использовать цифры 0–9, буквы верхнего и нижнего регистра, а также "+" и "/" A всего 64 символа представляют 64 состояния от 000000до 111111. В Википедии есть подробное объяснение кодировки Base64, и читатели, не знакомые с Base64, могут прочитать его сами.

> Примечание. Приведенный выше код предназначен в основном для объяснения связанного содержания сетевого программирования, поэтому он не имеет отношения к ненормальным условиям. Читателям предлагается добавить код обработки исключений, чтобы повысить надежность программы.

#### UDP-сокет
В дополнение к надежному протоколу передачи TCP, транспортный уровень также имеет очень легкий протокол передачи, называемый протоколом дейтаграмм пользователя, или сокращенно UDP. И TCP, и UDP - это протоколы, которые предоставляют услуги сквозной передачи. Разница между ними такая же, как между вызовом и отправкой текстового сообщения. Последнее не дает никаких обещаний относительно надежности и доступности передача, что позволяет избежать квитирования и квитирования в TCP. Накладные расходы на повторную передачу, поэтому в сценариях, которые делают упор на производительность, а не на целостность данных (например, передача сетевых аудио- и видеоданных), UDP может быть лучшим выбором. Вы можете заметить явление, то есть при просмотре онлайн-видео иногда будут зависания, а иногда будут размытые экраны.Это не что иное, как часть передачи данных или неправильная передача. Вы также можете использовать сокеты UDP для создания сетевых приложений на Python, мы не будем вдаваться в подробности об этом, и заинтересованные читатели могут изучить их самостоятельно.

### Разработка веб-приложений
отправить электронное письмо
Сегодня с развитием программного обеспечения для обмена мгновенными сообщениями электронная почта по-прежнему остается одним из наиболее широко используемых приложений в Интернете. Компания отправляет заявителю уведомление о приеме на работу, веб-сайт отправляет пользователю ссылку для активации учетной записи, а банк продвигает свои финансовые продукты среди клиентов и т. д. Практически все это делается по электронной почте, и эти задачи должны выполняться программой автоматически.

Подобно тому, как мы можем использовать HTTP (протокол передачи гипертекста) для посещения веб-сайтов, отправлять письма для использования SMTP (простой протокол передачи почты), SMTP также основан на надежной службе передачи данных, предоставляемой TCP (протокол управления передачей). протокол, который определяет детали того, как отправитель почты взаимодействует с почтовым сервером, а модуль smtplib в Python упрощает эти операции до нескольких простых функций.

Следующий код демонстрирует, как отправлять почту в Python.

```Python
from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText


def main():
    # 请自行修改下面的邮件发送者和接收者
    sender = 'abcdefg@126.com'
    receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com']
    message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8')
    message['From'] = Header('王大锤', 'utf-8')
    message['To'] = Header('骆昊', 'utf-8')
    message['Subject'] = Header('示例代码实验邮件', 'utf-8')
    smtper = SMTP('smtp.126.com')
    # 请自行修改下面的登录口令
    smtper.login(sender, 'secretpass')
    smtper.sendmail(sender, receivers, message.as_string())
    print('邮件发送完成!')


if __name__ == '__main__':
    main()
```

Если вы хотите отправить электронное письмо с вложениями, вы можете выполнить следующие действия.

```Python
from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart

import urllib


def main():
    # 创建一个带附件的邮件消息对象
    message = MIMEMultipart()
    
    # 创建文本内容
    text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8')
    message['Subject'] = Header('本月数据', 'utf-8')
    # 将文本内容添加到邮件消息对象中
    message.attach(text_content)

    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open('/Users/Hao/Desktop/hello.txt', 'rb') as f:
        txt = MIMEText(f.read(), 'base64', 'utf-8')
        txt['Content-Type'] = 'text/plain'
        txt['Content-Disposition'] = 'attachment; filename=hello.txt'
        message.attach(txt)
    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f:
        xls = MIMEText(f.read(), 'base64', 'utf-8')
        xls['Content-Type'] = 'application/vnd.ms-excel'
        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'
        message.attach(xls)
    
    # 创建SMTP对象
    smtper = SMTP('smtp.126.com')
    # 开启安全连接
    # smtper.starttls()
    sender = 'abcdefg@126.com'
    receivers = ['uvwxyz@qq.com']
    # 登录到SMTP服务器
    # 请注意此处不是使用密码而是邮件客户端授权码进行登录
    # 对此有疑问的读者可以联系自己使用的邮件服务器客服
    smtper.login(sender, 'secretpass')
    # 发送邮件
    smtper.sendmail(sender, receivers, message.as_string())
    # 与邮件服务器断开连接
    smtper.quit()
    print('发送完成!')


if __name__ == '__main__':
    main()
```

#### отправлять сообщения
Отправка SMS - также распространенная функция в проекте. Регистрационный код, код подтверждения и маркетинговая информация веб-сайта в основном отправляются пользователям через SMS. В приведенном ниже коде мы используем платформу Mutual Billion Wireless SMS (эта платформа предоставляет зарегистрированным пользователям 50 бесплатных SMS и демонстрационные версии для отправки SMS на распространенных языках разработки. Вы можете войти на веб-сайт и настроить SMS в самообслуживании пользователя. Страница) Предоставляемый интерфейс API реализует услугу отправки SMS. Конечно, в Китае существует множество платформ для SMS, и читатели могут выбирать в соответствии со своими потребностями (обычно с учетом бюджета, скорости охвата SMS, простоты использования и других показателей) Для использования SMS-сервиса в проекте рекомендуется приобрести пакет услуг, предоставляемый платформой SMS.

```Python
import urllib.parse
import http.client
import json


def main():
    host  = "106.ihuyi.com"
    sms_send_uri = "/webservice/sms.php?method=Submit"
    # 下面的参数需要填入自己注册的账号和对应的密码
    params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' })
    print(params)
    headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'}
    conn = http.client.HTTPConnection(host, port=80, timeout=30)
    conn.request('POST', sms_send_uri, params, headers)
    response = conn.getresponse()
    response_str = response.read()
    jsonstr = response_str.decode('utf-8')
    print(json.loads(jsonstr))
    conn.close()


if __name__ == '__main__':
    main()
```