[Вернуться на главную](https://github.com/BEPb/Python-100-days)


## Начало работы с сетевым программированием

### Основы компьютерных сетей

Компьютерные сети – это совокупность устройств и программных средств, которые позволяют обмениваться информацией 
между компьютерами и другими устройствами, подключенными к ним. Целью компьютерной сети является обеспечение 
эффективного и надежного обмена данными внутри организации или между различными организациями.  

Основные элементы компьютерной сети – это:

1. Компьютеры и другие устройства (например, принтеры, маршрутизаторы и т.д.), подключаемые к сети.
2. Кабели, которые используются для передачи данных между устройствами. 
3. Сетевые интерфейсы, которые позволяют устройствам подключаться к сети. 
4. сетевые протоколы, которые определяют способ передачи данных по сети. 

Существуют различные типы компьютерных сетей, такие как локальные сети (LAN), глобальные сети (WAN) и 
метрополитенские сети (MAN). Каждый тип сети имеет свои характеристики и особенности, которые определяются ее 
географическим положением, числом устройств и другими факторами.  

Важно учитывать аспекты безопасности при проектировании и использовании компьютерных сетей, так как утечка 
информации может иметь серьезные последствия. Для защиты сети могут применяться различные технологии и меры 
безопасности, такие как брандмауэры, антивирусные программы и криптография.   

### История развития компьютерных сетей

История развития компьютерных сетей началась в 1960-х годах, когда компьютеры стали использоваться в бизнесе и 
учебных заведениях. В то время компьютеры работали самостоятельно и не могли обмениваться информацией. Для того 
чтобы решить эту проблему, была разработана технология передачи данных по телефонным линиям, которая стала основой 
для создания первых компьютерных сетей.   

В 1970-х годах компьютерные сети стали распространяться все шире, и были разработаны первые протоколы передачи 
данных. Самой известной из них стала технология передачи данных с использованием протокола TCP/IP, которая стала 
основой Интернета.  

В 1980-е и 1990-е годы развитие компьютерных сетей достигло своего пика. Компьютерные сети стали использоваться в 
огромном количестве различных сферах деятельности, включая бизнес, науку и государственные учреждения. Были созданы 
новые технологии, такие как локальные сети или Wi-Fi.  

Сегодня компьютерные сети являются неотъемлемой частью жизни человека. Они используются для обмена информацией, 
выполнения задач и доступа к различным ресурсам в Интернете. Кроме того, компьютерные сети стали главным средством 
связи между различными устройствами, которые используются в быту, включая смартфоны, планшеты и другие устройства 
соединенные сетями Интернет.   

#### TCP/IP модель

Основой сетевой коммуникации являются соотв. протоколы, которые обычно разрабатываются Инженерной 
группой Интернета (IETF). Так называемый «протокол» - это набор соглашений, которым обе стороны коммуникационного 
оборудования должны выполнять, например, как установить соединение, как распознать друг друга и т. д. Три 
элемента сетевого протокола: синтаксис, семантика и время. Основой Интернета, который мы используем сегодня, 
является набор протоколов TCP/IP. Так называемый набор протоколов представляет собой серию протоколов и их моделей 
связи. В отличие от семиуровневой модели OSI/RM, выпущенной Международной организацией по стандартизации. TCP/IP 
представляет собой четырехуровневую модель, то есть модель логически разделяет используемую нами сеть на четыре 
уровня, снизу вверх: 

- Прикладной уровень (Application Layer),
- Транспортный уровень (Transport Layer),
- Межсетевой уровень (Сетевой уровень) (Internet Layer),
- Канальный уровень (Network Access Layer).


Каждый уровень выполняет свои функции, связанные с передачей данных в сети.

Канальный уровень или уровень сетевого доступа отвечает за физическое подключение компьютеров к сети и передачу данных 
между сопряженными сетевыми устройствами. 

Межсетевой уровень обеспечивает маршрутизацию данных между различными сетями.

Транспортный уровень обрабатывает надежную передачу данных, устанавливает соединение между приложениями и определяет,
как передавать данные, используя протоколы TCP и UDP. 

Прикладной уровень включает в себя всевозможные приложения и протоколы, используемые для передачи конкретных видов 
данных - например, электронной почты, веб-страниц, файлов и т.д. 

### IP-адрес 

IP-адрес (англ. Internet Protocol Address) - это уникальный идентификатор, который присваивается каждому устройству, 
подключенному к сети Интернет. Он состоит из четырех блоков цифр, разделенных точками, например, 192.168.0.1. 
IP-адрес необходим для обеспечения связи между устройствами в сети Интернет, и он позволяет адресатам опознавать 
отправителей сообщений и данных. IP-адресы бывают двух видов: IPv4 (32-битный) и IPv6 (128-битный).   

IP обычно переводится как Интернет-протокол, который обслуживает сетевой уровень и в основном реализует функции 
адресации и маршрутизации. Каждый хост, который обращается к сети, должен иметь свой собственный IP-адрес, и этот 
IP-адрес является идентификатором хоста в компьютерной сети. 
Полное название TCP - это протокол управления передачей. Он основан на услугах адресации и маршрутизации, 
предоставляемых IP, и отвечает за обеспечение сквозной надежной передачи. Протокол TCP называется надежным 
протоколом передачи, потому что TCP обещает три вещи для звонящего. 


1. Данные не будут потеряны или переданы некорректно (это может быть достигнуто с помощью механизмов подтверждения, 
   контрольной суммы и повторной передачи).
2. Управление потоком (согласование скорости передачи данных между отправителем и получателем через скользящее окно).
3. Контроль перегрузки (уменьшение перегрузки сети за счет времени RTT и контроля скользящих окон).



### Формат JSON
JSON (JavaScript Object Notation) - это текстовый формат обмена данными, основанный на синтаксисе JavaScript. 
Принцип работы JSON заключается в том, что данные представляются в виде пар "ключ: значение" (так называемый объект),
которые разделяются запятыми и заключены в фигурные скобки. Также в JSON используются массивы, коих синтаксис очень 
похож на массивы в JavaScript.   

Пример объекта в формате JSON:

```json
{
  "name": "John",
  "age": 30,
  "city": "New York"
}
```

В этом примере в объекте содержатся ключи "name", "age" и "city", а их значениями являются "John", 30 и "New York".

Пример массива в формате JSON:

```json
[
  "apple",
  "banana",
  "cherry"
]
```

В этом примере массив содержит три элемента: "apple", "banana" и "cherry".

### Анализ данных в формате JSON

Конечный результат зависит от конкретных данных, которые вы обрабатываете. Но в целом, в Python можно использовать 
стандартную библиотеку `json` для работы с JSON-данными. Вот пример чтения данных из JSON-файла и вывода на экран: 

```python
import json

# Открываем файл и загружаем данные
with open('data.json') as f:
    data = json.load(f)

# Выводим данные на экран
print(data)
```

Предполагается, что в файле `data.json` содержится JSON-объект. Если вам нужно производить более сложную обработку 
данных, например, фильтрацию, сортировку, агрегацию и т.д., то может быть полезно использовать дополнительные 
библиотеки типа `pandas`.  



### XML

XML (Extensible Markup Language) – это язык разметки документов, созданный для обмена и передачи данных между 
различными программами и устройствами. Вот пример простого XML документа: 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<book>
 <title>Harry Potter and the Philosopher's Stone</title>
 <author>J.K. Rowling</author>
 <published>1997</published>
</book>
```
В данном примере мы имеем элемент `book`, который содержит три других элемента: `title`, `author` и `published`. 
Каждый элемент имеет своё имя и значение, которое заключено внутри тегов. `<?xml version="1.0" encoding="UTF-8"?>` – 
это строка, которая указывает на версию XML и кодировку используемую в документе. Она обычно располагается в самом 
начале каждого XML файла.   


#### Библиотека запросов
request - это третья библиотека, которая использует сеть на основе протокола HTTP. На ее официальном веб-сайте есть 
такое предложение, чтобы представить ее: «Запросы - это единственная HTTP-библиотека Python без ГМО, которой могут 
безопасно пользоваться люди». Проще говоря, используйте запросы. Библиотеки могут легко использовать HTTP, чтобы 
избежать недостатков безопасности, избыточного кода и «повторного изобретения колеса» (отраслевая идиома, обычно 
используемая в области разработки программного обеспечения для обозначения воссоздания существующего или 
оптимизированного базового метода). Мы уже использовали эту библиотеку в предыдущей статье. Затем мы будем 
использовать запросы для реализации интерфейса сетевых данных доступа и получения от него ссылки для загрузки 
изображения красоты, а затем загрузим изображение красоты в локальный пример программы. Программа использует сеть, 
предоставляемая Tianxing Data API.

Сначала мы можем установить запросы и зависимые от них библиотеки через pip.

```Shell
pip install requests
```

Если вы используете PyCharm в качестве инструмента разработки, вы можете писать прямо в коде import requests, а 
затем использовать функцию восстановления кода для автоматической загрузки и установки запросов.

Вот пример многопоточного скачивания файлов с использованием библиотеки `requests` и модуля `threading`:


```Python
"""
Python 3.10 Многопоточное скачивание
Название файла '01.Многопоточное_скачивание.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
import requests
import threading

# Список URL для скачивания
urls = ['https://i.postimg.cc/yNdnFR8y/Screenshot-11.png', 'https://i.postimg.cc/BvmWNyF3/Screenshot-3.png', 'https://i.postimg.cc/g2WN0XZb/Screenshot-1.png']


def download(url):
    # Отправить запрос GET и сохранить содержимое ответа в файл
    response = requests.get(url)
    with open(url.split('/')[-1], 'wb') as file:
        file.write(response.content)
    print(f'Скачивание по ссылке {url} заврешено')


if __name__ == '__main__':
    # Создайте новый поток для каждого URL-адреса в списке URL-адресов
    threads = []
    for url in urls:
        t = threading.Thread(target=download, args=(url,))
        threads.append(t)

    # Начать загрузку каждого файла одновременно
    for thread in threads:
        thread.start()

    # Дождитесь завершения всех потоков перед выходом из основного потока.
    for thread in threads:
        thread.join()

print('Все загрузки завершены!')
```

Этот код создает отдельный поток для каждого URL в списке `urls`. Затем каждый поток вызывает функцию `download`, 
которая отправляет запрос `GET` по URL и сохраняет содержимое ответа в файл. После завершения загрузки каждый поток 
напечатает сообщение об успешной загрузке своего файла. В конце главный поток ждет завершения всех потоков и 
печатает сообщение о завершении загрузок.   


#### Программирование сокетов на основе протокола транспортного уровня
Термин сокет очень неясен и незнаком многим людям, не разбирающимся в сетевом программировании. Фактически, проще 
говоря, сокет - это набор библиотек разработки приложений, написанных на языке C, в основном используемых для 
реализации межпроцессного взаимодействия и cетевое программирование широко используется при разработке сетевых 
приложений. В Python вы также можете использовать службы передачи, предоставляемые транспортным уровнем на основе 
сокетов, и разрабатывать свои собственные сетевые приложения на их основе. Сокеты, используемые в реальной 
разработке, можно разделить на три категории: сокеты потоков (сокеты TCP), сокеты дейтаграмм и необработанные сокеты.

Для запуска сетевого приложения на Python можно использовать библиотеку socket. 

Пример сервера:

```python
import socket

# Создание TCP/IP сокета
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Адрес и порт сервера
server_address = ('localhost', 5000)

# Связываем сокет с заданным адресом и портом
server.bind(server_address)

# Слушаем входящие соединения
server.listen()

while True:
    # Ждем соединения клиента
    connection, client_address = server.accept()

    try:
        print('Client connected:', client_address)

        # Получаем данные от клиента
        data = connection.recv(1024)
        print('Received: ', data.decode())

        # Отправляем ответ клиенту
        response = 'Hello, client!'
        connection.sendall(response.encode())

    finally:
        # Закрываем соединение
        connection.close()
```

Пример клиента:

```python
import socket

# Создание TCP/IP сокета
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Адрес и порт сервера
server_address = ('localhost', 5000)

# Подключение к серверу
client.connect(server_address)

try:
    # Отправка данных серверу
    message = 'Hello, server!'
    client.sendall(message.encode())

    # Получение ответа от сервера
    response = client.recv(1024)
    print('Received: ', response.decode())

finally:
    # Закрытие соединения
    client.close()
```


### Режим «клиент-сервер»

Режим "клиент-сервер" (client-server) в Python означает использование архитектуры, при которой один компьютер 
(клиент) запрашивает данные или услуги у другого компьютера (сервера), который предоставляет эти данные или услуги. 

Для создания серверного приложения необходимо:

1. Импортировать модуль socket:

```python
import socket
```

2. Создать сокет:

```python
s = socket.socket()
```

3. Привязать сокет к определенному адресу и порту:

```python
s.bind(('localhost', 8080))
```

4. Начать прослушивание (ожидание) подключений:

```python
s.listen(5)
```

5. Принять подключение клиента:

```python
client_socket, client_address = s.accept()
```

Теперь сервер готов к принятию запросов от клиентов и обработке полученных данных.

Для создания клиентской части необходимо:

1. Импортировать модуль socket:

```
import socket
```

2. Создать сокет:

```
s = socket.socket()
```

3. Подключиться к серверу по его адресу и порту:

```
s.connect(('localhost', 8080))
```

4. Отправить данные серверу:

```
s.send(b'Hello, server!')
```

5. Получить ответ от сервера:

```
data = s.recv(1024)
```

Теперь клиент может обрабатывать полученные данные от сервера.

Обратите внимание, что это простой пример использования библиотеки socket. В реальных приложениях могут быть 
использованы более сложные протоколы обмена данными и библиотеки, такие как Flask или Django. 

### Режим «браузер-сервер»

Режим "браузер-сервер" в Python - это способ создания веб-приложений, который позволяет запускать локальный сервер, 
на котором можно размещать веб-страницы и обрабатывать запросы пользователей.

Для запуска сервера в Python можно использовать стандартный модуль http.server. Например, чтобы запустить простой 
сервер на порту 8000, нужно выполнить следующие команды в терминале: 

```commandline
python -m http.server 8000
```

После запуска сервера вы можете открыть браузер и перейти по адресу http://localhost:8000, чтобы увидеть содержимое 
каталога, из которого был запущен сервер. 

Обработка запросов пользователя может быть реализована с помощью других модулей, таких как Flask или Django. В этих 
фреймворках можно создавать веб-приложения со сложной логикой и взаимодействием с базами данных.  


Вот пример простого веб-сервера на Python:

```python
from http.server import BaseHTTPRequestHandler, HTTPServer

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        self.wfile.write(b"Hello, world!")

def run(server_class=HTTPServer, handler_class=SimpleHTTPRequestHandler):
    addr = ('', 8000)
    httpd = server_class(addr, handler_class)
    print(f'Serving on {addr}')
    httpd.serve_forever()

if __name__ == '__main__':
    run()
```

Этот код создает простой веб-сервер, который отвечает на все GET-запросы сообщением "Hello, world!". Сервер 
запускается на локальном хосте, порт 8000. Вы можете изменить порт, задав значение переменной `addr`. Запустите этот 
код, и вы сможете перейти на страницу http://localhost:8000 в вашем браузере и увидеть сообщение от сервера.  

Если вы хотите расширить этот пример до полноценного веб-приложения, вам стоит изучить более продвинутые фреймворки, 
такие как Flask или Django. 


### Доступ к сетевым ресурсам на основе протокола HTTP

Протокол HTTP (Hypertext Transfer Protocol) является базовым протоколом для передачи и обмена информацией в 
Интернете. С его помощью можно получать доступ к различным веб-ресурсам, таким как веб-страницы, изображения, видео 
и многое другое. Для этого необходимо воспользоваться браузером и ввести в адресной строке URL-адрес веб-ресурса. В 
ответ на запрос браузер получит ответ от сервера, который будет содержать нужные данные или информацию, изображения 
и т.д. Этот процесс осуществляется на основе протокола HTTP.

Для доступа к сетевым ресурсам на основе протокола HTTP в Python можно использовать библиотеку requests.

Пример запроса GET:

```python
import requests

response = requests.get('http://example.com')
print(response.text)
```

Пример добавления параметров запроса GET:

```python
import requests

payload = {'key1': 'value1', 'key2': 'value2'}
response = requests.get('http://example.com', params=payload)
print(response.url)
```

Пример отправки POST-запроса:

```python
import requests

payload = {'key1': 'value1', 'key2': 'value2'}
response = requests.post('http://example.com', data=payload)
print(response.text)
```

Python предоставляет множество библиотек и модулей, которые облегчают работу с сетевыми протоколами и API. 

Некоторые популярные библиотеки и модули для работы с сетевыми API в Python включают:

1. `Requests` - это очень популярный HTTP-клиент для Python. Он делает запросы на серверы, обрабатывает ответы и 
   представляет их в виде Python-объектов. 

2. `urllib` - это встроенный модуль Python, который позволяет отправлять HTTP-запросы и обрабатывать ответы.

3. `httplib2` - это Python-библиотека для работы с HTTP-запросами с дополнительными возможностями, включая 
   автоматическое кэширование. 

4. `tweepy` - это библиотека для работы с API Twitter. Он обеспечивает удобный интерфейс для отправки запросов и 
   обработки ответов. 

5. `pycurl` - это библиотека для работы с протоколом HTTP и другими протоколами с помощью многопоточности и 
   асинхронности. 

6. `sockets` - это встроенный модуль Python, который позволяет создавать клиент-серверные приложения с 
   использованием сокетов. 

7. `asyncio` - это пакет Python, который позволяет создавать асинхронный код, включая работу с сетевыми API.

Конечно, это только малая часть того, что можно найти в Python для работы с сетевыми API. Но эти библиотеки и модули 
являются наиболее популярными и удобными в использовании. 


Одна из наиболее популярных библиотек - `requests` - предоставляет простой и удобный интерфейс для работы с 
различными протоколами, такими как HTTP/HTTPS. 

Вот пример использования этой библиотки для получения содержимого веб-страницы:

```python
import requests

url = "https://www.example.com/"
response = requests.get(url)

print(response.content)
```

В этом примере мы использовали функцию `get` из библиотеки `requests` для получения страницы по URL-адресу 
`https://www.example.com/`. Затем мы распечатали содержимое полученного объекта ответа. 

Также следует отметить, что библиотека `requests` поддерживает множество других методов для работы с веб-ресурсами, 
таких как `post`, `put`, `delete` и т. д. 

Еще одной популярной библиотекой для работы с сетевым API является `socket`. Эта библиотека обеспечивает доступ к 
сокетам, которые позволяют приложениям обмениваться данными по сети. Вот пример использования библиотеки `socket` 
для отправки сообщения на удаленный сервер:  

```python
import socket

server_address = ('localhost', 5000)
data = b'Hello, world!'
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect(server_address)
client_socket.sendall(data)
client_socket.close()
```

В этом примере мы создали клиентский сокет, установили соединение с сервером, отправили сообщение и закрыли соединение.

Это только несколько примеров библиотек для работы с сетевым API. В Python есть множество других библиотек, которые 
позволяют работать с различными протоколами и протоколами прикладного уровня, такими как FTP, SMTP, POP3 и т. д. 


### Доступ к URL

Для доступа к URL с помощью Python можно использовать модуль `urllib`. Ниже приведен пример кода:

```python
from urllib.request import urlopen

url = 'https://example.com'
response = urlopen(url)
html = response.read()
print(html)
```

Здесь мы импортируем функцию `urlopen` из модуля `urllib.request`, указываем URL, открываем его с помощью `urlopen` 
и считываем содержимое с помощью `read`. Результат будет выведен на экран. Обратите внимание, что это пример 
простого доступа к URL без использования проверки на ошибки.  

#### Сокет TCP
Так называемый TCP-сокет - это программный интерфейс, который использует службу передачи, предоставляемую 
протоколом TCP, для реализации сетевого взаимодействия. В Python вы можете использовать сокеты TCP, создав объект 
сокета и указав атрибут типа как SOCK_STREAM. Поскольку хост может иметь несколько IP-адресов и может быть настроен 
с несколькими различными службами, как серверная программа, он должен быть привязан к указанному IP-адресу и порту после создания объекта сокета. Порт здесь не физическое устройство, а расширение IP-адреса для различения различных служб. Например, мы обычно привязываем службу HTTP к порту 80, в то время как служба базы данных MySQL привязана к порту 3306 по умолчанию, так что когда сервер получает Когда пользователь запрашивает его, номер порта может использоваться, чтобы определить, запрашивал ли пользователь услугу, предоставляемую сервером HTTP или сервером базы данных. Диапазон значений порта составляет 0 ~ 65535, и порты ниже 1024 обычно называются «известными портами» (порты, зарезервированные для «известных служб», таких как FTP, HTTP, SMTP и т. Д., А в некоторых местах они также называются «известными портами») известные порты ". Известные порты"), пользовательские службы обычно не используют эти порты, если только пользовательские службы не являются широко известными службами, такими как HTTP или FTP.

Следующий код реализует сервер, который предоставляет время и дату.

```Python
"""
Python 3.10 временной-сервер
Название файла '02.временной-сервер.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""

from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime


def main():
    # 1. Создайте объект сокета и укажите, какой транспортный сервис использовать.
    # family=AF_INET - IPv4 адрес
    # family=AF_INET6 - IPv6 адрес
    # type=SOCK_STREAM - TCP сокет
    # type=SOCK_DGRAM - UDP сокет
    # type=SOCK_RAW - raw сокет
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.Привязать IP-адрес и порт (чтобы различать разные сервисы)
    server.bind(('192.168.0.102', 5566))  # обязательно укажите свой локальный IP-адрес
    # 3.Включите мониторинг-прослушивание клиентских подключений к серверу.
    server.listen(512)
    print('Сервер запускается и начинает слушать...')
    # 4.Получение соединения клиента по шлейфу и выполнение соответствующей обработки (предоставление услуг)
    while True:
        # Метод accept - это метод блокировки, если к серверу не подключен клиент
        # Этот метод заблокирует код и не будет выполняться вниз
        # метод accept возвращает первый элемент кортежа - это клиентский объект
        # Второй элемент - это адрес клиента (состоит из двух частей: IP и порт)
        client, addr = server.accept()
        print(str(addr) + 'Подключено к серверу.')
        # 5.Отправить данные
        client.send(str(datetime.now()).encode('utf-8'))
        # 6.Отключитесь
        client.close()


if __name__ == '__main__':
    main()
```

Конечно, мы также можем реализовать функцию TCP-клиента через программу Python. По сравнению с программой-сервером, 
программа-клиент намного проще. Код показан ниже.


```Python
"""
Python 3.10 временной-клиент
Название файла '03.временной-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
from socket import socket


def main():
    client = socket()
    client.connect(('192.168.0.102', 5566))  # указываем IP адрес и порт временного сервера
    print(client.recv(1024).decode('utf-8'))
    client.close()


if __name__ == '__main__':
    main()

```

Следует отметить, что указанный выше сервер не использует многопоточность или асинхронную обработку ввода-вывода, 
что означает, что, когда сервер взаимодействует с одним клиентом, другие клиенты могут только ждать в очереди. 
Очевидно, что такой сервер не может удовлетворить наши потребности: необходимый нам сервер способен одновременно 
принимать и обрабатывать несколько пользовательских запросов. Давайте спроектируем файловый сервер, который использует 
технологию многопоточности для обработки нескольких пользовательских запросов.Сервер будет отправлять изображение 
клиенту, подключенному к серверу.
Серверный код:

```Python
"""
Python 3.10 файловый-сервер
Название файла '04.файловый-сервер.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
from socket import socket, SOCK_STREAM, AF_INET
from base64 import b64encode
from json import dumps
from threading import Thread


def main():
   # Пользовательский класс потока
   class FileTransferHandler(Thread):

      def __init__(self, cclient):
         super().__init__()
         self.cclient = cclient

      def run(self):
         my_dict = {}
         my_dict['filename'] = 'Screenshot-1.png'
         # JSON - это простой текст и не может переносить двоичные данные
         # Таким образом, двоичные данные изображения должны быть обработаны в кодировке base64
         my_dict['filedata'] = data
         # Преобразование словаря в строку JSON с помощью функции дампа
         json_str = dumps(my_dict)
         # Отправить строку JSON
         self.cclient.send(json_str.encode('utf-8'))
         self.cclient.close()

   # 1. Создайте объект сокета и укажите, какой транспортный сервис использовать.
   server = socket()
   # 2. Привязать IP-адрес и порт (чтобы различать разные сервисы)
   server.bind(('192.168.0.102', 5566))
   # 3. Включите мониторинг-прослушивание клиентских подключений к серверу.
   server.listen(512)
   print('Сервер запускается и начинает слушать .....')
   with open('Screenshot-1.png', 'rb') as f:
      # Обработать двоичные данные в base64 и затем декодировать их в строку
      data = b64encode(f.read()).decode('utf-8')
   while True:
      client, addr = server.accept()
      # Используйте словарь (пара ключ-значение) для сохранения различных данных для отправки
      # Позже словарь может быть преобразован в формат JSON и передан по сети
      FileTransferHandler(client).start()


if __name__ == '__main__':
   main()

```

Код клиента:

```Python
"""
Python 3.10 файловый-клиент
Название файла '05.файловый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
from socket import socket
from json import loads
from base64 import b64decode


def main():
    client = socket()
    client.connect(('192.168.0.102', 5566))
    # Определить объект, который сохраняет двоичные данные
    in_data = bytes()
    # Поскольку я не знаю, насколько велики данные, отправляемые сервером, я получаю 1024 байта каждый раз
    data = client.recv(1024)
    while data:
        # Объединить полученные данные
        in_data += data
        data = client.recv(1024)
        # Декодировать полученные двоичные данные в строку JSON и преобразовать в словарь
        # Функция  # load - преобразовать строки JSON в объекты словаря.
    my_dict = loads(in_data.decode('utf-8'))
    filename = my_dict['filename']
    filedata = my_dict['filedata'].encode('utf-8')
    with open('/Users/admin/' + filename, 'wb') as f:
        # Декодировать данные формата base64 в двоичные данные и записывать их в файл
        f.write(b64decode(filedata))
    print('Картинка сохранена.')


if __name__ == '__main__':
    main()
```

В этом случае мы использовали JSON в качестве формата передачи данных (передаваемые данные сериализуются и 
десериализуются через формат JSON), но JSON не может нести двоичные данные, поэтому двоичные данные изображения 
обрабатываются в кодировке Base64. Base64 - это метод кодирования, который использует 64 символа для представления 
всех двоичных данных. Реорганизуя двоичные данные в группы по 6 бит, вы можете просто использовать цифры 0–9, буквы 
верхнего и нижнего регистра, а также "+" и "/" A всего 64 символа представляют 64 состояния от 000000 до 111111. В 
Википедии есть подробное объяснение кодировки Base64, и читатели, не знакомые с Base64, могут прочитать его сами.

> Примечание. Приведенный выше код предназначен в основном для объяснения связанного содержания сетевого 
> программирования, поэтому он не имеет отношения к ненормальным условиям. Читателям предлагается добавить код 
> обработки исключений, чтобы повысить надежность программы.

#### UDP-сокет

В дополнение к надежному протоколу передачи TCP, транспортный уровень также имеет очень легкий протокол передачи, 
называемый протоколом дейтаграмм пользователя, или сокращенно UDP. И TCP, и UDP - это протоколы, которые 
предоставляют услуги сквозной передачи. Разница между ними такая же, как между вызовом и отправкой текстового 
сообщения. Последнее не дает никаких обещаний относительно надежности и доступности передача, что позволяет 
избежать квитирования по TCP. Но увы не предусматривает повторную передачу, поэтому в сценариях, которые 
делают упор на производительность, а не на целостность данных (например, передача сетевых аудио- и видеоданных), 
UDP может быть лучшим выбором. Вы можете заметить что при просмотре онлайн-видео иногда будут 
зависания, а иногда будут размытые экраны. Это не что иное, как часть передачи данных или неправильная передача. Вы 
также можете использовать сокеты UDP для создания сетевых приложений на Python, мы не будем вдаваться в подробности 
об этом, и заинтересованные читатели могут изучить их самостоятельно.
UDP-сервер:
```python
"""
Python 3.10 Сервер Socket-Echo на основе протокола UDP
Название файла '08.сервер_udp.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
from socket import *


server = socket(AF_INET, SOCK_DGRAM)
server.bind(('localhost', 6789))
while True:
    data, addr = server.recvfrom(1024)
    server.sendto(data, addr)
server.close()

```
UDP-клиент:
```python
"""
Python 3.10 Socket-Create Echo клиент на основе протокола UDP
Название файла '09.клиент_udp.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""

from socket import *

client = socket(AF_INET, SOCK_DGRAM)
while True:
    data_str = input('Пожалуйста, введите: ')
    client.sendto(data_str.encode('utf-8'), ('localhost', 6789))
    data, addr = client.recvfrom(1024)
    data_str = data.decode('utf-8')
    print('Ответ сервера:', data_str)
    if data_str == 'bye':
        break
client.close()
```

### Разработка веб-приложений

### Отправить электронное письмо 
Сегодня с развитием программного обеспечения для обмена мгновенными сообщениями электронная почта по-прежнему 
остается одним из наиболее широко используемых приложений в Интернете. Компания отправляет заявителю уведомление 
о приеме на работу, веб-сайт отправляет пользователю ссылку для активации учетной записи, а банк продвигает свои 
финансовые продукты среди клиентов и т. д. Практически все это делается по электронной почте, и эти задачи 
должны выполняться программой автоматически.

Подобно тому, как мы можем использовать HTTP (протокол передачи гипертекста) для посещения веб-сайтов, мы 
можем отправлять письма для использования SMTP (простой протокол передачи почты). SMTP также основан на надежной 
службе передачи данных, предоставляемой TCP (протокол управления передачей). протокол, который определяет детали 
того, как отправитель почты взаимодействует с почтовым сервером, а модуль smtplib в Python упрощает эти операции до 
нескольких простых функций.

Следующий код демонстрирует, как отправлять почту в Python.

```Python
"""
Python 3.10 почтовый-клиент SMTP-протокол
Название файла '14.почтовый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""
from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def main():
    message = MIMEMultipart()
    text_content = MIMEText('текст сообщения', 'plain', 'utf-8')
    message['Subject'] = Header('Здравствуте!', 'utf-8')
    message.attach(text_content)

    with open('/Users/admin/Desktop/hello.txt', 'rb') as f:
        txt = MIMEText(f.read(), 'base64', 'utf-8')
        txt['Content-Type'] = 'text/plain'
        txt['Content-Disposition'] = 'attachment; filename=hello.txt'
        message.attach(txt)
    with open('/Users/admin/Desktop/hi.xlsx', 'rb') as f:
        xls = MIMEText(f.read(), 'base64', 'utf-8')
        xls['Content-Type'] = 'application/vnd.ms-excel'
        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'
        message.attach(xls)

    smtper = SMTP('smtp.222.com')
    # smtper.starttls()
    sender = 'abcdefg@222.com'
    receivers = ['uvwxyz@qq.com']
    smtper.login(sender, 'secretpass')
    smtper.sendmail(sender, receivers, message.as_string())
    smtper.quit()
    print('почта отправлена!')


if __name__ == '__main__':
    main()

```

Если вы хотите отправить электронное письмо с вложениями, вы можете выполнить следующие действия.

```Python
"""
Python 3.10 почтовый-сервер SMTP-протокол
Название файла '14.почтовый-клиент.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-04-15
"""

from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def main():
    message = MIMEMultipart()
    text_content = MIMEText('текст сообщения', 'plain', 'utf-8')
    message['Subject'] = Header('Здравствуте!', 'utf-8')
    message.attach(text_content)

    with open('/Users/admin/Desktop/hello.txt', 'rb') as f:
        txt = MIMEText(f.read(), 'base64', 'utf-8')
        txt['Content-Type'] = 'text/plain'
        txt['Content-Disposition'] = 'attachment; filename=hello.txt'
        message.attach(txt)
    with open('/Users/admin/Desktop/hi.xlsx', 'rb') as f:
        xls = MIMEText(f.read(), 'base64', 'utf-8')
        xls['Content-Type'] = 'application/vnd.ms-excel'
        xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx'
        message.attach(xls)

    smtper = SMTP('smtp.222.com')
    # smtper.starttls()
    sender = 'abcdefg@222.com'
    receivers = ['uvwxyz@qq.com']
    smtper.login(sender, 'secretpass')
    smtper.sendmail(sender, receivers, message.as_string())
    smtper.quit()
    print('почта отправлена!')


if __name__ == '__main__':
    main()

```
Примеры:
- 01.Многопоточное_скачивание.py
- 02.временной-сервер.py
- 03.временной-клиент.py
- 04.файловый-сервер.py
- 05.файловый-клиент.py
- 06.сервер_времени_tcp.py
- 07.клиент_времени_tcp.py
- 08.сервер_udp.py
- 09.клиент_udp.py
- 10.сервер_времени_tcp.py
- 11.чат-сервер.py
- 12.чат-клиент.py
- 13.почтовый-сервер.py
- 14.почтовый-клиент.py

[Вернуться на главную](https://github.com/BEPb/Python-100-days)


[К следующему занятию](https://github.com/BEPb/Python-100-days/tree/master/%D0%94%D0%B5%D0%BD%D1%8C%2001-15/%D0%94%D0%B5%D0%BD%D1%8C%2015/README.md)
