## Продвинутый язык Python 

### Общая структура данных (день 16)

Расширенная структура данных в Python (англ. Advanced Data Structures) является набором из нескольких классов и 
коллекций, предоставляющих различные способы хранения и обработки данных.  

Некоторые из расширенных структур данных в Python включают в себя:

1. Кортежи (англ. Tuples) — упорядоченная неизменяемая коллекция элементов, которые могут быть различных типов. Кортеж 
   ограничен круглыми скобками () и может содержать любое количество элементов, разделенных запятыми. 
2. Множества (англ. Sets) — неупорядоченная коллекция уникальных элементов. Множество ограничено фигурными скобками {} и 
   может содержать любое количество элементов, разделенных запятыми. 
3. Словари (англ. Dictionaries) — неупорядоченная коллекция пар ключ-значение, где каждый ключ уникален. Ключи и значения 
   могут быть любого типа данных. Словарь ограничен фигурными скобками {}. 
4. Очереди (англ. Queues) - это структура данных, которая представляет собой объект, подобный списку, но доступ к 
   элементам возможен только с двух концов: с начала очереди и с ее конца
5. Стэки (англ. Stacks) - является коллекцией элементов, которые могут быть добавлены и удалены только с одной 
   стороны - с вершины стека. Данные в стеке хранятся по принципу "последним пришел, первым ушел" (LIFO - last in, 
   first out)
6. Списки с быстрым доступом (англ. Lists with Fast Access)

В зависимости от нужд приложения, выбираются подходящие структуры данных. Например, для быстрого поиска элементов 
лучше использовать словари, а для работы с упорядоченными элементами — кортежи или списки.  

В Python также существуют сторонние пакеты, расширяющие функциональность базовых структур данных, например, NumPy 
для работы с многомерными массивами и pandas для работы с табличными данными. 



#### Очередь
Структура данных очередь в Python имеет несколько реализаций, но основной класс для работы с ней - `queue.Queue()`. 
Он поддерживает следующие методы: 

- `put(item)`: добавляет элемент в конец очереди
- `get()`: удаляет и возвращает элемент из начала очереди
- `empty()`: возвращает `True`, если очередь пуста
- `qsize()`: возвращает текущую длину очереди

Класс `queue.Queue()` реализует очередь с блокировкой, что позволяет избежать гонки за ресурсы, когда несколько 
потоков пытаются одновременно добавить или удалить элементы из очереди. Кроме этого, существуют и другие реализации 
очереди, например, `queue.LifoQueue()`, которая реализует стек на основе очереди.  

Очередь в Python - это структура данных, которая представляет собой объект, подобный списку, но со следующими 
отличительными особенностями: 
- Доступ к элементам возможен только с двух концов: с начала очереди и с ее конца
- Первым в очереди становится элемент, добавленный первым (FIFO - "first in, first out")
- Добавление элемента в очередь происходит с помощью метода put(), удаление - с помощью метода get()
- Если очередь пуста, то вызов метода get() заблокируется, пока в очереди не появится элемент.

Класс Queue из стандартной библиотеки Python предоставляет реализацию очереди, а его потомки - различные модификации 
этой структуры. Для примера, класс LifoQueue реализует стек (LIFO - "last in, first out"), а класс PriorityQueue - 
очередь с приоритетами.  


#### Стек

Стек (stack) - это одна из основных структур данных, которая используется в программировании. Стек является 
коллекцией элементов, которые могут быть добавлены и удалены только с одной стороны - с вершины стека. Данные в 
стеке хранятся по принципу "последним пришел, первым ушел" (LIFO - last in, first out).  

В Python стек обычно реализуется с помощью списка (list), который позволяет добавлять или удалять элементы с конца 
списка.  

Например, чтобы создать новый пустой стек, можно использовать следующий код:

```python
stack = []
```

Чтобы добавить элементы в стек, можно использовать метод `append()`:

```python
stack.append(1)
stack.append(2)
stack.append(3)
```

Чтобы удалить элемент из стека, можно использовать метод `pop()`, который удаляет и возвращает последний элемент списка:

```python
last_element = stack.pop()
```

В результате выполнения этих команд переменная `last_element` будет содержать значение 3, а в стеке останется только 
два элемента - 1 и 2. 


### Использование генеративного (производного) создания

Генеративное создание в Python - это способ создания последовательностей, списков или других объектов в Python, 
используя выражения-генераторы вместо циклов. Вместо того, чтобы явно создавать список или последовательность 
объектов, генератор выражения позволяют определить объекты, которые будут сгенерированы автоматически при выполнении 
генератора. В результате, генераторы позволяют создавать объекты напрямую и эффективно. Генераторы также могут 
использоваться для создания бесконечных потоков объектов, которые могут быть использованы для различных задач, таких 
как обработка данных, генерация отчетов или создание уникальных идентификаторов.

Пример генеративного (производного) создания - создание списка квадратов всех четных чисел от 1 до 10:

```python
squares = (x*x for x in range(1, 11) if x%2==0)
print(list(squares))
```

Output:
```
[4, 16, 36, 64, 100]
```

В этом примере мы используем генератор (generator comprehension) для создания списка квадратов всех четных чисел в 
диапазоне от 1 до 10. Функция range() создает последовательность чисел от 1 до 10, а условие if x%2==0 фильтрует 
только четные числа. Затем мы используем оператор `**` для создания квадрата каждого четного числа. В результате 
получаем объект-генератор (generator object), который мы преобразуем в список с помощью функции list().   

```Python
# создадим словарь в котором ключ - имя компании, а значение - цена акции
prices = {  
    'AAPL': 191.88,
    'GOOG': 1186.96,
    'IBM': 149.24,
    'ORCL': 48.44,
    'ACN': 166.89,
    'FB': 208.09,
    'SYMC': 21.29
}
# а теперь на основе словаря prices создадим новый словарь в котором останутся только компании с ценой акций больше, 
# чем $ 100  
prices2 = {key: value for key, value in prices.items() if value > 100}
print(prices2)
```

  > Генеративное создание (производное) может использоваться для создания списков, наборов и словарей.


### Вложенный список

В Python можно создать вложенный список, который является списком внутри списка. 
Например:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# Этот список состоит из трех вложенных списков, которые содержат числа от 1 до 9. 

# Для доступа к элементам вложенного списка можно использовать индексы. Например, чтобы получить число 5:
print(my_list[1][1])
```

Здесь первый индекс `[1]` указывает на второй вложенный список, а второй индекс `[1]` указывает на второй элемент 
этого списка. 

Конструкция вложенного списка в Python позволяет создавать списки, элементы которых сами могут быть списками, и тем 
самым представлять данные в виде многомерных массивов. Пример вложенного списка: 

```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Вывести первый элемент второго списка
print(nested_list[1][0])

# Вывести элементы каждого списка в отдельной строке
for lst in nested_list:
    for item in lst:
        print(item, end=' ')
    print()
```

Исходный список `nested_list` содержит три подсписка. Каждый из подсписков содержит три элемента. Для обращения к 
элементам списка используется оператор `[ ]`. В данном примере мы выводим первый элемент второго списка (`nested_list
[1][0]`) и элементы каждого списка в отдельных строках (`for` цикл внутри другого `for` цикла).  



### Модуль `heapq` (сортировка по куче)

Куча (англ. Heap) – это структура данных, которая представляет из себя бинарное дерево. Куча является структурой 
данных "на вершину", то есть наибольший элемент хранится в корне дерева, а меньшие элементы располагаются ниже.  

В Python куча может быть реализована с помощью модуля heapq. 

Пример:
```python
import heapq

# Создание пустой кучи
heap = []

# Добавление элементов в кучу
heapq.heappush(heap, 5)
heapq.heappush(heap, 1)
heapq.heappush(heap, 10)

# Извлечение минимального элемента из кучи
print(heapq.heappop(heap)) # 1
```


Вот пример сортировки по куче (heap sort) на Python:

```python
# Функция для сортировки по куче
def heap_sort(arr):
    n = len(arr)

    # Построение максимальной кучи
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извлечение элементов из кучи
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Функция для поддержания свойств кучи
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] > arr[largest]:
        largest = l

    if r < n and arr[r] > arr[largest]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# Пример использования
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("Отсортированный массив:")
print(arr)
```

Этот код использует две функции: `heap_sort` и `heapify`. `heap_sort` создает максимальную кучу из заданного массива 
и извлекает элементы из кучи для сортировки. `heapify` поддерживает свойства кучи, проверяя, является ли текущий 
узел максимальным и, если это не так, меняет местами узлы для поддержания свойств кучи.  

Выходные данные:
```
Отсортированный массив:
[5, 6, 7, 11, 12, 13]
```


Модуль heapq в несколько раз облегчает написание программ, использующих такую структуру данных как куча. Этот модуль 
обеспечивает реализацию алгоритма очереди с кучами, также известный как алгоритм очереди с приоритетами.
 Для создания типа данных используется пустой список.

Все функции записывают изменения в ту переменную, которая передавалась параметру heap.

```Python
"""
сортировка по куче
"""
import heapq

list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]
list2 = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
print(heapq.nlargest(3, list1))  # Возвращает список с самыми большими 3 элементами от набора данных 
print(heapq.nsmallest(3, list1))  # Возвращает список с самыми наименьшими 3 элементами от набора данных 
print(heapq.nlargest(2, list2, key=lambda x: x['price']))  # Возвращает список с самыми большими 2 элементами от 
# набора данных по ключу 'price'
print(heapq.nlargest(2, list2, key=lambda x: x['shares']))  # Возвращает список с самыми большими 2 элементами от 
# набора данных по ключу 'shares'
  ```

### модуль `itertools` - сборник полезных итераторов.
  Для выполнения продвинутой генерации списка в языке Python используется подключаемая библиотека под названием 
 itertools. С ее помощью можно создавать наборы значений по определенным правилам. Методы, которые содержит эта 
  библиотека, позволяют генерировать списки с использованием улучшенных циклов. Например, с ее помощью можно легко 
  создавать комбинации различных значений, как символьных, так и числовых. Следующий код является простым примером 
  генерации списка с вызовом функции repeat.


Вот несколько примеров итераторов из модуля `itertools`:

1. `count()` - итератор, который генерирует бесконечную последовательность чисел, начиная с заданного числа и с 
   заданным шагом. 

```python
from itertools import count

for i in count(3, 2):
    if i > 10:
        break
    print(i)

# Вывод:
# 3
# 5
# 7
# 9
# 11
```

2. `cycle()` - итератор, который генерирует бесконечную повторяющуюся последовательность элементов из заданного 
   итерируемого объекта. 

```python
from itertools import cycle

colors = cycle(['red', 'green', 'blue'])
for i in range(6):
    print(next(colors))

# Вывод:
# red
# green
# blue
# red
# green
# blue
```

3. `accumulate()` - итератор, который генерирует последовательность накопления значений из заданного итерируемого объекта.

```python
from itertools import accumulate

numbers = [1, 2, 3, 4, 5]
accumulated = accumulate(numbers)
print(list(accumulated))

# Вывод:
# [1, 3, 6, 10, 15]
```

4. `chain()` - итератор, который объединяет несколько итерируемых объектов в один.

```python
from itertools import chain

colors = ['red', 'green', 'blue']
numbers = [1, 2, 3]
combined = list(chain(colors, numbers))
print(combined)

# Вывод:
# ['red', 'green', 'blue', 1, 2, 3]
```

5. `combinations()` - итератор, который генерирует последовательность комбинаций из итерируемого объекта.

```python
from itertools import combinations

letters = ['a', 'b', 'c']
combs = list(combinations(letters, 2))
print(combs)

# Вывод:
# [('a', 'b'), ('a', 'c'), ('b', 'c')]
```


  - itertools.permutations(iterable, r=None) - перестановки длиной r из iterable.
  - itertools.combinations(iterable, [r]) - комбинации длиной r из iterable без повторяющихся элементов.
  - itertools.product(*iterables, repeat=1) - аналог вложенных циклов.
  - itertools.cycle(iterable) - возвращает по одному значению из последовательности, повторенной бесконечное число раз.
  - itertools.repeat(elem, n=Inf) - повторяет elem n раз.
  - itertools.count(start=0, step=1) - бесконечная арифметическая прогрессия с первым членом start и шагом step.
  - itertools.accumulate(iterable) - аккумулирует суммы.
  - itertools.chain(*iterables) - возвращает по одному элементу из первого итератора, потом из второго, до тех пор, 
    пока итераторы не кончатся. 
  - itertools.combinations_with_replacement(iterable, r) - комбинации длиной r из iterable с повторяющимися элементами.
  - itertools.compress(data, selectors) - (d[0] if s[0]), (d[1] if s[1]), ...
  - itertools.filterfalse(func, iterable) - все элементы, для которых func возвращает ложь.
  - itertools.groupby(iterable, key=None) - группирует элементы по значению. Значение получается применением 
    функции key к элементу (если аргумент key не указан, то значением является сам элемент).

Это только небольшая часть итераторов, которые доступны в модуле `itertools` - их гораздо больше. Вы можете 
ознакомиться со всеми доступными итераторами и их описанием на странице документации: https://docs.python.
org/3/library/itertools.html.  

```Python
"""
сборник полезных итераторов
"""
import itertools

itertools.permutations('ABCD')  # перестановки из символов 'ABCD'
itertools.combinations('ABCDE', 3)  # комбинации длиной 3 из символов 'ABCDE' без повторяющихся элементов
itertools.product('ABCD', '123')  # аналог вложенных циклов
itertools.cycle(('A', 'B', 'C'))

```

### модуль `collections`
этот модуль предоставляет специализированные типы данных, на основе словарей, кортежей, множеств, списков.

  часто используемые классы инструментов:

  - collections.Counter - вид словаря, который позволяет нам считать количество неизменяемых объектов (в 
    большинстве случаев, строк).
  - elements() - возвращает список элементов в лексикографическом порядке.
  - subtract([iterable-or-mapping]) - вычитание
  - collections.defaultdict ничем не отличается от обычного словаря за исключением того, что по умолчанию всегда 
    вызывается функция, возвращающая значение
  - collections.OrderedDict - ещё один похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи. 
  - Методы:
    - popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False.
    - move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если last=False
  - collections.namedtuple позволяет создать тип данных, ведущий себя как кортеж, с тем дополнением, что каждому 
    элементу присваивается имя, по которому можно в дальнейшем получать доступ


Наиболее часто употребляемые шаблоны для работы с Counter:
- sum(c.values()) - общее количество.
- c.clear() - очистить счётчик.
- list(c) - список уникальных элементов.
- set(c) - преобразовать в множество.
- dict(c) - преобразовать в словарь.
- c.most_common()[:-n:-1] - n наименее часто встречающихся элементов.
- c += Counter() - удалить элементы, встречающиеся менее одного раза.
Counter также поддерживает сложение, вычитание, пересечение и объединение


collections.deque(iterable, [maxlen]) - создаёт очередь из итерируемого объекта с максимальной длиной maxlen. 
Очереди очень похожи на списки, за исключением того, что добавлять и удалять элементы можно либо справа, либо слева.

Методы, определённые в deque:
- append(x) - добавляет x в конец.
- appendleft(x) - добавляет x в начало.
- clear() - очищает очередь.
- count(x) - количество элементов, равных x.
- extend(iterable) - добавляет в конец все элементы iterable.
- extendleft(iterable) - добавляет в начало все элементы iterable (начиная с последнего элемента iterable).
- pop() - удаляет и возвращает последний элемент очереди.
- popleft() - удаляет и возвращает первый элемент очереди.
- remove(value) - удаляет первое вхождение value.
- reverse() - разворачивает очередь.
- rotate(n) - последовательно переносит n элементов из начала в конец (если n отрицательно, то с конца в начало).
 

Пример использования модуля `collections`:

```python
from collections import Counter

# создание объекта Counter для подсчета количества элементов
lst = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
count = Counter(lst)

# вывод результата подсчета
print(count)

# доступ к элементам и их количеству
print(count['apple'])
print(count['banana'])

# вывод наиболее часто встречающихся элементов
print(count.most_common(2))


# В результате выполнения кода вы получите следующий вывод:

# Counter({'apple': 3, 'banana': 2, 'orange': 1})
# 3
# 2
# [('apple', 3), ('banana', 2)]
```

В этом примере мы использовали класс `Counter` модуля `collections` для подсчета количества элементов в списке. 
Затем мы обратились к отдельным элементам и их количеству, а также вывели наиболее часто встречающиеся элементы в 
списке.  



### Алгоритм сортировки (выбор, всплытие и объединение) и алгоритм поиска (последовательность и деление пополам)

Алгоритмы сортировки в Python нужны для упорядочивания элементов в списке или массиве в соответствии с заданными 
критериями. Сортировка позволяет находить элементы быстрее и удобнее, а также улучшает производительность алгоритмов,
использующих отсортированные данные. Python предоставляет несколько встроенных алгоритмов сортировки, например, 
sorted() и sort(). Также можно использовать сторонние библиотеки для выполнения более сложных алгоритмов сортировки, 
таких как быстрая сортировка, сортировка слиянием и т.д.    

Встроенная функция `sorted()` позволяет отсортировать объекты в порядке возрастания. 

Также существует множество других алгоритмов сортировки, которые могут быть реализованы в Python:

1. Сортировка пузырьком (Bubble Sort)
```python
def bubble_sort(array):  # получаем на вход список элементов
    n = len(array)  # создадим переменную равную длинне списка
    for i in range(n):  # цикл равный длине списка
        for j in range(0, n-i-1):  # цикл каждый раз уменьшающийся с шагом верхнего цикла
            if array[j] > array[j+1]:  # сравнивает два соседних элемента списка
                array[j], array[j+1] = array[j+1], array[j]  # меняет их местами
    return array  # возвращает отсортированную таблицу

# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Отсортированный массив:")
for i in range(len(arr)):
    print("%d" %arr[i]),
```

Этот пример создает функцию `bubble_sort` для сортировки переданного в нее массива `arr`. Функция использует два 
цикла для обработки элементов в массиве и сравнивает каждую пару соседних элементов. Если элементы нуждаются в 
перестановке, они меняются местами. После того, как цикл завершается, массив считается отсортированным. Вызов `print
()` выводит отсортированный массив.   

  ```Python
  def bubble_sort(items, comp=lambda x, y: x > y):
      """пузырьковая сортировка"""
      items = items[:]
      for i in range(len(items) - 1):
          swapped = False
          for j in range(len(items) - 1 - i):
              if comp(items[j], items[j + 1]):
                  items[j], items[j + 1] = items[j + 1], items[j]
                  swapped = True
          if not swapped:
              break
      return items
  ```

  ```Python
  def bubble_sort(items, comp=lambda x, y: x > y):
      """Сортировка перемешивания (пузырьковая сортировка улучшена)"""
      items = items[:]
      for i in range(len(items) - 1):
          swapped = False
          for j in range(len(items) - 1 - i):
              if comp(items[j], items[j + 1]):
                  items[j], items[j + 1] = items[j + 1], items[j]
                  swapped = True
          if swapped:
              swapped = False
              for j in range(len(items) - 2 - i, i, -1):
                  if comp(items[j - 1], items[j]):
                      items[j], items[j - 1] = items[j - 1], items[j]
                      swapped = True
          if not swapped:
              break
      return items
  ```

2. Сортировка выбором (Selection Sort)
```python
def selection_sort(array):
    n = len(array)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if array[j] < array[min_idx]:
                min_idx = j
        array[i], array[min_idx] = array[min_idx], array[i]
    return array
```

3. Сортировка вставкой (Insertion Sort)
```python
def insertion_sort(array):
    n = len(array)
    for i in range(1, n):
        key = array[i]
        j = i-1
        while j >=0 and key < array[j] :
            array[j+1] = array[j]
            j -= 1
        array[j+1] = key
    return array
```

4. Быстрая сортировка (Quick Sort)
```python
def partition(arr, low, high):
    i = (low-1)
    pivot = arr[high]
    for j in range(low, high):
        if arr[j] < pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)

def quick_sort(arr, low, high):
    if len(arr) == 1:
        return arr
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi-1)
        quick_sort(arr, pi+1, high)
    return arr
```

5. Сортировка слиянием (Merge Sort)
```python
def merge_sort(array):
    if len(array) > 1:
        mid = len(array)//2
        L = array[:mid]
        R = array[mid:]
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                array[k] = L[i]
                i += 1
            else:
                array[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            array[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            array[k] = R[j]
            j += 1
            k += 1
    return array
```

Это лишь некоторые из алгоритмов сортировки, которые можно найти в Python. Выбор того, какой алгоритм использовать, 
зависит от конкретного случая и требований к скорости и эффективности. 

Примеры:
- example02.py
- example01.py
- test_example01.py
- test_example02.py


[Вернуться на главную](https://github.com/BEPb/Python-100-days)

[К следующему занятию](https://github.com/BEPb/Python-100-days/blob/master/%D0%94%D0%B5%D0%BD%D1%8C%2016-20/%D0%94%D0%B5%D0%BD%D1%8C%2016/README.md)
