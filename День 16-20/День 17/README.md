- Расширенное использование функций - «первоклассные граждане» / функции высшего порядка / лямбда-функции / области 
  видимости и замыкания / декораторы

### Расширенное использование функций (день 17)

В Python функции могут быть использованы для решения широкого спектра задач и проблем. Вот несколько расширенных 
сценариев использования функций: 

1. Рекурсивные функции - функции, которые вызывают сами себя. Это особенно полезно в алгоритмах, которые 
   подразумевают глубокую вложенность. 

2. Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их 
   как результат. Это особенно полезно для функционального программирования. 

3. Анонимные функции (лямбда-выражения) - это функции без имени, которые могут использоваться в качестве аргументов 
   в других функциях для создания кратких и компактных выражений. 

4. Генераторы - это функции, которые используются для создания итераторов в Python. Они позволяют создавать 
   последовательности значений по требованию, вместо того, чтобы создавать целую последовательность сразу. 

5. Декораторы - это функции, которые позволяют изменять поведение других функций. Декораторы могут использоваться 
   для добавления дополнительной функциональности функциям без изменения их кода. 

6. Модуль functools - это стандартный модуль Python, который содержит множество функций, которые могут 
   использоваться для дополнительной обработки и изменения поведения функций в Python. Здесь можно найти функции, 
   такие как functools.partial, которые позволяют создавать новые функции на основе существующих, и functools.
   lru_cache, который позволяет кэшировать результаты выполнения функции для повышения ее производительности.   





### как используются функции

- рассматривайте функцию как "гражданина первого класса"

  - функция может быть назначена переменной
  - функция может выступать в качестве аргумента функции
  - функция может служить возвращаемым значением функции

- использование функций более высокого порядка（`filter`、`map`）
```Python
items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))
items2 = [x ** 2 for x in range(1, 10) if x % 2]
```


- параметры местоположения, переменные параметры, параметры ключевых слов, параметры именованных ключевых слов

- метаинформация параметров (проблема удобочитаемости кода)

- использование анонимных и встроенных функций (функций)lambda

- проблемы с замыканиями и областью

    * Порядок LEGB переменных поиска Python (Local >>> Embedded >>> Global >>> Built-in)

    * globalи то, что ключевые слова делают nonlocal

    * global: объявляет или определяет глобальные переменные (либо непосредственно с помощью переменной существующей глобальной области, либо определяет переменную, помещенную в глобальную область).

    * nonlocal: объявляет переменную, использующую вложенную область (вложенная область должна существовать, в 
  противном случае она будет сообщена об ошибке).

- функция декоратора (с помощью декоратора и декоратора отмены)

пример: декоратор времени выполнения выходной функции.

  ```Python
  def record_time(func):
      """自定义装饰函数的装饰器"""
      
      @wraps(func)
      def wrapper(*args, **kwargs):
          start = time()
          result = func(*args, **kwargs)
          print(f'{func.__name__}: {time() - start}秒')
          return result
          
      return wrapper
  ```

  если декоратор не хочет быть связан с функцией, можно написать декоратор, который может быть параметризирован.print

  ```Python
  from functools import wraps
  from time import time
  
  
  def record(output):
      """可以参数化的装饰器"""
  	
  	def decorate(func):
  		
  		@wraps(func)
  		def wrapper(*args, **kwargs):
  			start = time()
  			result = func(*args, **kwargs)
  			output(func.__name__, time() - start)
  			return result
              
  		return wrapper
  	
  	return decorate
  ```

  ```Python
  from functools import wraps
  from time import time
  
  
  class Record():
      """通过定义类的方式定义装饰器"""
  
      def __init__(self, output):
          self.output = output
  
      def __call__(self, func):
  
          @wraps(func)
          def wrapper(*args, **kwargs):
              start = time()
              result = func(*args, **kwargs)
              self.output(func.__name__, time() - start)
              return result
  
          return wrapper
  ```

  > 

    описание: из-за добавления @wraps декоратора к функции с декоративной функцией можно отменить роль декоратора, получив функцию или класс, предшествующий украшению.func.__wrapped__

  пример: используйте декоратор для реализации одного шаблона.

  ```Python
  from functools import wraps
  
  
  def singleton(cls):
      """装饰类的装饰器"""
      instances = {}
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  
  
  @singleton
  class President:
      """总统(单例类)"""
      pass
  ```

  > совет: замыкание (closure) используется в приведенном выше коде, и я не знаю, понимаете ли вы это. существует еще одна небольшая проблема заключается в том, что приведенный выше код не реализует один случай потокобезопасности, что делать, если вы хотите реализовать один случай потоковой безопасности? 

одноэлементный декоратор для потокобезопасности.。

  ```Python
  from functools import wraps
  from threading import RLock
  
  
  def singleton(cls):
      """线程安全的单例装饰器"""
      instances = {}
      locker = RLock()
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              with locker:
                  if cls not in instances:
                      instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  ```

  > 

    совет: приведенный выше код использует контекстный синтаксис для операций блокировки, поскольку объект блокировки сам по себе является объектом диспетчера контекстов (методы поддержки и магии). в функции мы делаем проверку без блокировки, а затем проверку с блокировкой, которая лучше, чем проверка непосредственной блокировки, и если объект был создан, мы не должны быть заблокированы, а вернуться непосредственно к объекту.with__enter____exit__wrapper



