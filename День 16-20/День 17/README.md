
- Расширенное использование функций - «первоклассные граждане» / функции высшего порядка / лямбда-функции / области 
  видимости и замыкания / декораторы

### Расширенное использование функций (день 17)

В Python функции могут быть использованы для решения широкого спектра задач и проблем. Вот несколько расширенных 
сценариев использования функций: 

1. Рекурсивные функции - функции, которые вызывают сами себя. Это особенно полезно в алгоритмах, которые 
   подразумевают глубокую вложенность. 

2. Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их 
   как результат. Это особенно полезно для функционального программирования. 

3. Анонимные функции (лямбда-выражения) - это функции без имени, которые могут использоваться в качестве аргументов 
   в других функциях для создания кратких и компактных выражений. 

4. Генераторы - это функции, которые используются для создания итераторов в Python. Они позволяют создавать 
   последовательности значений по требованию, вместо того, чтобы создавать целую последовательность сразу. 

5. Декораторы - это функции, которые позволяют изменять поведение других функций. Декораторы могут использоваться 
   для добавления дополнительной функциональности функциям без изменения их кода. 

6. Модуль functools - это стандартный модуль Python, который содержит множество функций, которые могут 
   использоваться для дополнительной обработки и изменения поведения функций в Python. Здесь можно найти функции, 
   такие как functools.partial, которые позволяют создавать новые функции на основе существующих, и functools.
   lru_cache, который позволяет кэшировать результаты выполнения функции для повышения ее производительности.   

### Функция как "гражданин первого класса"

Python - объектно-ориентированный язык программирования, в котором функции - это "граждане первого класса". Это 
означает, что функции в Python имеют множество свойств классических объектов, таких как возможность передачи как 
параметров, возвращение в качестве результата, сохранение в переменных и передача другим функциям.  

Это является очень мощным инструментом, позволяющим создавать сложные программы и сокращать объем кода благодаря 
возможности переиспользования кода внутри программы. 

Ниже приведены некоторые примеры использования функций в Python:

1. Простая функция для вычисления квадрата числа:

```python
def square(x):
    return x*x

result = square(5)
print(result) # Выведет 25
```

2. Функция, принимающая список чисел и возвращающая сумму всех чисел в списке:

```python
def sum_numbers(numbers):
    sum = 0
    for num in numbers:
        sum += num
    return sum
    
result = sum_numbers([1, 2, 3, 4, 5])
print(result) # Выведет 15
```

3. Функция, использующая функцию в качестве параметра:

```python
"""
Python 3.10 расширенные возможности функции
Название файла '01.калькулятор.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-05-03
"""

def calculator(operation, x, y):
    if operation == "add":
        return x+y
    elif operation == "subtract":
        return x-y
    elif operation == "multiply":
        return x*y
    elif operation == "divide":
        return x/y

def square(x):
    return x*x

result = calculator("multiply", 5, 6)
print(result)  # Выведет 30 = 5*6
print(square(5))  # Выведет 25 = 5*5
print(calculator(square, 5, 5))  # None
print(calculator("divide", square(10), 5))  # 20.0 =((10*10)/5)
```

Функция «калькулятор» принимает одну из четырех операций и два числа в качестве параметров. Затем она использует 
переданную функцию в качестве операции и выполняет операцию между двумя числами. 

4. Анонимные функции:

```python
square = lambda x: x*x

result = square(5)
print(result) # Выведет 25
```

Анонимная функция - это функция без имени, которая может быть определена в одну строку кода. Они удобны, когда вам 
нужна небольшая функция, которую можно определить прямо на месте. В приведенном примере мы определяем функцию square,
которая возвращает квадрат переданного числа.  

В целом, использование функций как "граждан первого класса" в Python позволяет создавать более читабельный и 
переиспользуемый код. Их можно использовать для многих задач, таких как вычисление, обработка данных и многих других.  


### Высшие функции в Python

Высшие функции в Python - это функции, которые могут принимать одну или несколько функций в качестве аргументов 
и/или возвращать функции в качестве результата. Это очень мощная концепция, которую можно использовать для создания 
гибких и модульных программ.  

Приведу несколько примеров высших функций в Python с описанием:

1. map(function, iterable) - применяет функцию к каждому элементу итерируемого объекта (например, списка или кортежа)
   и возвращает новый итератор с результатами. Пример: 

```python
def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(square, numbers))
print(squared_numbers) # Output: [1, 4, 9, 16, 25]
```

2. filter(function, iterable) - возвращает новый итератор с элементами итерируемого объекта, для которых функция 
   возвращает истинное значение. Пример: 

```python
def is_odd(x):
    return x % 2 != 0

numbers = [1, 2, 3, 4, 5]
odd_numbers = list(filter(is_odd, numbers))
print(odd_numbers) # Output: [1, 3, 5]
```

3. reduce(function, iterable[, initializer]) - применяет функцию к элементам итерируемого объекта, частично сводя 
   его к одному значению. Пример: 

```python
from functools import reduce

def multiply(x, y):
    return x * y

numbers = [1, 2, 3, 4, 5]
product = reduce(multiply, numbers)
print(product) # Output: 120
```

4. lambda arguments: expression - используется для создания анонимных функций. Пример:

```python
square = lambda x: x ** 2
print(square(5)) # Output: 25
```

5. sorted(iterable, key=None, reverse=False) - сортирует элементы итерируемого объекта в порядке возрастания (или 
   убывания, если `reverse=True`) и возвращает новый отсортированный список. Ключ `key` определяет функцию, которая 
   будет использоваться для извлечения значения, по которому будет происходить сортировка. Пример:  

```python
names = ['Alice', 'Bob', 'Charlie', 'Dave']
sorted_names = sorted(names, key=len)
print(sorted_names) # Output: ['Bob', 'Dave', 'Alice', 'Charlie']
```

Это только несколько примеров высших функций в Python. Есть много других функций, которые могут быть использованы 
для задач, которые считаются более сложными, но эти пять функций должны дать вам представление о том, что высшие 
функции могут делать.  



### как используются функции

- рассматривайте функцию как "гражданина первого класса"

  - функция может быть назначена переменной
  - функция может выступать в качестве аргумента функции
  - функция может служить возвращаемым значением функции

- использование функций более высокого порядка（`filter`、`map`）
```Python
items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))
items2 = [x ** 2 for x in range(1, 10) if x % 2]
```


- параметры местоположения, переменные параметры, параметры ключевых слов, параметры именованных ключевых слов

- метаинформация параметров (проблема удобочитаемости кода)

- использование анонимных и встроенных функций (функций)lambda

- проблемы с замыканиями и областью

    * Порядок LEGB переменных поиска Python (Local >>> Embedded >>> Global >>> Built-in)

    * globalи то, что ключевые слова делают nonlocal

    * global: объявляет или определяет глобальные переменные (либо непосредственно с помощью переменной существующей глобальной области, либо определяет переменную, помещенную в глобальную область).

    * nonlocal: объявляет переменную, использующую вложенную область (вложенная область должна существовать, в 
  противном случае она будет сообщена об ошибке).

- функция декоратора (с помощью декоратора и декоратора отмены)

пример: декоратор времени выполнения выходной функции.

  ```Python
  def record_time(func):
      """自定义装饰函数的装饰器"""
      
      @wraps(func)
      def wrapper(*args, **kwargs):
          start = time()
          result = func(*args, **kwargs)
          print(f'{func.__name__}: {time() - start}秒')
          return result
          
      return wrapper
  ```

  если декоратор не хочет быть связан с функцией, можно написать декоратор, который может быть параметризирован.print

  ```Python
  from functools import wraps
  from time import time
  
  
  def record(output):
      """可以参数化的装饰器"""
  	
  	def decorate(func):
  		
  		@wraps(func)
  		def wrapper(*args, **kwargs):
  			start = time()
  			result = func(*args, **kwargs)
  			output(func.__name__, time() - start)
  			return result
              
  		return wrapper
  	
  	return decorate
  ```

  ```Python
  from functools import wraps
  from time import time
  
  
  class Record():
      """通过定义类的方式定义装饰器"""
  
      def __init__(self, output):
          self.output = output
  
      def __call__(self, func):
  
          @wraps(func)
          def wrapper(*args, **kwargs):
              start = time()
              result = func(*args, **kwargs)
              self.output(func.__name__, time() - start)
              return result
  
          return wrapper
  ```

  > 

    описание: из-за добавления @wraps декоратора к функции с декоративной функцией можно отменить роль декоратора, получив функцию или класс, предшествующий украшению.func.__wrapped__

  пример: используйте декоратор для реализации одного шаблона.

  ```Python
  from functools import wraps
  
  
  def singleton(cls):
      """装饰类的装饰器"""
      instances = {}
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  
  
  @singleton
  class President:
      """总统(单例类)"""
      pass
  ```

  > совет: замыкание (closure) используется в приведенном выше коде, и я не знаю, понимаете ли вы это. существует еще одна небольшая проблема заключается в том, что приведенный выше код не реализует один случай потокобезопасности, что делать, если вы хотите реализовать один случай потоковой безопасности? 

одноэлементный декоратор для потокобезопасности.。

  ```Python
  from functools import wraps
  from threading import RLock
  
  
  def singleton(cls):
      """线程安全的单例装饰器"""
      instances = {}
      locker = RLock()
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              with locker:
                  if cls not in instances:
                      instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  ```

  > 

    совет: приведенный выше код использует контекстный синтаксис для операций блокировки, поскольку объект блокировки сам по себе является объектом диспетчера контекстов (методы поддержки и магии). в функции мы делаем проверку без блокировки, а затем проверку с блокировкой, которая лучше, чем проверка непосредственной блокировки, и если объект был создан, мы не должны быть заблокированы, а вернуться непосредственно к объекту.with__enter____exit__wrapper



[Вернуться на главную](https://github.com/BEPb/Python-100-days)

[К следующему занятию](https://github.com/BEPb/Python-100-days/blob/master/%D0%94%D0%B5%D0%BD%D1%8C%2016-20/%D0%94%D0%B5%D0%BD%D1%8C%2016/README.md)


