- Параллельное и асинхронное программирование - многопоточный / многопроцессорный / асинхронный ввод-вывод / 
  асинхронный и ожидающий


### Параллельное и асинхронное программирование (день 20)

### Параллельное программирование

Существует три сценария параллельного программирования в Python: многопоточный, многопроцессный и асинхронный 
ввод-вывод. Преимущество параллельного программирования заключается в повышении эффективности выполнения программ и 
улучшении взаимодействия с пользователем;

В Python есть несколько способов параллельного программирования:

1. Модуль threading - позволяет создавать потоки выполнения и распределять задачи между ними. Однако из-за 
   особенностей реализации интерпретатора Python, потоки в этом модуле не являются идеально параллельными и могут 
   иметь ограничения в производительности.  

2. Модуль multiprocessing - позволяет создавать процессы выполнения, каждый из которых работает независимо от других.
   Каждый процесс имеет свою собственную память и выполняет свои задачи параллельно с другими процессами. Однако 
   из-за особенностей работы с процессами, передача данных между ними может быть затруднительной и требует 
   использования специальных техник.   

3. Модуль asyncio - позволяет использовать асинхронный подход к программированию, при котором задачи выполняются в 
   одном потоке, но процессор переключается между задачами в зависимости от их состояния. Этот подход может быть 
   полезен в задачах, связанных с сетевым вводом-выводом или с другими блокирующими операциями.  
 
Каждый из этих способов имеет свои достоинства и недостатки и может быть выбран в зависимости от конкретной задачи и 
условий ее выполнения. 

#### Многопоточность
Многопоточность в Python позволяет запускать несколько потоков выполнения кода в одном процессе. Это позволяет 
повысить производительность при выполнении задач, которые можно разделить на несколько параллельных подзадач. В 
Python для многопоточности обычно используется модуль threading.  

Вот пример создания и запуска потока в Python:

```python
import threading

def my_function():
    print("start")
    # здесь можно добавить любой код, который вы хотите выполнить в отдельном потоке
    print("end")

my_thread = threading.Thread(target=my_function)
my_thread.start()
```

В этом примере мы создали функцию my_function, которую мы хотим выполнить в отдельном потоке. Для создания потока мы 
передали функцию в качестве аргумента методу Thread, который создал новый поток. Затем вызвали метод start() у 
созданного объекта потока, чтобы запустить выполнение потока.  

Также важно помнить о возможных проблемах, связанных с многопоточностью, таких как гонки за ресурсы или блокировки 
потоков. Поэтому важно правильно реализовать многопоточность в коде и тестируе ее на предмет проблем.  

Пример:
```python
import glob
import os
import time

from threading import Thread
from PIL import Image


class ThumbnailThread(Thread):

    def __init__(self, infile):
        self.infile = infile
        super().__init__()

    def run(self):
        file, ext = os.path.splitext(self.infile)
        filename = file[file.rfind('/') + 1:]
        for size in (32, 64, 128):
            outfile = f'{filename}_{size}_{size}.png'
            image = Image.open(self.infile)
            image.thumbnail((size, size))
            image.save(outfile, format='PNG')


def main():
    start = time.time()
    threads = []
    for infile in glob.glob('images/*'):
        t = ThumbnailThread(infile)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()
    end = time.time()
    print(f'Время затраченное на выполнение: {end - start} секунд')



if __name__ == '__main__':
    main()
```

Эта программа создает миниатюры заданных изображений различных размеров. Она использует библиотеку PIL для обработки 
изображений и многопоточность для повышения производительности. 

Основная функция `main()` начинается с измерения времени начала выполнения (в переменную `start`), продолжается с 
инициализации списка потоков (`threads`) и последующим запуском новых потоков для каждого изображения в папке 
`images`. Каждый поток создается как экземпляр класса `ThumbnailThread`, который принимает путь к файлу изображения 
в качестве аргумента конструктора.   

Когда каждый поток запущен, он вызывает метод `run()`, который извлекает имя файла и его расширение, затем создает и 
сохраняет экземпляры миниатюр для каждого заданного размера. Их размер задается в цикле, который перебирает значения 
32, 64 и 128. Каждый раз, когда размер изменяется, создается новый файл с соответствующими размерами в его названии.  

После того, как все потоки завершили свою работу, функция `main()` измеряет время завершения выполнения (в 
переменную `end`) и выводит разницу между временем начала и конца выполнения программы в секундах. 

Эта программа позволяет обрабатывать несколько изображений одновременно, что делает процесс создания миниатюр 
гораздо более быстро и эффективным относительно последовательного преобразования. 

Еще пример, решающий точно такую же задачу, но через использование объекта пула потоков:
```python
import glob
import os
import time

from concurrent.futures import ThreadPoolExecutor
from PIL import Image


def gen_thumbnail(infile):
    file, ext = os.path.splitext(infile)
    filename = file[file.rfind('/') + 1:]
    for size in (32, 64, 128):
        outfile = f'{filename}_{size}_{size}.png'
        image = Image.open(infile)
        image.thumbnail((size, size))
        image.save(outfile, format='PNG')


def main():
    pool = ThreadPoolExecutor(max_workers=30)
    futures = []
    start = time.time()
    for infile in glob.glob('images/*'):
        # метод отправки - это неблокирующий метод
        # Даже если количество рабочих потоков было израсходовано, метод submit примет отправленную задачу
        future = pool.submit(gen_thumbnail, infile)
        futures.append(future)
    for future in futures:
        # Метод результата - это метод блокировки, если поток еще не завершен
        # Временно невозможно получить результат выполнения потока, код здесь будет заблокирован
        future.result()
    end = time.time()
    print(f'Время затраченное на выполнение: {end - start} секунд')
    # выключение также является неблокирующим методом, если отправленная задача была не завершена
    # Пул потоков - это завершение работы, которое не перестанет работать, и отправка задачи не будет выполнена и вызовет исключение
    pool.shutdown()


if __name__ == '__main__':
    main()

```
Данная программа создает уменьшенные копии изображений из папки "images" и сохраняет их в той же папке с добавлением 
размера в конце имени файла. Для этого используется модуль Pillow (PIL). 

Основная функция - gen_thumbnail(infile) - принимает путь к исходному файлу изображения и создает уменьшенные копии 
размером 32, 64 и 128 пикселей. Она используется в параллельном режиме благодаря использованию пула потоков 
(ThreadPoolExecutor) и методов submit() и result().  

Основная функция main() создает пул потоков (ThreadPoolExecutor) и запускает выполнение функции gen_thumbnail() на 
каждом файле изображения в папке "images". Для каждого отправленного задания сохраняется объект Future в списке 
futures.  

Затем программа ожидает завершения всех заданий, получая результаты выполнения через метод result() для каждого 
объекта Future в списке futures. 

После выполнения всех заданий программа завершается и выводит общее время выполнения.

Важно отметить, что методы submit() и result() являются неблокирующими. Это значит, что отправление задания в пул 
потоков происходит мгновенно, даже если все рабочие потоки уже заняты выполнением других заданий. Однако метод result
() блокирует выполнение, пока результат выполнения задания не будет получен. Таким образом, программа не будет 
завершена, пока все задания не будут выполнены.   


Ситуация, когда несколько потоков конкурируют за ресурсы.

```python
"""
Python 3.10 Это программа создает два потока (Thread), каждый из которых выводит на экран постоянно повторяющееся
сообщение "Ping" и "Pong" соответственно. Функция output() запускается в каждом потоке и принимает один аргумент -
сообщение, которое будет выводиться бесконечно посредством цикла while True.

Итак, программа выводит на экран бесконечно повторяющиеся сообщения "Ping" и "Pong", пока главный поток не завершит
свою работу и не выведет "bye!".
Название файла 'example03.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-05-13
"""
from threading import Thread
from time import sleep


def output(content):
    while True:
        print(content, end='')


def main():
    '''
    Главной функцией программы является main(), которая запускает два потока с помощью метода Thread() и передает им
    соответствующие аргументы.
    Каждый поток запускается в демоническом режиме (daemon=True), что означает, что если главный поток завершит работу
    (в данном случае через 5 секунд), то потоки-демоны будут автоматически прекращать свою работу и завершаться.

    После запуска потоков, главный поток засыпает на 5 секунд, а затем выводит на экран сообщение "bye!" и завершает свою работу.

    '''
    Thread(target=output, args=('Ping', ), daemon=True).start()
    Thread(target=output, args=('Pong', ), daemon=True).start()
    sleep(5)
    print('bye!')


if __name__ == '__main__':
    main()
```

#### Многопроцессинг

Многопроцессинг в Python позволяет запускать несколько процессов одновременно для выполнения различных задач.

Для создания процесса в Python используется модуль multiprocessing. Он позволяет создавать процессы, которые 
выполняются параллельно в разных потоках. 

Пример:

```python
import multiprocessing

def worker(num):
    """Функция, которая будет выполняться в процессе"""
    print('Процесс {0} запущен'.format(num))

if __name__ == '__main__':
    # Создание нескольких процессов
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        p.start()
```

Многопоточность и многопроцессинг являются двумя стандартными способами параллелизации выполнения задач в Python.

Многопоточность позволяет одному процессу эффективно использовать несколько потоков, каждый из которых может 
выполнять некоторую часть программы параллельно. Для этого Python использует глобальный интерпретаторный блокировщик 
(GIL), который ограничивает параллельное выполнение нескольких потоков в рамках одного процесса. В большинстве 
случаев многопоточность не позволяет использовать все ядра процессора, так как только один поток может выполняться в 
один момент времени в одном процессе.

Многопроцессинг, с другой стороны, позволяет создавать несколько процессов, каждый из которых может выполняться на 
своём ядре процессора. Python обеспечивает многопроцессинг через стандартную библиотеку multiprocessing. Каждый 
процесс имеет свою копию интерпретатора Python и может выполняться параллельно с другими процессами. При 
использовании многопроцессинга GIL не оказывает влияния на выполнение задачи, так как каждый процесс имеет свою 
копию интерпретатора Python.    

Разница между многопоточностью и многопроцессингом заключается в том, что многопоточность использует несколько 
потоков в одном процессе для параллельного выполнения, а многопроцессинг создает несколько процессов, каждый из 
которых имеет свой собственный интерпретатор Python и выполняется на своём ядре процессора.  

В многопроцессном приложении важно правильно управлять ресурсами и синхронизировать работу процессов для 
предотвращения возможных конфликтов. 

Многопоточность обычно применяется в задачах, где не требуется слишком много вычислительных ресурсов, но требуется 
обрабатывать большое количество данных. Многопроцессность же используется в задачах, где требуется максимальная 
производительность и использование всех доступных ресурсов компьютера.   


#### Асинхронное программирование

Асинхронное программирование в Python позволяет выполнять несколько задач одновременно без блокировки потока 
выполнения. Для этого используется библиотека asyncio (asynchronous I/O). 

Основным элементом в асинхронном программировании является корутина (coroutine). Корутины - это функции, которые 
могут остановить свое выполнение на определенном шаге, передав управление другой корутине, и затем продолжить свое 
выполнение с того же места, где остановилась.  

Например, рассмотрим следующий код:

```python
import asyncio

async def print_numbers():
    for i in range(10):
        print(i)
        await asyncio.sleep(1)

async def print_letters():
    for letter in "abcdefghij":
        print(letter)
        await asyncio.sleep(0.5)

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.gather(print_numbers(), print_letters()))
loop.close()
```

В данном примере мы создали две корутины: `print_numbers` и `print_letters`, каждая из которых выводит на экран 
числа и буквы соответственно. Функция `asyncio.gather` позволяет запустить несколько корутин одновременно. 

В данном случае мы используем функцию `asyncio.sleep`, которая приостанавливает выполнение корутины на указанное 
количество секунд. Таким образом, при выполнении данного кода на экран будут выводиться числа и буквы каждую секунду 
и полсекунды соответственно.  

Преимущества асинхронного программирования в Python включают большую производительность и эффективность работы 
сетевых приложений. 

- Асинхронная обработка: Выбор задач из очереди задач планировщика, выполняющей эти задачи в перекрестном режиме, не 
  гарантирует, что задачи будут выполняться в определенном порядке, поскольку порядок выполнения зависит от 
  готовности одной задачи в очереди уступить время обработки ЦП другой задаче. Асинхронные задачи обычно выполняются 
  с помощью многозадачной совместной работы, и из-за неопределенности в отношении времени и последовательности 
  выполнения необходимо получить результаты выполнения задачи с помощью обратного программирования или объектов. 
  
```Python
"""
Python 3.10
программа осуществляет асинхронный обход нескольких web-страниц, извлечение их заголовков и вывод их на экран.
Название файла 'example07.py'

Version: 0.1
Author: Andrej Marinchenko
Date: 2023-05-13
"""

import asyncio  # Модуль asyncio используется для организации асинхронных операций
import re  # модуль re - для использования регулярных выражений
import aiohttp  # модуль aiohttp - для отправки HTTP-запросов и получения ответов на них


async def fetch(session, url):
    '''
    функция fetch(session, url) используется для отправки запросов и возврата ответа в виде строки
    '''
    async with session.get(url, ssl=False) as resp:
        return await resp.text()


async def main():
    '''
    Основная функция main(), в которой создается объект клиентской сессии aiohttp.ClientSession() для
    использования в методе fetch().

    В цикле for происходит обращение к нескольким url-адресам, получение ответов, извлечение из них заголовков с помощью
    регулярного выражения и вывод на экран с помощью метода print().

    '''
    pattern = re.compile(r'\<title\>(?P<title>.*)\<\/title\>')
    urls = ('https://www.python.org/',
            'https://git-scm.com/',
            'https://www.ibm.com/',
            'https://www.apple.com/',
            'https://www.google.com/')
    async with aiohttp.ClientSession() as session:
        for url in urls:
            html = await fetch(session, url)
            print(pattern.search(html).group('title'))


if __name__ == '__main__':
    '''    
    После запуска главной функции main(), используя module функцию asyncio.get_event_loop(), создается экземпляр 
    асинхронного цикла event loop и запускается функция main() с использованием метода loop.run_until_complete(main()).  
    
    Цикл запускает асинхронную функцию и ожидает ее завершения, после чего закрывается с помощью метода loop.close(). 
    '''
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    # loop.close()
```

 
 В реальной разработке для повышения масштабируемости и параллели системы обычно существует как вертикальное 
 масштабирование (увеличение вычислительной мощности одного узла), так и горизонтальное масштабирование 
 (преобразование одного узла в несколько узлов).

Масштабируемая производительность системы Python зависит от ряда факторов, таких как:

1. Объем данных, с которым работает система
2. Качество и оптимизация кода
3. Количество и характеристики серверов, на которых запущена система
4. Использование асинхронности и конкурентности приложения

Для достижения масштабируемой производительности необходимо учитывать каждый из этих факторов и оптимизировать 
систему соответствующим образом. Например, использование более мощных серверов или распределенных систем может 
помочь улучшить производительность при обработке больших объемов данных. Также важно использовать современные 
инструменты, такие как асинхронные фреймворки, которые позволяют эффективно работать с несколькими задачами 
одновременно и уменьшают нагрузку на систему.    

Одним из ключевых инструментов, помогающих достичь масштабируемой производительности в Python, является 
использование расширений CPython, таких как NumPy и Pandas. Они предоставляют эффективные инструменты для обработки 
данных и вычислений, что может значительно улучшить производительность приложения.  

Примеры:
- example01.py
- example02.py
- example03.py
- example04.py
- example05.py
- example06.py
- example07.py


[Вернуться на главную](https://github.com/BEPb/Python-100-days)

[К следующему занятию](https://github.com/BEPb/Python-100-days/blob/master/%D0%94%D0%B5%D0%BD%D1%8C%2021-30/%D0%94%D0%B5%D0%BD%D1%8C%2021/README.md)
