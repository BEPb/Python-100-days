## Удовольствие от операционной системы Linux
### История операционной системы
Компьютерная система только с оборудованием и без программного обеспечения называется «голым железом». Нам сложно 
использовать «голое железо» для выполнения повседневных компьютерных задач (таких как хранение и вычисления), 
поэтому мы должны использовать специальное программное обеспечение для управления работой. оборудования. 
Программное обеспечение, наиболее близкое к компьютерному оборудованию, - это системное программное обеспечение, 
наиболее важным из которых является «операционная система». «Операционная система» - это набор программ, которые 
контролируют и управляют всеми аппаратными и программными ресурсами компьютера, реализуют распределение ресурсов и 
распределение задач и предоставляют пользователям системы и другому программному обеспечению интерфейсы и среды.

### Без операционной системы (ручное управление)
В эпоху, когда компьютер родился без операционной системы, люди сначала устанавливали программную бумажную ленту 
(или карту) на компьютер, затем запускали машину ввода для отправки программы на компьютер, а затем запускали 
программу для запуска через консольный переключатель. Когда программа выполняется, принтер выводит рассчитанные 
результаты, а пользователь выгружает и забирает бумажную ленту (или карту). Второй пользователь входит в машину и 
повторяет те же действия. В течение всего процесса пользователь монополизирует машину, а ЦП ожидает ручного 
управления, что приводит к чрезвычайно низкому использованию ресурсов.

### Пакетная система
Сначала запустите на компьютере контрольную программу. Под управлением супервизорной программы компьютер может 
автоматически обрабатывать одно или несколько пользовательских заданий в пакетном режиме. После выполнения пакета 
заданий степень контроля считывает задание с устройства ввода и сохраняет его на ленточном накопителе. Повторите 
задание в соответствии с вышеуказанными шагами. Программа контроля непрерывно обрабатывает каждое задание, 
реализует автоматическую передачу задания, сокращает время создания задания и ручного управления, а также улучшает 
коэффициент использования компьютерных ресурсов. Системы пакетной обработки можно разделить на однопроходные 
системы пакетной обработки, многопроходные системы пакетной обработки, онлайн-системы пакетной обработки и 
автономные системы пакетной обработки.

### Система разделения времени и система реального времени

Система с разделением времени делит время работы процессора на короткие отрезки времени и распределяет процессоры 
для каждого онлайн-задания по очереди в соответствии с отрезками времени. Если задание не может завершить 
вычисление в течение выделенного ему отрезка времени, задание временно прерывается, процессор передается для 
использования другому заданию, и оно продолжает выполняться, когда ожидает следующего раунда планирования. 
Поскольку компьютер работает быстро, задания выполняются и меняются быстро, и каждый пользователь чувствует, что он 
является исключительным владельцем компьютера. И каждый пользователь может подавать различные команды управления 
операциями в систему через свой собственный терминал и выполнять работу при достаточном взаимодействии человека с 
компьютером. Чтобы разрешить ситуацию, когда система с разделением времени не может своевременно реагировать на 
инструкции пользователя, появилась система реального времени, которая может завершить обработку событий в строгие 
временные рамки и своевременно реагировать на случайные внешние события.

#### Универсальная операционная система

1. 1960-е: Машины серии IBM System / 360 имеют унифицированную операционную систему OS / 360.

2. 1965: Bell Labs компании AT&T присоединилась к программе сотрудничества GE и MIT и приступила к разработке MULTICS.

3. 1969: Проект MULTICS провалился. Кен Томпсон проводил время дома. Чтобы играть в игру «Космическое путешествие», он 
использовал язык ассемблера для разработки Unics на PDP-7, который в то время был исключен.

Примечание: трудно представить, что такая замечательная система, как Unix, была разработана программистом, который 
 бездельничал дома (дело в том, что его жена вернулась в свою родную семью и взяла с собой детей) на устаревшем 
устройстве для игр.

4. 1970 ~ 1971: Кен Томпсон и Деннис Ричи переписали Unics на PDP-11 на языке B и переименовали его в Unix по 
предложению Брайана Кернигана.

5. С 1972 по 1973 год: Деннис Ритчи изобрел язык C, чтобы заменить менее переносимый язык B, и начал работу по 
   переписыванию Unix с языком C.

6. 1974: Unix выпустила свое знаменательное 5-е издание, которое почти полностью было реализовано на языке C.

7. 1979: Начиная с версии 7 Unix, AT&T выпустила новые условия использования, приватизируя Unix.

8. 1987: Чтобы объяснить детали работы операционной системы студентам в классе, профессор Эндрю С. Таненбаум решил 
разработать Unix-совместимую операционную систему без использования какого-либо исходного кода AT&T, чтобы избежать 
   споров об авторских правах. Система получила название Minix. 

9. 1991: Когда Линус Торвальдс учился в Университете Хельсинки, Финляндия, он попытался провести некоторую работу по 
   разработке Minix, но поскольку Minix использовался только как операционная система для учебных целей, эта 
   функция не была мощной, чтобы облегчить чтение. и запись в школьную группу новостей и почтовую систему. Для 
   загрузки файлов Линус написал драйвер диска и файловую систему, которые сформировали зародышевую форму ядра 
   системы Linux. 

### Обзор Linux

Linux - это операционная система общего назначения. Операционная система отвечает за такие задачи, как планирование 
задач, выделение памяти и обработка периферийного ввода-вывода. Операционная система обычно состоит из двух частей: 
ядра (основная программа, которая запускает другие программы и управляет аппаратными устройствами, такими как диски 
и принтеры) и системной программы (драйверы устройств, базовые библиотеки, оболочки, служебные программы и т. Д.).

Ядро Linux было разработано Финном Линусом Торвальдсом и выпущено в сентябре 1991 года. Как продукт эпохи Интернета, 
операционная система Linux - это бесплатная операционная система, разработанная многими разработчиками со всего 
мира (обратите внимание, что свобода и бесплатный - это не одно и то же, вы можете щелкнуть здесь, чтобы понять 
разницу между ними). 

### Преимущества системы Linux
1. Общая операционная система, не привязанная к конкретному оборудованию.
2. Написано на языке C, сильная портативность, с интерфейсом программирования ядра.
3. Поддерживает многопользовательскую и многозадачность, а также поддерживает безопасную иерархическую файловую систему.
4. Большое количество служебных программ, полные сетевые функции и мощная сопроводительная документация.
5. Надежная безопасность и хорошая стабильность более удобны для разработчиков.

### Версии выпуска системы Linux

1. [Redhat](https://www.redhat.com/en)
2. [Ubuntu](https://www.ubuntu.com/)
3. [CentOS](https://www.centos.org/)
4. [Fedora](https://getfedora.org/)
5. [Debian](https://www.debian.org/)
6. [openSUSE](https://www.opensuse.org/)

### Основные команды

Системные команды Linux обычно имеют следующий формат:

```Shell
Имя команды [именованный параметр] [объект команды]
```

1. Получить информацию для входа в систему - **w** / **who** / **last**/ **lastb**。

   ```Shell
   [root ~]# w
    23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05
   USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
   root     pts/0    182.139.66.250   23:03    4.00s  0.02s  0.00s w
   jackfrue pts/1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash
   [root ~]# who
   root     pts/0        2018-04-12 23:03 (182.139.66.250)
   jackfrued pts/1        2018-04-12 23:26 (182.139.66.250)
   [root ~]# who am i
   root     pts/0        2018-04-12 23:03 (182.139.66.250)
   [root ~]# who mom likes
   root     pts/0        2018-04-12 23:03 (182.139.66.250)
   [root ~]# last
   root     pts/0        117.136.63.184   Sun May 26 18:57   still logged in   
   reboot   system boot  3.10.0-957.10.1. Mon May 27 02:52 - 19:10  (-7:-42)   
   root     pts/4        117.136.63.184   Sun May 26 18:51 - crash  (08:01)    
   root     pts/4        117.136.63.184   Sun May 26 18:49 - 18:49  (00:00)    
   root     pts/3        117.136.63.183   Sun May 26 18:35 - crash  (08:17)    
   root     pts/2        117.136.63.183   Sun May 26 18:34 - crash  (08:17)    
   root     pts/0        117.136.63.183   Sun May 26 18:10 - crash  (08:42)    
   ```

2. Проверьте оболочку Shell - **ps**。

    Оболочку Shell также называют «программой оболочки». Это переводчик для взаимодействия 
   пользователя с ядром операционной системы. Проще говоря, это интерфейс и интерфейс между людьми и компьютерами. 
   В настоящее время оболочкой по умолчанию для многих систем Linux является bash (Bourne Again SHell), потому что 
   он может использовать клавишу табуляции для завершения команд и путей, сохранения исторических команд, простой 
   настройки переменных среды и выполнения пакетных операций. 
   ```Shell
   [root ~]# ps
     PID TTY          TIME CMD
    3531 pts/0    00:00:00 bash
    3553 pts/0    00:00:00 ps
   ```

3. Просмотрите описание и расположение команды - **whatis** / **which** / **whereis**。

   ```Shell
   [root ~]# whatis ps
   ps (1)        - report a snapshot of the current processes.
   [root ~]# whatis python
   python (1)    - an interpreted, interactive, object-oriented programming language
   [root ~]# whereis ps
   ps: /usr/bin/ps /usr/share/man/man1/ps.1.gz
   [root ~]# whereis python
   python: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz
   [root ~]# which ps
   /usr/bin/ps
   [root ~]# which python
   /usr/bin/python
   ```

4. Очистить содержимое, отображаемое на экране - **clear**。

5. Просмотрите справочную документацию - **man** / **info** / **--help** / **apropos**。
   ```Shell
   [root@izwz97tbgo9lkabnat2lo8z ~]# ps --help
   Usage:
    ps [options]
    Try 'ps --help <simple|list|output|threads|misc|all>'
     or 'ps --help <s|l|o|t|m|a>'
    for additional help text.
   For more details see ps(1).
   [root@izwz97tbgo9lkabnat2lo8z ~]# man ps
   PS(1)                                User Commands                                PS(1)
   NAME
          ps - report a snapshot of the current processes.
   SYNOPSIS
          ps [options]
   DESCRIPTION
   ...
   ```

6. Просмотрите систему и имя хоста - **uname** / **hostname**。

   ```Shell
   [root@izwz97tbgo9lkabnat2lo8z ~]# uname
   Linux
   [root@izwz97tbgo9lkabnat2lo8z ~]# hostname
   izwz97tbgo9lkabnat2lo8z
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release
   CentOS Linux release 7.6.1810 (Core)
   ```

   > Описание: cat это команда для подключения содержимого файла и вывода его на стандартный вывод. Эта команда будет 
   > /etc обсуждаться позже; это очень важный каталог в системе Linux, который сохраняет множество файлов 
   > конфигурации; это centos-release файл в этот каталог, потому что I Я использую дистрибутив Linux CentOS 7.6, 
   > поэтому здесь будет такой файл.б 
7. Время и дата - **date** / **cal**。

   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# date
   Wed Jun 20 12:53:19 CST 2018
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# cal
         June 2018
   Su Mo Tu We Th Fr Sa
                   1  2
    3  4  5  6  7  8  9
   10 11 12 13 14 15 16
   17 18 19 20 21 22 23
   24 25 26 27 28 29 30
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017
         May 2017
   Su Mo Tu We Th Fr Sa
       1  2  3  4  5  6
    7  8  9 10 11 12 13
   14 15 16 17 18 19 20
   21 22 23 24 25 26 27
   28 29 30 31
   ```

8. Перезагрузка и выключение - **reboot** / **shutdown**。

   ```Shell
   [root ~]# shutdown -h +5
   Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use 'shutdown -c' to cancel.
   [root ~]# 
   Broadcast message from root (Sun 2019-05-26 19:29:27 CST):
   
   The system is going down for power-off at Sun 2019-05-26 19:34:27 CST!
   [root ~]# shutdown -c
   
   Broadcast message from root (Sun 2019-05-26 19:30:22 CST):
   
   The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST!
   [root ~]# shutdown -r 23:58
   Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use 'shutdown -c' to cancel.
   [root ~]# shutdown -c
   
   Broadcast message from root (Sun 2019-05-26 19:31:06 CST):
   
   The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!
   ```

   > Примечание: При выполнении shutdown команды пользователю, который входит в систему, будет выдано предупреждение.
   > Вы можете заменить предупреждающее сообщение по умолчанию предупреждающим сообщением после команды или 
   > -h пройти после параметра, now чтобы указать немедленное завершение работы. 
9. Выход -  **exit** / **logout**。

10. Просмотр истории команд - **history**。

  ```Shell
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# history
  ...
  452  ls
  453  cd Python-3.6.5/
  454  clear
  455  history
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# !454
  ```

  > Описание: после просмотра истории команды можно использовать! для повторного выполнения команды; history 
  > -c до очистки истории команд. 
### Утилита

#### Операции с файлами и папками

1. Создать / удалить пустые каталоги - **mkdir** / **rmdir**。

   ```Shell
   [root ~]# mkdir abc
   [root ~]# mkdir -p xyz/abc
   [root ~]# rmdir abc
   ```

2. Создание / удаление файлов - **touch** / **rm**。

   ```Shell
   [root ~]# touch readme.txt
   [root ~]# touch error.txt
   [root ~]# rm error.txt
   rm: remove regular empty file ‘error.txt’? y
   [root ~]# rm -rf xyz
   ```

   - `touch`Команды используются для создания пустых файлов или изменения времени файла. В системе Linux существует три вида времени для файла:
- Пора менять content-mtime.
- Пора менять разрешения-ctime.
- Время последнего посещения.
   - rm Несколько важных параметров:
-i: Удалить в интерактивном режиме, будет запрашиваться каждый удаленный элемент.
-r: Удалить каталог и рекурсивно удалить файлы и каталоги в каталоге.
-f: Принудительное удаление, игнорирование несуществующих файлов без запроса.

3. Переключитесь и просмотрите текущий рабочий каталог - **cd** / **pwd**。

   > Объяснение: За cd командой может следовать относительный путь (текущий путь к ссылке) или абсолютный путь ( /в 
   > начале) для переключения в указанный каталог, также может использоваться cd .. для возврата на один уровень 
   > назад. Подумайте, пожалуйста, если вы хотите вернуться в каталог верхнего уровня, cd какие параметры нужно 
   > добавить в команду? 
4. Просмотрите содержимое каталогов - **ls**。

   - `-l`：Просмотр файлов и каталогов в длинном формате.
   - `-a`：Отображать файлы и каталоги, начинающиеся с точки (скрытые файлы).
   - `-R`：Рекурсивное расширение требуется при обнаружении каталога (продолжайте перечислять файлы и каталоги в каталоге).
   - `-d`：Перечислить только каталог, а не другой контент.
   - `-S` / `-t`： Сортировать по размеру / времени.

5. Просмотрите содержимое файла - **cat** / **tac** / **head** / **tail** / **more** / **less** / **rev** / **od**。

   ```Shell
   [root ~]# wget http://www.sohu.com/ -O sohu.html
   --2018-06-20 18:42:34--  http://www.sohu.com/
   Resolving www.sohu.com (www.sohu.com)... 14.18.240.6
   Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.
   HTTP request sent, awaiting response... 200 OK
   Length: 212527 (208K) [text/html]
   Saving to: ‘sohu.html’
   100%[==================================================>] 212,527     --.-K/s   in 0.03s
   2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527]
   [root ~]# cat sohu.html
   ...
   [root ~]# head -10 sohu.html
   <!DOCTYPE html>
   <html>
   <head>
   <title>111</title>
   <meta name="shenma-site-verification" content="1237e4d02a3d8d73e96cbd97b699e9c3_1504254750">
   <meta charset="utf-8"/>
   <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
   [root ~]# tail -2 sohu.html
   </body>
   </html>
   [root ~]# less sohu.html
   ...
   [root ~]# cat -n sohu.html | more
   ...
   ```

   > Описание: используется wget указанная выше команда, которая представляет собой программу-загрузчик из сети, 
   > которая может загружать ресурсы с указанного URL-адреса. 

6. Копирование / перемещение файлов - **cp** / **mv**。

   ```Shell
   [root ~]# mkdir backup
   [root ~]# cp sohu.html backup/
   [root ~]# cd backup
   [root backup]# ls
   sohu.html
   [root backup]# mv sohu.html sohu_index.html
   [root backup]# ls
   sohu_index.html
   ```

7. Переименовать файл - **rename**。

  ```Shell
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm
  ```

8. Найдите файлы и найдите контент - **find** / **grep**。

   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name "*.html"
   /root/sohu.html
   /root/backup/sohu_index.html
   [root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print
   [root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k
   [root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name "*.swp" -delete
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# grep "<script>" sohu.html -n
   20:<script>
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \<\/?script.*\> sohu.html -n
   20:<script>
   22:</script>
   24:<script src="//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js"></script>
   25:<script src="//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js"></script>
   26:<script src="//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js"></script>
   29:<script type="text/javascript">
   52:</script>
   ...
   ```
   > Примечание: grep вы можете использовать регулярные выражения при поиске строк. Если вам нужно использовать 
   > регулярные выражения, вы можете использовать их grep -E или использовать напрямую egrep. 
9. Создайте ссылку и просмотрите ссылку - **ln** / **readlink**。

   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
   -rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
   -rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html
   -rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfo
   lrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -> /etc/centos-release
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfo
   CentOS Linux release 7.4.1708 (Core)
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release
   CentOS Linux release 7.4.1708 (Core)
   ```

   > Примечание. Ссылки можно разделить на жесткие ссылки и программные ссылки (символические ссылки). Жесткую 
   > ссылку можно рассматривать как указатель на данные файла, как и счетчик ссылок на объект в Python. Каждый раз, 
   > когда жесткая ссылка добавляется, количество ссылок на файл увеличивается на 1. Только тогда, когда количество 
   > ссылок равно файл равен 0, файл соответствует. Пространство для хранения может быть перезаписано другими 
   > файлами. Когда мы обычно удаляем файлы, мы фактически не удаляем данные на жестком диске. То, что мы удаляем, 
   > -это просто указатель или запись об использовании данных, поэтому программное обеспечение, такое как «шредер 
   > файлов», за исключением удаления файлов при «измельчении» файлов. Указатель файла также заполняется данными в 
   > области хранения, соответствующей файлу, чтобы гарантировать невозможность восстановления файла. Программная 
   > ссылка аналогична ярлыку в системе Windows. Когда файл, связанный программной ссылкой, удаляется, программная 
   > ссылка становится недействительной. 
10. Сжать / разархивировать и заархивировать / разархивировать - **gzip** / **gunzip** / **xz**。

  ```Shell
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz
  --2018-06-20 19:29:59--  http://download.redis.io/releases/redis-4.0.10.tar.gz
  Resolving download.redis.io (download.redis.io)... 109.74.203.151
  Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.
  HTTP request sent, awaiting response... 200 OK
  Length: 1738465 (1.7M) [application/x-gzip]
  Saving to: ‘redis-4.0.10.tar.gz’
  100%[==================================================>] 1,738,465   70.1KB/s   in 74s
  2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465]
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*
  redis-4.0.10.tar.gz
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz
  [root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*
  redis-4.0.10.tar
  ```

11. Архив и unarchive - **tar**。

   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tar
   redis-4.0.10/
   redis-4.0.10/.gitignore
   redis-4.0.10/00-RELEASENOTES
   redis-4.0.10/BUGS
   redis-4.0.10/CONTRIBUTING
   redis-4.0.10/COPYING
   redis-4.0.10/INSTALL
   redis-4.0.10/MANIFESTO
   redis-4.0.10/Makefile
   redis-4.0.10/README.md
   redis-4.0.10/deps/
   redis-4.0.10/deps/Makefile
   redis-4.0.10/deps/README.md
   ...
   ```

   > Примечание. Как для архивирования (также известного как создание архива), так и для разархивирования 
   > используются tar команды. Обычно для создания архива требуются -cvf три параметра. Среди них c: создать (создать)
   > , v показать подробности создания архива (подробно) и f указать файл, который нужно заархивировать. (файл); 
   > решение Архивация требует добавления -xvf параметров, что x означает извлечение (извлечение), а два других 
   > параметра аналогичны созданию архивов. 
12. Преобразуйте стандартный ввод в аргументы командной строки - **xargs**。

   Следующая команда найдет html-файлы по текущему пути, а затем передаст xargs эти файлы в качестве параметров 
   rm команде для поиска и удаления файлов. 
   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name "*.html" | xargs rm -f
   ```

   Следующая команда превращает несколько строк в файле a.txt в одну и выводит ее в файл b.txt, где это <означает 
   чтение ввода из a.txt и >означает вывод результата выполнения команды в b.txt. 
   ```Shell
   [root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs < a.txt > b.txt
   ```

   > Описание: как показано выше, эта команда часто используется в конвейерах (способ достижения межпроцессного 
   > взаимодействия) и операциях перенаправления (повторное определение местоположения ввода и вывода). Операции 
   > конвейера и ввод будут обсуждаться в следующем содержании Вывод операция перенаправления. 
13. Отображение файлов или directories - **basename** / **dirname**。

14. Другие сопутствующие инструменты. 

   - **sort** - отсортировать содержимое
   - **uniq** - удаление соседних дубликатов
   - **tr** - заменить указанное содержимое новым содержимым
   - **cut** / **paste** - вырезать / вставить содержимое
   - **split** - split файл
   - **file** - Определите тип файла
   - **wc** - Счетчик строк, слов и байтов файла
   - **iconv** - преобразование кодировки

   ```Shell
   [root ~]# cat foo.txt
   grape
   apple
   pitaya
   [root ~]# cat bar.txt
   100
   200
   300
   400
   [root ~]# paste foo.txt bar.txt
   grape   100
   apple   200
   pitaya  300
           400
   [root ~]# paste foo.txt bar.txt > hello.txt
   [root ~]# cut -b 4-8 hello.txt
   pe      10
   le      20
   aya     3
   0
   [root ~]# cat hello.txt | tr '\t' ','
   grape,100
   apple,200
   pitaya,300
   ,400
   [root ~]# split -l 100 sohu.html hello
   [root ~]# wget https://www.baidu.com/img/bd_logo1.png
   [root ~]# file bd_logo1.png
   bd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced
   [root ~]# wc sohu.html
     2979   6355 212527 sohu.html
   [root ~]# wc -l sohu.html
   2979 sohu.html
   [root ~]# wget http://www.qq.com -O qq.html
   [root ~]# iconv -f gb2312 -t utf-8 qq.html
   ```

#### Трубопровод и перенаправление

1. Использование в - **\|**。

   Пример: Найдите количество файлов в текущем каталоге.

   ```Shell
   [root ~]# find ./ | wc -l
   6152
   ```

   Пример: перечислите файлы и папки по текущему пути и добавьте номер к каждому элементу.

   ```Shell
   [root ~]# ls | cat -n
        1  dump.rdb
        2  mongodb-3.6.5
        3  Python-3.6.5
        4  redis-3.2.11
        5  redis.conf
   ```

Пример: найдите общее количество записей, содержащих AAA, но не BBB, в record.log

   ```Shell
   [root ~]# cat record.log | grep AAA | grep -v BBB | wc -l
   ```

2. Перенаправление вывода и перенаправление ошибок - **\>** / **>>** / **2\>**。

   ```Shell
   [root ~]# cat readme.txt
   banana
   apple
   grape
   apple
   grape
   watermelon
   pear
   pitaya
   [root ~]# cat readme.txt | sort | uniq > result.txt
   [root ~]# cat result.txt
   apple
   banana
   grape
   pear
   pitaya
   watermelon
   ```

3. Введите перенаправление - **\<**。

   ```Shell
   [root ~]# echo 'hello, world!' > hello.txt
   [root ~]# wall < hello.txt
   [root ~]#
   Broadcast message from root (Wed Jun 20 19:43:05 2018):
   hello, world!
   [root ~]# echo 'I will show you some code.' >> hello.txt
   [root ~]# wall < hello.txt
   [root ~]#
   Broadcast message from root (Wed Jun 20 19:43:55 2018):
   hello, world!
   I will show you some code.
   ```

4. Множественное перенаправление - **tee**。

   Помимо отображения ls результатов команд на терминале, следующие команды также будут выводиться в ls.txt файл.
   ```Shell
   [root ~]# ls | tee -a ls.txt
   ```

#### Псевдоним

1. **alias**

   ```Shell
   [root ~]# alias ll='ls -l'
   [root ~]# alias frm='rm -rf'
   [root ~]# ll
   ...
   drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc
   ...
   [root ~]# frm abc
   ```

2. **unalias**

   ```Shell
   [root ~]# unalias frm
   [root ~]# frm sohu.html
   -bash: frm: command not found
   ```

#### Обработка текста

1. Редактор символьного потока - **sed**。

   Sed - это инструмент для управления, фильтрации и преобразования текстового контента. Предположим, есть файл с 
   именем fruit.txt с содержимым, как показано ниже. 
   ```Shell
   [root ~]# cat -n fruit.txt 
        1  banana
        2  grape
        3  apple
        4  watermelon
        5  orange
   ```

   Затем мы добавляем питайю после строки 2.

   ```Shell
   [root ~]# sed '2a pitaya' fruit.txt 
   banana
   grape
   pitaya
   apple
   watermelon
   orange
   ```

   > Примечание. Команда только что не изменяет файл fruit.txt, как многие команды, которые мы упоминали ранее, но
   > выводит содержимое добавленной новой строки в терминал. Если вы хотите сохранить его в fruit.txt, вы можете
   > используйте перенаправление вывода.


Вставьте восковую ягоду перед линией 2.

   ```Shell
   [root ~]# sed '2i waxberry' fruit.txt
   banana
   waxberry
   grape
   apple
   watermelon
   orange
   ```

   Удалите третью строку.。

   ```Shell
   [root ~]# sed '3d' fruit.txt
   banana
   grape
   watermelon
   orange
   ```

  Удалите строки 2–4.

   ```Shell
   [root ~]# sed '2,4d' fruit.txt
   banana
   orange
   ```

   Замените в тексте символ a на @.

   ```Shell
   [root ~]# sed 's#a#@#' fruit.txt 
   b@nana
   gr@pe
   @pple
   w@termelon
   or@nge
   ```

   Замените в тексте символ a на @ и используйте глобальный режим.

   ```Shell
   [root ~]# sed 's#a#@#g' fruit.txt 
   b@n@n@
   gr@pe
   @pple
   w@termelon
   or@nge
   ```

2. Язык сопоставления и обработки с образцом - **awk**。

Awk - это язык программирования и самый мощный инструмент для обработки текста в системе Linux.Один из его авторов 
и текущих сопровождающих - вышеупомянутый Брайан Керниган (ближайший партнер ken и dmr). С помощью этой команды вы 
можете извлекать указанный столбец из текста, использовать регулярные выражения для извлечения нужного нам 
содержимого из текста, отображать указанную строку и выполнять статистику и вычисления. Короче говоря, это очень 
мощный инструмент.

Предположим, существует файл с именем fruit2.txt с содержимым, как показано ниже.

   ```Shell
   [root ~]# cat fruit2.txt 
   1       banana      120
   2       grape       500
   3       apple       1230
   4       watermelon  80
   5       orange      400
   ```

Отобразите 3-ю строку файла

   ```Shell
   [root ~]# awk 'NR==3' fruit2.txt 
   3       apple       1230
   ```

Отобразите второй столбец файла.

   ```Shell
   [root ~]# awk '{print $2}' fruit2.txt 
   banana
   grape
   apple
   watermelon
   orange
   ```

Отобразите последний столбец файла.

   ```Shell
   [root ~]# awk '{print $NF}' fruit2.txt 
   120
   500
   1230
   80
   400
   ```

Выведите в конце строки с числом больше или равным 300.

   ```Shell
   [root ~]# awk '{if($3 >= 300) {print $0}}' fruit2.txt 
   2       grape       500
   3       apple       1230
   5       orange      400
   ```

Вышеупомянутое - лишь верхушка айсберга команды awk, и читателю предоставляется больше информации для изучения на 
практике. 

### Управление пользователями

1. Создание и удаление пользователей - **useradd** / **userdel**。

   ```Shell
   [root home]# useradd hellokitty
   [root home]# userdel hellokitty
   ```

   - `-d` - Укажите домашний каталог пользователя для пользователя при создании пользователя
   - `-g` - Укажите группу пользователей, к которой принадлежит пользователь при создании пользователя

2. Создание и удаление групп пользователей - **groupadd** / **groupdel**。

   > Примечание: группа пользователей в основном предназначена для облегчения управления всеми пользователями в группе.

3. Смена пароля - **passwd**。

   ```Shell
   [root ~]# passwd hellokitty
   New password: 
   Retype new password: 
   passwd: all authentication tokens updated successfully.
   ```

   > Примечание. Входной пароль и пароль подтверждения не отображаются эхом, и их необходимо вводить за один раз 
   > (нельзя использовать клавишу Backspace), а пароль и пароль подтверждения должны быть согласованы. Если 
   > passwdвы не укажете объект команды при использовании команды, это означает, что вы хотите изменить пароль 
   > текущего пользователя. Если вы хотите изменять пароли пользователей партиями, вы можете использовать chpasswd 
   > команды.
   - `-l` / `-u` - Блокировать / разблокировать пользователя.
   - `-d` - Чистый пароль пользователя.
   - `-e` - Установите пароль для немедленного истечения срока действия, и пользователь будет вынужден изменить 
     пароль при входе в систему. 
   - `-i` - Установите количество дней после истечения срока действия пароля, чтобы отключить пользователя.

4. Просмотр и изменение пароля - **chage**。

   После настройки пользователя hellokitty пароль должен быть изменен через 100 дней, пользователь будет уведомлен 
   за 15 дней до истечения срока действия, и пользователь будет отключен через 7 дней после истечения срока действия. 
   ```Shell
   chage -M 100 -W 15 -I 7 hellokitty
   ```

5. Сменить пользователя - **su**。

   ```Shell
   [root ~]# su hellokitty
   [hellokitty root]$
   ```

6. Выполните команду от имени администратора - **sudo**。

   ```Shell
   [hellokitty ~]$ ls /root
   ls: cannot open directory /root: Permission denied
   [hellokitty ~]$ sudo ls /root
   [sudo] password for hellokitty:
   ```

   > Описание: если вы хотите, чтобы пользователи выполняли команды в качестве администратора, пользователь должен 
   > отображаться в списке sudoers, файл sudoers в /etc каталоге, если вы хотите напрямую редактировать файл, также 
   > можете использовать следующую команду. 
   
7. Отредактируйте файл sudoers visudo.

Здесь используется редактор vi, а информация о vi будет объяснена позже. Часть содержимого файла выглядит следующим 
образом: 
   ```
   ## Allow root to run any commands anywhere 
   root    ALL=(ALL)   ALL
   
   ## Allows members of the 'sys' group to run networking, software, 
   ## service management apps and more.
   # %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS
   ## Allows people in group wheel to run all commands
   %wheel  ALL=(ALL)   ALL
   
   ## Same thing without a password
   # %wheel    ALL=(ALL)   NOPASSWD: ALL
   
   ## Allows members of the users group to mount and unmount the
   ## cdrom as root
   # %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom
   
   ## Allows members of the users group to shutdown this system
   # %users  localhost=/sbin/shutdown -h now
   ```

8. Отображение информации о пользователях и группах пользователей - **id**。

9. Отправлять сообщения другим пользователям -**write** / **wall**。

   отправитель:

   ```Shell
   [root ~]# write hellokitty
   Dinner is on me.
   Call me at 6pm.
   ```

   получатель:

   ```Shell
   [hellokitty ~]$ 
   Message from root on pts/0 at 17:41 ...
   Dinner is on me.
   Call me at 6pm.
   EOF
   ```

10. Просмотр / установка, следует ли получать сообщения, отправленные другими пользователями - **mesg**。

   ```Shell
   [hellokitty ~]$ mesg
   is y
   [hellokitty ~]$ mesg n
   [hellokitty ~]$ mesg
   is n
   ```

### Файловая система

#### Файл и путь

1. Правила именования: максимальная длина имени файла зависит от типа файловой системы. Как правило, имя файла не 
   должно превышать 255 символов. Хотя в имени файла можно использовать большинство символов, лучше всего 
   использовать английские прописные и строчные буквы. и числа., подчеркивание и точка. Хотя в именах файлов можно 
   использовать пробелы, их следует по возможности избегать. В противном случае вам нужно заключить имя файла в 
   двойные кавычки или \экранировать пробелы при вводе имени файла.
2. Расширение: расширение файла не является обязательным в системе Linux, но использование расширения полезно для 
   понимания содержимого файла. Некоторым приложениям необходимо идентифицировать файлы по расширению, но другие 
   приложения не полагаются на расширение файла, так же как file команда не определяет тип файла на основе 
   расширения при идентификации файла.
3. Скрытые файлы: файлы, начинающиеся с точки, являются скрытыми файлами (невидимыми файлами) в системах Linux. 

#### Структура каталогов

1. / bin-Двоичный файл основных команд.
2. / boot - статический файл загрузчика.
3. / dev-device файл.
4. / etc - файл конфигурации.
5. / home - родительский каталог домашнего каталога обычного пользователя.
6. / lib файлы общей библиотеки.
7. / lib64-share файлы 64-битных библиотек.
8. / lost + found - хранить несвязанные файлы.
9. / media - Автоматически определять каталог монтирования устройства.
10. / mnt - точка монтирования для временного монтирования файловой системы.
11. / opt-Дополнительное место установки пакета подключаемого модуля.
12. / proc-Ядро и информация о процессе.
13. / root - домашний каталог суперадминистратора.
14. / run-Хранить все, что нужно, когда система работает.
15. / sbin - двоичный файл для суперпользователя.
16. / sys - псевдофайловая система устройства.
17. / tmp-временная папка.
18. / usr - каталог пользовательского приложения.
19. / var-Каталог данных переменных.

#### разрешение на доступ

1. **chmod** - изменить бит режима файла.

   ```Shell
   [root ~]# ls -l
   ...
   -rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html
   ...
   [root ~]# chmod g+w,o+w sohu.html
   [root ~]# ls -l
   ...
   -rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html
   ...
   [root ~]# chmod 644 sohu.html
   [root ~]# ls -l
   ...
   -rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html
   ...
   ```
   > Примечание. Из приведенного выше примера видно, что chmod есть два способа изменить бит режима файла: один - это 
   > метод установки символов, а другой - метод установки числа. Кроме chmod того, вы можете использовать, 
   > umask чтобы установить, какие разрешения будут удалены в разрешениях по умолчанию для нового файла.
    
   
При просмотре каталога или файла в длинном формате отображаемые результаты и соответствующие им значения разрешений 
показаны в следующей таблице. 

   ![](./res/file-mode.png)

2. **chown** - смена владельца файла

    ```Shell
    [root ~]# ls -l
    ...
    -rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt
    ...
    [root ~]# chown hellokitty readme.txt
    [root ~]# ls -l
    ...
    -rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt
    ...
    ```

3. **chgrp** - смена группы пользователей.

#### Управление диском

1. Список использования диска файловой системой - **df**。

   ```Shell
   [root ~]# df -h
   Filesystem      Size  Used Avail Use% Mounted on
   /dev/vda1        40G  5.0G   33G  14% /
   devtmpfs        486M     0  486M   0% /dev
   tmpfs           497M     0  497M   0% /dev/shm
   tmpfs           497M  356K  496M   1% /run
   tmpfs           497M     0  497M   0% /sys/fs/cgroup
   tmpfs           100M     0  100M   0% /run/user/0
   ```

2. Операция с таблицей разделов диска - **fdisk**。

   ```Shell
   [root ~]# fdisk -l
   Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors
   Units = sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disk label type: dos
   Disk identifier: 0x000a42f4
      Device Boot      Start         End      Blocks   Id  System
   /dev/vda1   *        2048    83884031    41940992   83  Linux
   Disk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
   Units = sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   ```

3. Диск раздела tool - **parted**。

4. Отформатируйте файловую систему - **mkfs**。

   ```Shell
   [root ~]# mkfs -t ext4 -v /dev/sdb
   ```

   - `-t` - Укажите тип файловой системы。
   - `-c` - Проверьте повреждение диска при создании файловой системы。
   - `-v` - Показать подробную информацию。

5. Проверка файловой системы - **fsck**。

6. Конвертируйте или копируйте файлы - **dd**。

7. смонтировать / размонтировать - **mount** / **umount**。

8. Создать / активировать / закрыть раздел подкачки - **mkswap** / **swapon** / **swapoff**。

> Примечание. Выполнение вышеперечисленных команд сопряжено с определенными рисками. Если вы не уверены в 
> использовании этих команд, лучше не использовать их по своему желанию. В процессе использования лучше всего 
> действовать в соответствии с рекомендациями. материалы и подтвердите, хотите ли вы сделать это перед операцией. 


### Редактор - vim

1. Запустите vim. Вы можете запустить vim с помощью команды vi или vim. Вы можете указать имя файла, чтобы открыть 
   файл при его запуске. Если вы не укажете имя файла, вы также можете указать имя файла при сохранении. 
   ```Shell
   [root ~]# vim guess.py
   ```

2. Командный режим, режим редактирования и режим последней строки: запустите vim для входа в командный режим (также 
   известный как обычный режим), i войдите в режим редактирования (режим вставки), когда вы вводите английские буквы 
   в командном режиме, и внизу появится -- INSERT --подсказка экрана; в режиме редактирования Нажмите, Esc чтобы 
   вернуться в командный режим. В это время, если вы введете английский, вы: войдете в режим последней строки. 
   Войдите в режим последней строки, q! чтобы принудительно выйти из vim без сохранения текущей работы; vвведите в 
   визуальном режиме при входе в командный режим (визуальный режим) вы можете использовать курсор, чтобы выбрать 
   область, а затем выполнить соответствующую операцию. 
3. Сохраните и выйдите из vim: войдите в командный режим, чтобы войти: в режим последней строки, и введите, wq чтобы 
   сохранить и выйти; если вы хотите отказаться от редактируемого содержимого, введите q!принудительный выход, о 
   чем только что говорилось; в командном режиме вы также можете непосредственно введите, ZZ чтобы сохранить выход. 
   Если вы хотите только сохранить файл без выхода, вы можете ввести его в режиме последней строки w; вы можете 
   wв вести пробел после этого, а затем указать имя файла для сохранения. 
4. Работа курсора.

- В команде через режим h, j, k, l для управления курсором влево, вниз, вверх, правильное направление движения, до 
- того, как цифры могут быть введены буквы, чтобы представить пройденное расстояние, например: 10h представляет 
  собой 10 символов двигаться влево.
- В командном режиме вы можете использовать Ctrl+y и Ctrl+e для прокрутки строки текста вверх и вниз, и вы можете 
  использовать Ctrl+f и Ctrl+b для перелистывания страниц вперед и назад.
- В командном режиме путем ввода букв G переместите курсор в конец файла, gg курсором в начало файла, может быть G перед 
  вводом цифрового, чтобы переместить курсор в указанную строку.

5. Текстовые манипуляции.

- Удалить: в командном режиме может использоваться dd для удаления всей строки; может dd использоваться для указания 
- количества удаляемых строк, которым предшествует номер; может d$быть выполнено удаление удалено от курсора до 
  рабочего конца строки, также может d0быть выполнено из укажите, чтобы удалить операцию dw в начале строки если 
  вы хотите удалить слово, вы можете использовать его; если вы хотите удалить полный текст, вы можете ввести его 
  :%d (который: используется для входа в режим последней строки из командный режим).
- Копирование и вставка: в командном режиме можно использовать yy для копирования всей строки; yy можно скопировать до 
  указанного количества строк плюс числа; можно p вставить содержимое, куда копируется курсор.
- Отменить и повторить: введите в командном режиме, чтобы u отменить предыдущую операцию; через Ctrl+r вы можете 
  повторить отмененную операцию.
- Сортировка содержимого: ввод в командном режиме %!sort.

6. Найти и заменить.

Операция поиска требует ввода для /входа в режим последней строки и предоставления регулярного выражения для 
соответствия соответствующему содержимому, например :, /doc.*\.ввод nдля поиска вперед или ввод N для поиска в 
обратном направлении.
Операция замены должна войти: в режим последней строки и указать диапазон поиска, регулярное выражение, содержимое 
и параметры сопоставления после замены, например: , :1,$s/doc.*/hello/gice где:
     - `g` - global：глобальный。
     - `i` - ignore case：игнорировать регистр。
     - `c` - confirm：Подтверждение требуется при замене。
     - `e` - error：игнорировать ошибки。

7. Настройка параметров: после: входа в режим последней строки вы можете установить vim.

   - Задайте количество пробелов для клавиши Tab:set ts=4

   - Установить номер отображаемой / неотображаемой строки: set nu/set nonu

   - Установите синтаксис включения / отключения подсветки: syntax on/syntax off

   - Установите линейку дисплея (строку и столбец, в которых находится курсор): set ruler

   - Установите для включения / выключения выделения результатов поиска: set hls/set nohls

     > Примечание. Если вы хотите, чтобы указанные выше настройки вступали в силу автоматически при каждом запуске 
     > vim, вам необходимо записать эти настройки в файл. vimrc в домашнем каталоге пользователя.


8. Продвинутые навыки

   - Сравните несколько файлов.

     ```Shell
     [root ~]# vim -d foo.txt bar.txt
     ```
   - Открыть несколько файлов.

     ```Shell
     [root ~]# vim foo.txt bar.txt hello.txt
     ```

     После запуска vim только одно окно отображает foo.txt. Вы можете войти в режим последней строки, чтобы 
     ls просмотреть три открытых файла, или вы можете войти в режим последней строки, b <num> чтобы отобразить другой 
     файл, например, вы можете использовать: b 2bar.txt для отображения Когда он появится, вы можете использовать 
     :b 3hello.txt для его отображения. 
   - Разделяйте и переключайте окна.

     Вы можете войти sp или в режиме последней строки, чтобы vs разделить окно по горизонтали или вертикали, чтобы мы 
     могли одновременно открывать несколько окон редактирования. При двойном нажатии Ctrl+w можно переключать окна 
     редактирования, а операция выхода в одном окне выполняется только Соответствующее окно закроется, а остальные 
     останутся. 

   - Сопоставление сочетаний клавиш: в vim некоторые общие операции могут быть сопоставлены с сочетаниями клавиш для 
     повышения эффективности работы. 
     - Пример 1. Введите и F4выполните операцию удаления 10 000 строк кода из первой строки в командном режиме.

       `:map <F4> gg10000dd`。

       Пример 2: Ввод __main прямого завершения, как в режиме редактирования `if __name__ == '__main__':`。

       `:inoremap __main if __name__ == '__main__':`

     > Описание: 2 в приведенном выше примере inoremap на i карту с указанием ключа в использовании режима 
     > редактирования, nore значит вы не может рекурсии, что очень важно, в противном случае, если ключ, 
     > соответствующий содержанию появился ключом сам, приведет к рекурсивному (эквиваленту войти бесконечный цикл). 
     > Если вы хотите, чтобы назначенные сочетания клавиш вступали в силу при каждом запуске vim, вам необходимо 
     > записать сопоставление в файл. vimrc в домашнем каталоге пользователя. 
   - Запишите макрос.

* Войдите в командный режим, чтобы qa начать запись макроса (где это a имя регистра, это также могут быть другие 
английские буквы или цифры от 0 до 9).

* Выполняйте свои операции (операции с курсором, операции редактирования и т. Д.), И эти операции будут записаны.

* Если операция записи была завершена, нажмите, чтобы q завершить запись.

* Играть макрос через @a(a имя регистра просто используется). Если вы хотите, чтобы выполнить макрос несколько раз,
  вы можете добавить несколько впереди, например, это 100@aзначит играть макрос 100 раз.

* Вы можете попробовать следующий пример, чтобы испытать операцию записи макросов. Пример взят с веб-сайта Harttle 
Land, который предоставляет множество советов по использованию vim. Те, кому интересно, могут узнать об этом. 

### Установка и настройка программного обеспечения

#### Используйте инструменты управления пакетами

1. **yum** - Yellowdog Updater Modified。
   - `yum search`：Поиск пакетов, например `yum search nginx`。
   - `yum list installed`：Например, список установленных пакетов `yum list installed | grep zlib`。
   - `yum install`：Установите, например, программный пакет `yum install nginx`。
   - `yum remove`：Удалите, например, программные пакеты `yum remove nginx`。
   - `yum update`：Обновите пакеты, например `yum update`вы можете обновить все пакеты, но `yum update tar`только tar。
   - `yum check-update`：Проверить, какие пакеты программного обеспечения можно обновить.
   - `yum info`：Отображение информации о программном пакете, например`yum info nginx`。
2. **rpm** - Redhat Package Manager。
   - Установите：`rpm -ivh <packagename>.rpm`。
   - Удаление：`rpm -e <packagename>`。
   - Пакеты запросов:：`rpm -qa`，например, можно использовать `rpm -qa | grep mysql`для проверки, установлены ли  
     пакеты программного обеспечения, относящиеся к MySQL.

Давайте возьмем Nginx в качестве примера, чтобы продемонстрировать, как использовать yum для установки программного 
обеспечения.

```Shell
[root ~]# yum -y install nginx
...
Installed:
  nginx.x86_64 1:1.12.2-2.el7
Dependency Installed:
  nginx-all-modules.noarch 1:1.12.2-2.el7
  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7
  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7
  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7
  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7
  nginx-mod-mail.x86_64 1:1.12.2-2.el7
  nginx-mod-stream.x86_64 1:1.12.2-2.el7
Complete!
[root ~]# yum info nginx
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
Installed Packages
Name        : nginx
Arch        : x86_64
Epoch       : 1
Version     : 1.12.2
Release     : 2.el7
Size        : 1.5 M
Repo        : installed
From repo   : epel
Summary     : A high performance web server and reverse proxy server
URL         : http://nginx.org/
License     : BSD
Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and
            : IMAP protocols, with a strong focus on high concurrency, performance and low
            : memory usage.
[root ~]# nginx -v
nginx version: nginx/1.12.2
```

Удалите Nginx。

```Shell
[root ~]# yum -y remove nginx
```

Давайте возьмем MySQL в качестве примера, чтобы продемонстрировать, как устанавливать программное обеспечение с 
помощью rpm. Чтобы установить MySQL, вам необходимо загрузить соответствующий RPM-файл с официального сайта MySQL . 
Разумеется, вы должны выбрать версию, которая соответствует используемой вами системе Linux. MySQL теперь является 
продуктом Oracle. После того, как MySQL был приобретен, автор MySQL воссоздал ветку MySQL MariaDB, которую можно 
установить через yum. 
```Shell
[root mysql]# ls
mysql-community-client-5.7.22-1.el7.x86_64.rpm
mysql-community-common-5.7.22-1.el7.x86_64.rpm
mysql-community-libs-5.7.22-1.el7.x86_64.rpm
mysql-community-server-5.7.22-1.el7.x86_64.rpm
[root mysql]# yum -y remove mariadb-libs
[root mysql]# yum -y install libaio
[root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm
...
[root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm
...
```

> Примечание. Поскольку базовые библиотеки зависимостей MySQL и MariaDB конфликтуют, мы сначала yumудалили 
> библиотеку зависимостей с именем mariadb-libs и установили библиотеку зависимостей с именем libaio, которая 
> поддерживает операции асинхронного ввода-вывода. Что касается взаимоотношений между MySQL и MariaDB, вы можете 
> прочитать введение в MariaDB в Википедии. 
 

Удалите установленный MySQL.

```Shell
[root ~]# rpm -qa | grep mysql | xargs rpm -e
```

#### Загрузите и разархивируйте переменные среды конфигурации

Давайте возьмем установку MongoDB в качестве примера, чтобы продемонстрировать, как следует устанавливать этот тип 
программного обеспечения. 

```Shell
[root ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz
--2018-06-21 18:32:53--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz
Resolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...
Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 100564462 (96M) [application/x-gzip]
Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’
100%[==================================================>] 100,564,462  630KB/s   in 2m 9s
2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462]
[root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz
[root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tar
mongodb-linux-x86_64-rhel70-3.6.5/README
mongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICES
mongodb-linux-x86_64-rhel70-3.6.5/MPL-2
mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodump
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestore
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexport
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimport
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongostat
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongotop
mongodb-linux-x86_64-rhel70-3.6.5/bin/bsondump
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongofiles
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplay
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperf
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongod
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongos
mongodb-linux-x86_64-rhel70-3.6.5/bin/mongo
mongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass
[root ~]# vim .bash_profile
...
PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/bin
export PATH
...
[root ~]# source .bash_profile
[root ~]# mongod --version
db version v3.6.5
git version: a20ecd3e3a174162052ff99913bc2ca9a839d618
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64
[root ~]# mongo --version
MongoDB shell version v3.6.5
git version: a20ecd3e3a174162052ff99913bc2ca9a839d618
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64
```

> Примечание. Конечно, вы также можете установить MongoDB через yum. Подробнее см. В инструкциях на официальном сайте .


#### Сборка и установка исходного кода

1. Установите Python 3.6。

   ```Shell
   [root ~]# yum install gcc
   [root ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz
   [root ~]# gunzip Python-3.6.5.tgz
   [root ~]# tar -xvf Python-3.6.5.tar
   [root ~]# cd Python-3.6.5
   [root ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations
   [root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel
   [root ~]# make && make install
   ...
   [root ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3
   [root ~]# python3 --version
   Python 3.6.5
   [root ~]# python3 -m pip install -U pip
   [root ~]# pip3 --version
   ```

   > Примечание. После установки Python вам также необходимо зарегистрировать переменную среды PATH и 
   > зарегистрировать абсолютный путь к папке bin в пути установки Python в переменной среды PATH. Регистрация 
   > переменных среды может изменить .bash_profile в домашнем каталоге пользователя или файл профиля в каталоге / 
   > etc. Разница между ними заключается в том, что первые эквивалентны переменным среды пользователя, а вторые - 
   > системным переменным среды.


2. Установите Redis-3.2.12。

   ```Shell
   [root ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz
   [root ~]# gunzip redis-3.2.12.tar.gz
   [root ~]# tar -xvf redis-3.2.12.tar
   [root ~]# cd redis-3.2.12
   [root ~]# make && make install
   [root ~]# redis-server --version
   Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6
   [root ~]# redis-cli --version
   redis-cli 3.2.12
   ```

### Служба настройки

Мы можем устанавливать и настраивать различные службы в системе Linux, что означает, что мы можем превратить систему 
Linux в сервер базы данных, веб-сервер, сервер кеширования, файловый сервер, сервер очереди сообщений и так далее. 
Большинство услуг под Linux устанавливается как процессы демона (проживающих в фоновом режиме системы, но Linux не 
могут быть остановлены, поскольку услуги по - прежнему работают), поэтому услуги мы устанавливаем , как правило, 
письмо после имени d, он это daemon сокращение от английских слов. Например, служба межсетевого экрана называется 
firewalld, служба MySQL, которую мы установили ранее, называется mysqld, а сервер Apache называется httpd. После установки службы вы можете использовать systemctlкоманды или serviceкоманды для выполнения таких операций, как запуск и остановка службы. Ниже приведены конкретные операции. 
1. Запустите службу брандмауэра.

   ```Shell
   [root ~]# systemctl start firewalld
   ```

2. Закройте службу брандмауэра.

   ```Shell
   [root ~]# systemctl stop firewalld
   ```

3. Перезапустите службу брандмауэра.

   ```Shell
   [root ~]# systemctl restart firewalld
   ```

4. Проверьте статус службы межсетевого экрана.

    ```Shell
    [root ~]# systemctl status firewalld
    ```

5. Установите / отключите автоматический запуск службы брандмауэра после загрузки.

   ```Shell
   [root ~]# systemctl enable firewalld
   Created symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.
   Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.
   [root ~]# systemctl disable firewalld
   Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
   Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
   ```

### Запланированные задачи

1. Выполните команду в указанное время.

   - **at** - Оставить задачу в очередь и выполнить ее в указанное время。
   - **atq** - просмотр очереди задач, которые нужно выполнить。
   - **atrm** - удалить из очереди задачу, которую нужно выполнить.

  Укажите задачу, которую нужно выполнить в 17:00 через 3 дня.

   ```Shell
   [root ~]# at 5pm+3days
   at> rm -f /root/*.html
   at> <EOT>
   job 9 at Wed Jun  5 17:00:00 2019
   ```

   Просмотрите очередь задач, которые нужно выполнить.

   ```Shell
   [root ~]# atq
   9       Wed Jun  5 17:00:00 2019 a root
   ```

   Удалить указанную задачу из очереди.

   ```Shell
   [root ~]$ atrm 9
   ```

2. Таблица запланированных задач - **crontab**。

   ```Shell
   [root ~]# crontab -e
   * * * * * echo "hello, world!" >> /root/hello.txt
   59 23 * * * rm -f /root/*.log
   ```
   > Описание: ввод crontab -e команды откроет vim для редактирования выражения cron и указания задачи, которая будет 
   > запускаться. Выше мы настроили две запланированные задачи, одна - каждую минуту добавлять вывод в hello.txt в 
   > корневой каталог / hello, world!; вторая - в 23 часа каждый день На 59 точках удалите файлы с суффиксом log в 
   > корневом каталоге /. Если вы не знаете, как писать выражения Cron, вы можете обратиться к подсказкам в файле / 
   > etc / crontab (описанном ниже) или использовать поисковую систему, чтобы найти «Онлайн-генератор выражений 
   > Cron» для генерации выражений Cron. 
   
   Файлы, относящиеся к crontab, находятся в /etcкаталоге, и /etcзапланированные задачи также можно настроить , 
   изменив файл crontab в каталоге. 

   ```Shell
   [root ~]# cd /etc
   [root etc]# ls -l | grep cron
   -rw-------.  1 root root      541 Aug  3  2017 anacrontab
   drwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.d
   drwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily
   -rw-------.  1 root root        0 Aug  3  2017 cron.deny
   drwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourly
   drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly
   -rw-r--r--   1 root root      493 Jun 23 15:09 crontab
   drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly
   [root etc]# vim crontab
     1 SHELL=/bin/bash
     2 PATH=/sbin:/bin:/usr/sbin:/usr/bin
     3 MAILTO=root
     4
     5 # For details see man 4 crontabs
     6
     7 # Example of job definition:
     8 # .---------------- minute (0 - 59)
     9 # |  .------------- hour (0 - 23)
    10 # |  |  .---------- day of month (1 - 31)
    11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
    12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
    13 # |  |  |  |  |
    14 # *  *  *  *  * user-name  command to be executed
   ```


### Доступ к сети и управление

1. Безопасное удаленное соединение  - **ssh**。

    ```Shell
    [root ~]$ ssh root@120.77.222.217
    The authenticity of host '120.77.222.217 (120.77.222.217)' can't be established.
    ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w.
    ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65.
    Are you sure you want to continue connecting (yes/no)? yes
    Warning: Permanently added '120.77.222.217' (ECDSA) to the list of known hosts.
    root@120.77.222.217's password: 
    ```

2. Получите ресурсы через сеть - **wget**。

   - -b фоновый режим загрузки
   - -O скачать в указанный каталог
   - -r рекурсивная загрузка

3. Отправлять и получать почту - **mail**。

4. Инструмент настройки сети (старый)  - **ifconfig**。

   ```Shell
   [root ~]# ifconfig eth0
   eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
           inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255
           ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)
           RX packets 1067841  bytes 1296732947 (1.2 GiB)
           RX errors 0  dropped 0  overruns 0  frame 0
           TX packets 409912  bytes 43569163 (41.5 MiB)
           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 
   ```

5. Инструмент настройки сети (новый)  - **ip**。

   ```Shell
   [root ~]# ip address
   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
       link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
       inet 127.0.0.1/8 scope host lo
          valid_lft forever preferred_lft forever
   2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
       link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff
       inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0
          valid_lft forever preferred_lft forever
   ```

6. Сеть достижимости чек - **ping**。

   ```Shell
   [root ~]# ping www.baidu.com -c 3
   PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.
   64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms
   64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms
   64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms
   --- www.a.shifen.com ping statistics ---
   3 packets transmitted, 3 received, 0% packet loss, time 2002ms
   rtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms
   ```

7. Отображение или управление таблицей маршрутизации - **route**。

8. Просмотр сетевых служб и портов - **netstat** / **ss**。

   ```Shell
   [root ~]# netstat -nap | grep nginx
   ```

9. Захват пакетов сетевого мониторинга - **tcpdump**。

10. Безопасное копирование файлов  - **scp**。

  ```Shell
  [root ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg
  ```

11. Инструмент синхронизации файлов  - **rsync**。

    > Примечание: с помощью rsync можно реализовать автоматическую синхронизацию файлов, что очень важно для 
    > файлового сервера. Что касается использования этой команды, мы подробно объясним ее, когда поговорим о 
    > развертывании проекта позже.  
12. Безопасная передача файлов - **sftp**。

    ```Shell
    [root ~]# sftp root@1.2.3.4
    root@1.2.3.4's password:
    Connected to 1.2.3.4.
    sftp>
    ```

    - `help`：Отображение справочной информации。

    - `ls`/`lls`：Показать список удаленных / локальных каталогов。

    - `cd`/`lcd`：Переключить удаленный / локальный путь。

    - `mkdir`/`lmkdir`：Создать удаленный / локальный каталог.

    - `pwd`/`lpwd`：Показать текущий удаленный / локальный рабочий каталог.

    - `get`：Загрузка файла.

    - `put`：загрузить файлы。

    - `rm`：Удалить удаленные файлы。

    - `bye`/`exit`/`quit`：Выход SFTP.

### Управление процессом

1. Посмотреть процесс  - **ps**。

   ```Shell
   [root ~]# ps -ef
   UID        PID  PPID  C STIME TTY          TIME CMD
   root         1     0  0 Jun23 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
   root         2     0  0 Jun23 ?        00:00:00 [kthreadd]
   ...
   [root ~]# ps -ef | grep mysqld
   root      4943  4581  0 22:45 pts/0    00:00:00 grep --color=auto mysqld
   mysql    25257     1  0 Jun25 ?        00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid
   ```

2. Отображение дерева состояния процесса - **pstree**。

    ```Shell
    [root ~]# pstree
    systemd─┬─AliYunDun───18*[{AliYunDun}]
            ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]
            ├─2*[agetty]
            ├─aliyun-service───2*[{aliyun-service}]
            ├─atd
            ├─auditd───{auditd}
            ├─dbus-daemon
            ├─dhclient
            ├─irqbalance
            ├─lvmetad
            ├─mysqld───28*[{mysqld}]
            ├─nginx───2*[nginx]
            ├─ntpd
            ├─polkitd───6*[{polkitd}]
            ├─rsyslogd───2*[{rsyslogd}]
            ├─sshd───sshd───bash───pstree
            ├─systemd-journal
            ├─systemd-logind
            ├─systemd-udevd
            └─tuned───4*[{tuned}]
    ```

3. Найдите процесс, который соответствует указанным критериям - **pgrep**。

   ```Shell
   [root ~]$ pgrep mysqld
   3584
   ```

4. Завершите процесс, набрав номер процесса- **kill**。

   ```Shell
   [root ~]$ kill -l
    1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
    6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
   11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
   16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
   21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
   26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
   31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
   38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
   43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
   48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
   53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
   58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
   63) SIGRTMAX-1  64) SIGRTMAX
   [root ~]# kill 1234
   [root ~]# kill -9 1234
   ```

   Пример: используйте команду для принудительного завершения запущенного процесса Redis.

    ```Shell
   ps -ef | grep redis | grep -v grep | awk '{print $2}' | xargs kill
    ```

5. Завершить процесс по имени процесса - killall / pkill .

Завершите процесс с именем mysqld.

    ```Shell
    [root ~]# pkill mysqld
    ```

Завершите все процессы пользователя hellokitty.

    ```Shell
    [root ~]# pkill -u hellokitty
    ```

> Примечание. Эта операция отключит пользователя hellokitty от сервера.

6. Поместите процесс в фоновый режим.

   - `Ctrl+Z` - Клавиши быстрого доступа, используемые для остановки процесса и перевода его в фоновый режим.
   - `&` - Поставить процесс для запуска в фоновом режиме.

   ```Shell
   [root ~]# mongod &
   [root ~]# redis-server
   ...
   ^Z
   [4]+  Stopped                 redis-server
   ```

7. Запросить фоновые процессы - **jobs**。

   ```Shell
   [root ~]# jobs
   [2]   Running                 mongod &
   [3]-  Stopped                 cat
   [4]+  Stopped                 redis-server
   ```

8. Позвольте процессу продолжить работу в фоновом режиме - **bg**。

   ```Shell
   [root ~]# bg %4
   [4]+ redis-server &
   [root ~]# jobs
   [2]   Running                 mongod &
   [3]+  Stopped                 cat
   [4]-  Running                 redis-server &
   ```

9. Поместите фоновый процесс на передний план - **fg**。

    ```Shell
    [root ~]# fg %4
    redis-server
    ```

    > Описание: процесс, помещенный на передний план, можно использовать Ctrl+Cдля его завершения

10. Настройте приоритет времени выполнения программы / процесса - **nice** / **renice**。

11. Процесс продолжает работу после того, как пользователь входит OUT - **nohup**。

     ```Shell
     [root ~]# nohup ping www.baidu.com > result.txt &
     ```

12. Системные вызовы процессов отслеживания - **strace**。

     ```Shell
     [root ~]# pgrep mysqld
     8803
     [root ~]# strace -c -p 8803
     strace: Process 8803 attached
     ^Cstrace: Process 8803 detached
     % time     seconds  usecs/call     calls    errors syscall
     ------ ----------- ----------- --------- --------- ----------------
      99.18    0.005719        5719         1           restart_syscall
       0.49    0.000028          28         1           mprotect
       0.24    0.000014          14         1           clone
       0.05    0.000003           3         1           mmap
       0.03    0.000002           2         1           accept
     ------ ----------- ----------- --------- --------- ----------------
     100.00    0.005766                     5           total
     ```

     > Примечание: использование и параметры этой команды более сложны. Рекомендуется, чтобы вы понимали это в 
    > соответствии с реальными потребностями, когда вы действительно используете эту команду. 
13. Просмотр текущего уровня выполнения - **runlevel**。

     ```Shell
     [root ~]# runlevel
     N 3
     ```

14. Мониторинг загруженности ресурсов в режиме реального времени  - **top**。

     ```Shell
     [root ~]# top
     top - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05
     Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie
     %Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
     KiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff/cache
     KiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem
     ...
     ```

     - `-c` - Отображение всего пути процесса.。
     - `-d` - Укажите интервал времени (в секундах) между двумя обновлениями.
     - `-i` - Не отображать незанятые процессы или зомби-процессы.
     - `-p` - Показать информацию об указанном процессе.

### Системная диагностика

1. Неправильная диагностика при запуске системы - **dmesg**。

2. Просмотр информации о деятельности системы - **sar**。

   ```Shell
   [root ~]# sar -u -r 5 10
   Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06/02/2019      _x86_64_        (2 CPU)
   
   06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
   06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.80
   
   06:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
   06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0
   ```

   - `-A` - Отображение рабочего состояния всех устройств (ЦП, память, диск).
   - `-u` - Отображение состояния загрузки всех процессоров.
   - `-d` - Показать использование всех дисков.
   - `-r` - Отображение использования памяти.
   - `-n` - Отображение статуса работы сети.。

3. Проверить использование памяти - **free**。

   ```Shell
   [root ~]# free
                 total        used        free      shared  buff/cache   available
   Mem:        1016168      323924      190452         356      501792      531800
   Swap:             0           0           0
   ```

4. Статистика виртуальной памяти  - **vmstat**。

   ```Shell
   [root ~]# vmstat
   procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
    r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
    2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0
   ```

5. Статистика информации о процессоре - **mpstat**。

   ```Shell
   [root ~]# mpstat
   Linux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05/30/2019      _x86_64_        (1 CPU)
   
   01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
   01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07
   ```

6. Просмотр использования памяти процессом - **pmap**。

   ```Shell
   [root ~]# ps
     PID TTY          TIME CMD
    4581 pts/0    00:00:00 bash
    5664 pts/0    00:00:00 ps
   [root ~]# pmap 4581
   4581:   -bash
   0000000000400000    884K r-x-- bash
   00000000006dc000      4K r---- bash
   00000000006dd000     36K rw--- bash
   00000000006e6000     24K rw---   [ anon ]
   0000000001de0000    400K rw---   [ anon ]
   00007f82fe805000     48K r-x-- libnss_files-2.17.so
   00007f82fe811000   2044K ----- libnss_files-2.17.so
   ...
   ```

7. Сообщать статистику ЦП и ввода-вывода устройства - **iostat**。

   ```Shell
   [root ~]# iostat
   Linux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06/26/2018      _x86_64_       (1 CPU)
   avg-cpu:  %user   %nice %system %iowait  %steal   %idle
              0.79    0.00    0.20    0.04    0.00   98.97
   Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
   vda               0.85         6.78        21.32    2106565    6623024
   vdb               0.00         0.01         0.00       2088          0
   ```

8. Показать все устройства PCI - **lspci**。

   ```Shell
   [root ~]# lspci
   00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
   00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
   00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
   00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)
   00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)
   00:02.0 VGA compatible controller: Cirrus Logic GD 5446
   00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device
   00:04.0 Communication controller: Red Hat, Inc. Virtio console
   00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device
   00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device
   00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon
   ```

9. Показывает состояние средств связи между процессами - **ipcs**。

   ```Shell
   [root ~]# ipcs
   
   ------ Message Queues --------
   key        msqid      owner      perms      used-bytes   messages    
   
   ------ Shared Memory Segments --------
   key        shmid      owner      perms      bytes      nattch     status      
   
   ------ Semaphore Arrays --------
   key        semid      owner      perms      nsems
   ```

### Программирование оболочки Shell

Как мы упоминали ранее, Shell - это приложение, которое связывает пользователя и операционную систему. Оно 
обеспечивает интерфейс (интерфейс) взаимодействия человека с компьютером, через который пользователь получает 
доступ к службам ядра операционной системы. Shell-скрипт - это программа-скрипт, написанная для Shell.Мы можем 
управлять системой через Shell-скрипт, а также можем выполнять через него файловые операции. Короче говоря, 
написание сценариев Shell должно быть стандартным навыком для людей, использующих системы Linux.

В Интернете есть много связанных с этим знаний о сценариях оболочки. Я не планирую давать исчерпывающее и 
систематическое объяснение сценариев оболочки. Мы можем получить представление о сценариях оболочки с помощью 
следующего кода.

Пример 1. Введите два целых числа m и n и вычислите результат суммы целых чисел от m до n.

```Shell
#!/usr/bin/bash
printf 'm = '
read m
printf 'n = '
read n
a=$m
sum=0
while [ $a -le $n ]
do
    sum=$[ sum + a ]
    a=$[ a + 1 ]
done
echo 'results: '$sum
```

Пример 2: Автоматически создать папку и указанное количество файлов.

```Shell
#!/usr/bin/bash
printf 'Введите имя папки: '
read dir
printf 'имя входного файла: '
read file
printf 'номер входного файла (<1000): '
read num
if [ $num -ge 1000 ]
then
    echo 'Количество файлов не может превышать 1000'
else
    if [ -e $dir -a -d $dir ]
    then
        rm -rf $dir
    else
        if [ -e $dir -a -f $dir ]
        then
            rm -f $dir
        fi
    fi
    mkdir -p $dir
    index=1
    while [ $index -le $num ]
    do
        if [ $index -lt 10 ]
        then
            pre='00'
        elif [ $index -lt 100 ]
        then
            pre='0'
        else
            pre=''
        fi
        touch $dir'/'$file'_'$pre$index
        index=$[ index + 1 ]
    done
fi
```

Пример 3. Автоматическая установка указанной версии Redis.

```Shell
#!/usr/bin/bash
install_redis() {
    if ! which redis-server > /dev/null
    then
        cd /root
        wget $1$2'.tar.gz' >> install.log
        gunzip /root/$2'.tar.gz'
        tar -xf /root/$2'.tar'
        cd /root/$2
        make >> install.log
        make install >> install.log
        echo 'установлен '
    else
        echo 'Redis уже установлен '
    fi
}

install_redis 'http://download.redis.io/releases/' $1
```

### Горячие клавиши командной строки Linux


   | горячая клавиша    | Описание функции                                                |
   |-----------------------------------------------| ------------------------------------ |
   | tab        | Автозаполнение команд или путей                                         |
   | Ctrl+a     | Переместите курсор в начало командной строки                            |
   | Ctrl+e     | Переместите курсор в конец командной строки                             |
   | Ctrl+f     | Переместите курсор на один символ вправо                                |
   | Ctrl+b     | Переместите курсор на один символ влево                                 |
   | Ctrl+k     | Вырезать символ от курсора до конца строки                              |
   | Ctrl+u     | Вырезать символ от курсора до начала строки                             |
   | Ctrl+w     | Вырезать слово перед курсором                                           |
   | Ctrl+y     | Скопируйте и вырежьте содержимое названной вырезки                      |
   | Ctrl+c     | Прервать выполнение задачи                                              |
   | Ctrl+h     | Удалить символ перед курсором                                           |
   | Ctrl+d     | Выйти из текущей командной строки                                       |
   | Ctrl+r     | Команды истории поиска                                                  |
   | Ctrl+g     | Выйти из исторического поиска команд                                    |
   | Ctrl+l     | Очистите все на экране и начните новую строку вверху экрана.            |
   | Ctrl+s     | Заблокируйте терминал, чтобы он временно не мог вводить контент         |
   | Ctrl+q     | Выход из клеммной коробки                                               |
   | Ctrl+z     | Остановить выполнение задачи в терминале и перевести ее в фоновый режим |
   | !!         | Выполнить предыдущую команду                                            |
   | !$ / Esc+. | 	Получить последний параметр предыдущей команды                        |
   | Esc+b      | Перейти к началу текущего слова                                         |
   | Esc+f      | Перейти в конец текущего слова                                          |

