## SQL и MySQL

### SQL подробно

Обычно мы можем разделить SQL на четыре категории, а именно DDL (язык определения данных), DML (язык обработки 
данных), DQL (язык запросов данных) и DCL (язык управления данными). DDL в основном используется для создания, 
удаления и изменения объектов в базе данных, таких как создание, удаление и изменение двумерных таблиц. Ключевые 
ключевые слова включают create, dropи alter; DML в основном отвечает за вставку, удаление и обновление данных, а 
также Ключевые слова включают insert, deleteи update; DQL Ответственный за запрос данных, наиболее важным ключевым 
словом является select; DCL обычно используется для предоставления и отзыва разрешений, а ключевое слово ядра - 
grantи revoke.       
> Примечание : SQL - это язык без учета регистра.Для облегчения записи и распознавания следующий SQL написан 
> строчными буквами. 

#### DDL (язык определения данных)

Давайте реализуем базу данных для системы выбора курса. SQL, показанный ниже, создает schoolбазу данных с именем 
named и пять таблиц, а именно таблицу колледжей ( tb_college), таблицу студентов ( tb_student), таблицу учителей ( 
tb_teacher), таблицу курсов ( tb_course) и таблицу записей выбора курса ( tb_record), в которой существуют отношения 
"многие-к-одному" между студентами, преподавателями и колледжем, отношения "многие-к-одному" между курсами и 
учителями и отношения "многие-ко-многим" между студентами и курсами. Запись о выборе курса table предназначен для 
поддержания связи «многие-ко-многим» между студентами и курсами. Средний стол.     
```SQL
-- Если есть база данных под названием школа, для ее удаления 
drop database if exists `school`;

-- Создание базы данных называется школой и установить набор символов по умолчанию и сортировке 
create database `school` default character set utf8mb4 collate utf8mb4_general_ci;

-- переход к школьной базе данных контекста
use `school`;

-- Основополагающие таблиц Академии 
create table `tb_college`
(
`col_id` int unsigned auto_increment comment 'нет',
`col_name` varchar(50) not null comment 'имя',
`col_intro` varchar(500) default '' comment 'введение',
primary key (`col_id`)
) engine=innodb auto_increment=1 comment 'таблица';

-- Создание таблицы студентов 
create table `tb_student`
(
`stu_id` int unsigned not null comment 'номер студента ',
`stu_name` varchar(20) not null comment 'имя',
`stu_sex` boolean default 1 not null comment 'пол',
`stu_birth` date not null comment 'Дата рождения',
`stu_addr` varchar(255) default '' comment 'происхождение',
`col_id` int unsigned not null comment 'принадлежит',
primary key (`stu_id`),
constraint `fk_student_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)
) engine=innodb comment 'Таблица учеников';

-- создать  таблицу учитель
create table `tb_teacher`
(
`tea_id` int unsigned not null comment 'номер задания ',
`tea_name` varchar(20) not null comment 'имя',
`tea_title` varchar(10) default '助教' comment 'название',
`col_id` int unsigned not null comment 'принадлежит школе',
primary key (`tea_id`),
constraint `fk_teacher_col_id` foreign key (`col_id`) references `tb_college` (`col_id`)
) engine=innodb comment 'таблица учителя ';

-- Создание учебного плана 
create table `tb_course`
(
`cou_id` int unsigned not null comment 'нет',
`cou_name` varchar(50) not null comment 'имя',
`cou_credit` int not null comment 'кредит',
`tea_id` int unsigned not null comment 'инструктор',
primary key (`cou_id`),
constraint `fk_course_tea_id` foreign key (`tea_id`) references `tb_teacher` (`tea_id`)
) engine=innodb comment 'расписание';

-- Создание регистрации записи листа
create table `tb_record`
(
`rec_id` bigint unsigned auto_increment comment 'регистрации номер записи',
`stu_id` int unsigned not null comment 'номер студента',
`cou_id` int unsigned not null comment 'Курс ID',
`sel_date` date not null comment 'регистрации даты',
`score` decimal(4,1) comment 'тесты',
primary key (`rec_id`),
constraint `fk_record_stu_id` foreign key (`stu_id`) references `tb_student` (`stu_id`),
constraint `fk_record_cou_id` foreign key (`cou_id`) references `tb_course` (`cou_id`),
constraint `uk_record_stu_cou` unique (`stu_id`, `cou_id`)
) engine=innodb comment 'таблица регистрационных записей';
```

В приведенном выше DDL есть несколько моментов, на которые следует обратить внимание:

- При создании базы данных мы default character set utf8mb4указали набор символов по умолчанию, используемый базой 
  данных, как utf8mb4( кодирование самого большого 4байта utf-8). Мы рекомендуем использовать этот набор символов. 
  Это также набор символов, используемый MySQL 8.x по умолчанию, поскольку он может поддерживать международная 
  кодировка. Также можно сохранять символы эмодзи. Вы можете использовать следующую команду, чтобы просмотреть набор 
  символов, поддерживаемый MySQL, и параметры сортировки по умолчанию.    

  ```SQL
  show character set;
  ```

  ```
  +----------+---------------------------------+---------------------+--------+
  | Charset  | Description                     | Default collation   | Maxlen |
  +----------+---------------------------------+---------------------+--------+
  | big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |
  | dec8     | DEC West European               | dec8_swedish_ci     |      1 |
  | cp850    | DOS West European               | cp850_general_ci    |      1 |
  | hp8      | HP West European                | hp8_english_ci      |      1 |
  | koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 |
  | latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
  | latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |
  | swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 |
  | ascii    | US ASCII                        | ascii_general_ci    |      1 |
  | ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 |
  | sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 |
  | hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 |
  | tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 |
  | euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 |
  | koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 |
  | gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
  | greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 |
  | cp1250   | Windows Central European        | cp1250_general_ci   |      1 |
  | gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
  | latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |
  | armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
  | utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
  | ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |
  | cp866    | DOS Russian                     | cp866_general_ci    |      1 |
  | keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 |
  | macce    | Mac Central European            | macce_general_ci    |      1 |
  | macroman | Mac West European               | macroman_general_ci |      1 |
  | cp852    | DOS Central European            | cp852_general_ci    |      1 |
  | latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |
  | utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
  | cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 |
  | utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
  | utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |
  | cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 |
  | cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 |
  | utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
  | binary   | Binary pseudo charset           | binary              |      1 |
  | geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 |
  | cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 |
  | eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 |
  | gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |
  +----------+---------------------------------+---------------------+--------+
  41 rows in set (0.00 sec)
  ```

  Если вы хотите установить набор символов по умолчанию, используемый при запуске службы MySQL, вы можете изменить 
  конфигурацию MySQL и добавить следующее содержимое. 

  ```INI
  [mysqld]
  character-set-server=utf8
  ```

- При создании таблицы вы можете самостоятельно выбрать базовый механизм хранения. MySQL поддерживает несколько 
  механизмов хранения, которые можно просматривать с помощью show engines команд. Механизм хранения по умолчанию, 
  используемый MySQL 5.5 или более поздней версии - это InnoDB, который является механизмом хранения, который мы 
  рекомендуем использовать всем (потому что он больше подходит для текущих Интернет-приложений для требований 
  высокого параллелизма, производительности и поддержки транзакций), для обратной совместимости Операторы SQL. Мы 
  можем engine=innodb указать использование механизма хранения InnoDB , передав закрывающую скобку в конце оператора 
  построения таблицы.      
  ```SQL
  show engines\G
  ```

  ```
  *************************** 1. row ***************************
        Engine: InnoDB
       Support: DEFAULT
       Comment: Supports transactions, row-level locking, and foreign keys
  Transactions: YES
            XA: YES
    Savepoints: YES
  *************************** 2. row ***************************
        Engine: MRG_MYISAM
       Support: YES
       Comment: Collection of identical MyISAM tables
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 3. row ***************************
        Engine: MEMORY
       Support: YES
       Comment: Hash based, stored in memory, useful for temporary tables
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 4. row ***************************
        Engine: BLACKHOLE
       Support: YES
       Comment: /dev/null storage engine (anything you write to it disappears)
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 5. row ***************************
        Engine: MyISAM
       Support: YES
       Comment: MyISAM storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 6. row ***************************
        Engine: CSV
       Support: YES
       Comment: CSV storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 7. row ***************************
        Engine: ARCHIVE
       Support: YES
       Comment: Archive storage engine
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 8. row ***************************
        Engine: PERFORMANCE_SCHEMA
       Support: YES
       Comment: Performance Schema
  Transactions: NO
            XA: NO
    Savepoints: NO
  *************************** 9. row ***************************
        Engine: FEDERATED
       Support: NO
       Comment: Federated MySQL storage engine
  Transactions: NULL
            XA: NULL
    Savepoints: NULL
  9 rows in set (0.00 sec)
  ```


- При определении структуры таблицы для выбора типа данных для каждого поля, если вы не знаете, какой тип данных 
  более подходит, вы можете использовать справочную систему MySQL, чтобы узнать о характеристиках каждого типа 
  данных, длине и точности данные и другая сопутствующая информация.  
  ```SQL
  ? data types
  ```

  ```
  You asked for help about help category: "Data Types"
  For more information, type 'help <item>', where <item> is one of the following
  topics:
     AUTO_INCREMENT
     BIGINT
     BINARY
     BIT
     BLOB
     BLOB DATA TYPE
     BOOLEAN
     CHAR
     CHAR BYTE
     DATE
     DATETIME
     DEC
     DECIMAL
     DOUBLE
     DOUBLE PRECISION
     ENUM
     FLOAT
     INT
     INTEGER
     LONGBLOB
     LONGTEXT
     MEDIUMBLOB
     MEDIUMINT
     MEDIUMTEXT
     SET DATA TYPE
     SMALLINT
     TEXT
     TIME
     TIMESTAMP
     TINYBLOB
     TINYINT
     TINYTEXT
     VARBINARY
     VARCHAR
     YEAR DATA TYPE
  ```

  ```SQL
  ? varchar
  ```

  ```
  Name: 'VARCHAR'
  Description:
  [NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATE
  collation_name]
  
  A variable-length string. M represents the maximum column length in
  characters. The range of M is 0 to 65,535. The effective maximum length
  of a VARCHAR is subject to the maximum row size (65,535 bytes, which is
  shared among all columns) and the character set used. For example, utf8
  characters can require up to three bytes per character, so a VARCHAR
  column that uses the utf8 character set can be declared to be a maximum
  of 21,844 characters. See
  http://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.
  
  MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plus
  data. The length prefix indicates the number of bytes in the value. A
  VARCHAR column uses one length byte if values require no more than 255
  bytes, two length bytes if values may require more than 255 bytes.
  
  *Note*:
  
  MySQL follows the standard SQL specification, and does not remove
  trailing spaces from VARCHAR values.
  
  VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the
  standard SQL way to define that a VARCHAR column should use some
  predefined character set. MySQL uses utf8 as this predefined character
  set. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.
  NVARCHAR is shorthand for NATIONAL VARCHAR.
  
  URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html
  ```

  В выбранных типах данных обычно используются сохраненные строковые данные VARCHAR и CHAR два типа, первый обычно 
  называется строками переменной длины, второй обычно называется строкой фиксированной длины; механизм хранения 
  InnoDB для формата хранения строк не различает фиксированные length И столбцы переменной длины, поэтому нет 
  существенной разницы между VARCHAR типом и CHAR типом. Последний не обязательно лучше первого. Если вы хотите 
  сохранить очень большую строку, вы можете использовать TEXT тип; если вы хотите сохранить очень большую байтовую 
  строку, вы можете использовать BLOB тип (большой двоичный объект). В MySQL, TEXT и BLOB они включают в себя TEXT, 
  MEDIUMTEXT, LONGTEXT и BLOB, MEDIUMBLOB, LONGBLOB три различных типа, их основное отличие состоит максимальный 
  размер хранимых данных. Вы можете использовать тип FLOAT или DOUBLE для хранения чисел с плавающей запятой , что 
  FLOAT больше не рекомендуется и может быть удалено в последующих версиях MySQL. DECIMAL Тип следует использовать для 
  сохранения чисел с фиксированной запятой. Если вы хотите сохранить время и дату, DATETIME тип лучше, чем 
  TIMESTAMP тип, потому что первый может представлять больший диапазон времени и даты.           

#### DML (язык манипулирования данными)

Мы добавляем данные в таблицу, созданную выше, с помощью SQL, показанного ниже.

```SQL
use school;

-- вставка колледжа данных 
insert into `tb_college` 
    (`col_name`, `col_intro`) 
values 
    (( ' Школа компьютерных наук ' , " Computer Science, созданная в 1958 году, компьютерные науки, была создана в 1981 году кафедрой вычислительной техники, информатики, создана в 1998, 2005 гг. В мае, в целях дальнейшей интеграции учебных и научно-исследовательских ресурсов, школа решила объединить административные группы Школы компьютерных наук и Школы программного обеспечения для единой работы и реализовать модель независимой работы обучения. и управление учащимися.В школе есть три отдела: Департамент компьютерных наук и технологий, Департамент инженерии Интернета вещей, Департамент вычислительных финансов; два научно-исследовательских института: Исследовательский институт изображения и графики, Исследовательский институт безопасности киберпространства (основан в 2015 году); три учебно-экспериментальные центры: Computer Basic Teaching and Experiment Center, IBM Technology Center и Computer Professional Experiment Center. ' ),
    ( « Школа иностранных языков » , « Колледж иностранных языков имеет 7 учебных единиц, 6 специальностей бакалавриата, сочетающих гуманитарные и естественные науки; 1 балл для присвоения докторской степени по дисциплине первого уровня, 3 балла для присвоения докторской степени по дисциплинам второго уровня и 5 магистры дисциплин первого уровня, 5 баллов для получения степени магистра по дисциплинам второго уровня, 5 областей профессиональной авторизации магистров и 2 специальности для получения профессиональной степени магистра (MTI); насчитывается более 210 преподавателей, в том числе более 80 профессоров и доцентов профессора, среди учителей доля преподавателей с докторской степенью и на рабочем месте степень доктора философии в престижных университетах в Китае и за рубежом приходится более 60% штатных преподавателей. ' ),
    ( « Школа экономики и менеджмента » , « Предшественником Школы экономики был экономический факультет, основанный в 1905 году; покойные экономисты Пэн Диксянь, Чжан Юцзю, Цзян Сюэмо, Ху Цзичуан, Тао Дайонг, Ху Дайгуан и современный ученый Лю Шибай последовательно учил здесь или Учись. ' );

-- вставляя данные студентов 
insert into `tb_student` 
    (`stu_id`, `stu_name`, `stu_sex`, `stu_birth`, `stu_addr`, `col_id`) 
values
    ( 1001 , ' Иван ' , 1 , ' 1990-3 - 4 ' , ' Минск ' , 1 ),
    ( 1002 , ' Саша ' , 1 , ' 1992-2-2 ' , ' Магилев ' , 1 ),
    ( 1033 , ' Лиза ' , 0 , ' 1989-12-3 ' , ' Гродно ' , 1 ),
    ( 1572 , ' Борис ' , 1 , ' 1993-7-19 ' , ' Брест ' , 1 ),
    ( 1378 , ' Яна ' , 0 , ' 1995-8-12 ' , ' Витебск ' , 1 ),
    ( 1954 , « Костя » , 1 , « 1994-9-20 » , « Гомель » , 1 ),
    ( 2035 , ' Женя ' , . 1 , ' 1988-6-30 ' , Минск , 2 ),
    ( 3011 , ' Руслан ' , 1 , ' 1985-12-12 ' , ' Киев ' , 3 ),
    ( 3755 , « Степан » , 1 , « 1993-1-25 » , « Гданьск » , 3 ),
    ( 3923 , « Юля » , 0 , « 1985-4-17 » , « Рим » , 3 );

-- вставки данных учитель 
insert into `tb_teacher` 
    (`tea_id`, `tea_name`, `tea_title`, `col_id`) 
values 
     ( 1122 , " Волков ' ' профессор " , 1 ),
    ( 1133 , « Зверев » , « доцент » , 1 ),
    ( 1144 , ' Орлов ' , ' доцент ' , 1 ),
    ( 2255 , « Зайцев » , « доцент » , 2 ),
    ( 3366 , « Барсуков » , по умолчанию, 3 );

-- - вставка данных конечно 
insert into `tb_course` 
    (`cou_id`, `cou_name`, `cou_credit`, `tea_id`) 
values 
    ( 1111 , ' программирования Python ' , 3 , 1122 ),
    ( 2222 , ' Веб-интерфейсная разработка ' , 2 , 1122 ),
    ( 3333 , ' операционная система ' , 4 , 1122 ),
    ( 4444 , ' компьютерная сеть ' , 2 , 1133 ),
    ( 5555 , ' Принцип компиляции ' , 4 , 1144 ),
    ( 6666 , ' Алгоритм и структура данных ' , 3 , 1144 ),
    ( 7777 , « Французский язык для экономики и торговли » , 3 , 2255 ),
    ( 8888 , « Учет затрат » , 2 , 3366 ),
    ( 9999 , « Аудит » , 3 , 3366 );

-- вставка курса данных 
insert into `tb_record` 
    (`stu_id`, `cou_id`, `sel_date`, `score`) 
values 
    (1001, 1111, '2017-09-01', 95),
    (1001, 2222, '2017-09-01', 87.5),
    (1001, 3333, '2017-09-01', 100),
    (1001, 4444, '2018-09-03', null),
    (1001, 6666, '2017-09-02', 100),
    (1002, 1111, '2017-09-03', 65),
    (1002, 5555, '2017-09-01', 42),
    (1033, 1111, '2017-09-03', 92.5),
    (1033, 4444, '2017-09-01', 78),
    (1033, 5555, '2017-09-01', 82.5),
    (1572, 1111, '2017-09-02', 78),
    (1378, 1111, '2017-09-05', 82),
    (1378, 7777, '2017-09-02', 65.5),
    (2035, 7777, '2018-09-03', 88),
    (2035, 9999, '2019-09-02', null),
    (3755, 1111, '2019-09-02', null),
    (3755, 8888, '2019-09-02', null),
    (3755, 9999, '2017-09-01', 92);
```

> Примечание. Приведенный выше insertоператор использует пакетную обработку для вставки данных, что более 
> эффективно для вставки данных. 

#### DQL(язык запросов данных)

Затем мы выполняем запрос, показанный ниже.

```SQL
-- Запрос всю информацию всех студентов 
select * from `tb_student`;

-- Запрос студент номер, имя и место происхождения (проекции) 
select `stu_id`, `stu_name`, `stu_addr` from `tb_student`;

-- название запроса и кредит для всех курсов (проекционных и псевдонимы) 
select `cou_name` as 课程名称, `cou_credit` as 学分 from `tb_course`;

-- Запрос имени всех женщин , студента и дата рождения (скрининг) 
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0;

-- Запрос по месту происхождения "в Чэнду, Сычуань," имя женского студента и дата рождения (скрининг)
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 and `stu_addr`='四川成都';

-- Запрос уроженец "Чэнду" или пола , как "женские" студентов 
select `stu_name`, `stu_birth` from `tb_student` where `stu_sex`=0 or `stu_addr`='四川成都';

-- Поиск 80 после того, как имя студента, пол и дата рождения (скрининг) 
select `stu_name`, `stu_sex`, `stu_birth` from `tb_student` 
where `stu_birth`>='1980-1-1' and `stu_birth`<='1989-12-31';

select `stu_name`, `stu_sex`, `stu_birth` from `tb_student` 
where `stu_birth` between '1980-1-1' and '1989-12-31';

-- Добавлено: представление пола и нулей перерабатывается в «мужской» и «женский» 
select 
    `stu_name` as имя, 
    if(`stu_sex`, 'мужчина', 'женщина') as пол, 
    `stu_birth` as дата рождения
from `tb_student` 
where `stu_birth` between '1980-1-1' and '1989-12-31';

select 
    `stu_name` as имя, 
    case `stu_sex` when 1 then 'мужчина' else 'женщина' end as пол, 
    `stu_birth` as дата рождения
from `tb_student` 
where `stu_birth` between '1980-1-1' and '1989-12-31';

-- имя запроса и кредитные курсы кредитов больше , чем 2 (скрининг) 
select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`>2;

-- Запрос кредитной курс нечетные имена и кредиты (скрининга)
select `cou_name`, `cou_credit` from `tb_course` where `cou_credit`%2<>0;

select `cou_name`, `cou_credit` from `tb_course` where `cou_credit` mod 2<>0;

-- выбирает запрос выбрал курс 1111 тестов более чем на 90 пунктов студенческий номер (скрининг) 
select `stu_id` from `tb_record` where `cou_id`=1111 and `score`>90;

-- Запрос название «Иванов,» имя студента и пол 
select `stu_name`, `stu_sex` from `tb_student` where `stu_name`='Иванов';
    
-- Запрос фамилия «Петров,» имя студента и пол (помутнение) 
-- % - групповой символ (подстановочные), он может соответствовать 0 или любое количество символов 
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'Петров%';

-- Запрос фамилия «Петров» слово из названия имени студента и пола (размытого) 
-- _ - подстановочный (подстановочный), он может точно соответствовать характеру 
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'Петров';

-- фамилия имя запроса «Петров» во имя имени и пола студента (размытости)
select `stu_name`, `stu_sex` from `tb_student` where `stu_name` like 'Петров__';

-- Запрос имя студента «нет» или «Петров» имена слов (размытости) 
select `stu_name` from `tb_student` where `stu_name` like '%Иванов%' or `stu_name` like '%Петров%';

-- "Сидоров" переименована в "Петров", следующее сравнение разницы между этими двумя запросами
update `tb_student` set `stu_name`='Сидоров' where `stu_id`=1572;

select `stu_name` from `tb_student` where `stu_name` like '%Петров%'
union 
select `stu_name` from `tb_student` where `stu_name` like '%Сидоров%';

select `stu_name` from `tb_student` where `stu_name` like '%Петров%'
union all 
select `stu_name` from `tb_student` where `stu_name` like '%Сидоров%';

-- Запрос фамилия «Иванов» или фамилию во имя ученика, «лес» Имя (регулярные выражения Fuzzy запросов) 
select `stu_name` from `tb_student` where `stu_name` regexp '[Иванов].{2}';

--  запрос чьи имена без указания адреса (нулеваое значение)
select `stu_name` from `tb_student` where `stu_addr` is null;

select `stu_name` from `tb_student` where `stu_addr` <=> null;

-- запрос чьи имена с указанием адреса (не нулеваое значение)
select `stu_name` from `tb_student` where `stu_addr` is not null;

-- запрос чьи имена с указанием адреса (могут принять значения --> true / false / unknown)
select `stu_name` from `tb_student` where `stu_addr`=null or `stu_addr`<>null;

-- Запрос студент зачисление всех дат (дедупликации) 
select distinct `sel_date` from `tb_record`;

-- Запрос студентов Место рождения (дедупликации)
select distinct `stu_addr` from `tb_student` where `stu_addr` is not null;

-- имя запроса студента мужского пола и даты рождения по возрасту в порядке (СНП) по убыванию 
-- по возрастанию: от мало до велика - по возрастанию, в порядке убывания: от большого к малому - убыванию 

select `stu_id`, `stu_name`, `stu_birth` from `tb_student` 
where `stu_sex`=1 order by `stu_birth` asc, `stu_id` desc;

-- Добавлено: Вышеуказанные условия возраста, даты рождения (дата функции, числовые функции) 
select 
    `stu_id` as число студентов,
    `stu_name` as имя, 
    floor(datediff(curdate(), `stu_birth`)/365) as возраст
from `tb_student` 
where `stu_sex`=1 order by возраст desc, `stu_id` desc;

-- Запрос дата рождения старейшего студента (агрегатная функция) 
select min(`stu_birth`) from `tb_student`;

-- Запрос дата рождения младшего студента (агрегатная функция) 
select max(`stu_birth`) from `tb_student`;

-- число запросов самый высокий балл тестов , конечно десятки 1111 (агрегатной функции)
select max(`score`) from `tb_record` where `cou_id`=1111;

-- Запрос номер студент низкий класс тест баллы 1001 (агрегатной функции)
select min(`score`) from `tb_record` where `stu_id`=1001;

--  Запрос номер студента для средних тестов студент десятки 1001 (агрегатной функции) 
select avg(`score`) from `tb_record` where `stu_id`=1001;

select sum(`score`) / count(`score`) from `tb_record` where `stu_id`=1001;

-- Запрос номер студента для средних тестов студент десятки 1001, если есть нулевое значение, счетчик нулевое значение 0 (агрегатной функции) 
select sum(`score`) / count(*) from `tb_record` where `stu_id`=1001;

select avg(ifnull(`score`, 0)) from `tb_record` where `stu_id`=1001;

-- Запрос студента количество тестовых баллов студента как 1001 стандартное отклонение (агрегатной функции)
select std(`score`), variance(`score`) from `tb_record` where `stu_id`=1001;

-- Количество (группировка и агрегатные функции) запросов мужчин и женщин студентов 
select 
    case `stu_sex` when 1 then 'мужчина' else 'женщина' end as пол,
    count(*) as число
from `tb_student` group by `stu_sex`;

-- количество запросов (группировка и агрегатные функции) студенты каждого колледжа 
select 
    `col_id` as колледж,
    count(*) as число
from `tb_student` group by `col_id` with rollup;

-- количество запросов мужчин и женщин студентов в каждом колледже (группировка и агрегатных функций) 

select 
    `col_id` as колледж,
    if(`stu_sex`, 'мужской', 'женский') as пол,
    count(*) as число
from `tb_student` group by `col_id`, `stu_sex`;

-- для каждого студента номер школы и среднего балла (группировка и агрегатные функции) запрос
select 
    `stu_id`, 
    round(avg(`score`), 1) as avg_score
from `tb_record` group by `stu_id`;

-- запрос средний балл 90 баллов или большее число студентов и точка класса школы , в среднем 
-- фильтр пакетов перед использованием, где положение, после того , как дизъюнкцию фильтрация пакетов с помощью 

select 
    `stu_id`, 
    round(avg(`score`), 1) as avg_score
from `tb_record`
group by `stu_id` having avg_score>=90;

-- Запрос 1111,2222,3333 три курсы средний балл 90 баллов или большее количество студентов в школе и средний балл 

select 
    `stu_id`, 
    round(avg(`score`), 1) as avg_score
from `tb_record` where `cou_id` in (1111, 2222, 3333)
group by `stu_id` having avg_score>=90;

-- Запрос имя старейшего студента (подзапрос / вложенный запрос) 
-- вложенный запрос: результаты выбора в качестве части другого выбора для использования 
select `stu_name` from `tb_student` 
where `stu_birth`=(
    select min(`stu_birth`) from `tb_student`
);

-- Запрос выбрал более двух курсов имя студента (подзапрос / группирование условие / операция сбора)
select `stu_name` from `tb_student` 
where `stu_id` in (
    select `stu_id` from `tb_record` 
    group by `stu_id` having count(*)>2
);

-- имя студента Query, дату рождения и имя колледжа , где 
select `stu_name`, `stu_birth`, `col_name` 
from `tb_student`, `tb_college` 
where `tb_student`.`col_id`=`tb_college`.`col_id`;

select `stu_name`, `stu_birth`, `col_name` 
from `tb_student` inner join `tb_college` 
on `tb_student`.`col_id`=`tb_college`.`col_id`;

select `stu_name`, `stu_birth`, `col_name` 
from `tb_student` natural join `tb_college`;

-- запрос имя, название курса студента и достижения (присоединиться запрос / присоединиться к запросу)
select `stu_name`, `cou_name`, `score` 
from `tb_student`, `tb_course`, `tb_record` 
where `tb_student`.`stu_id`=`tb_record`.`stu_id` 
and `tb_course`.`cou_id`=`tb_record`.`cou_id` 
and `score` is not null;

select `stu_name`, `cou_name`, `score` from `tb_student` 
inner join `tb_record` on `tb_student`.`stu_id`=`tb_record`.`stu_id` 
inner join `tb_course` on `tb_course`.`cou_id`=`tb_record`.`cou_id` 
where `score` is not null;

select `stu_name`, `cou_name`, `score` from `tb_student` 
natural join `tb_record` 
natural join `tb_course`
where `score` is not null;

-- Примечание: Приведенные выше результаты запроса от прежних пяти данных (пейджинг запросов) 
select `stu_name`, `cou_name`, `score` 
from `tb_student`, `tb_course`, `tb_record` 
where `tb_student`.`stu_id`=`tb_record`.`stu_id` 
and `tb_course`.`cou_id`=`tb_record`.`cou_id` 
and `score` is not null 
order by `score` desc 
limit 0,5;

-- Примечание: Результат выше запроса 6-10 принимают первые данные (пейджинг запроса) 
select `stu_name`, `cou_name`, `score` 
from `tb_student`, `tb_course`, `tb_record` 
where `tb_student`.`stu_id`=`tb_record`.`stu_id` 
and `tb_course`.`cou_id`=`tb_record`.`cou_id` 
and `score` is not null 
order by `score` desc 
limit 5 offset 5;

-- Примечание: Указанный выше результат запроса данных , принятых 11-15 (поискового вызова запроса)
select `stu_name`, `cou_name`, `score` 
from `tb_student`, `tb_course`, `tb_record` 
where `tb_student`.`stu_id`=`tb_record`.`stu_id` 
and `tb_course`.`cou_id`=`tb_record`.`cou_id` 
and `score` is not null 
order by `score` desc 
limit 5 offset 10;

-- Запрос имя и средний балл элективных студента (подзапросы и присоединиться запросы) 
select `stu_name`, `avg_score` 
from `tb_student` inner join (
    select `stu_id` as `sid`, round(avg(`score`), 1) as avg_score 
    from `tb_record` group by `stu_id`
) as `t2` on `stu_id`=`sid`;

-- Запрос имя студента и зачисление количества
select `stu_name`, `total` from `tb_student` as `t1`
inner join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- запросить имя каждого учащегося и количество факультативов (левые внешние соединения и подзапросы) 
-- левое внешнее соединение: левая таблица (написанная слева, присоединяется к таблице) каждой записи может быть 
извлечена, таблица не соответствует даже местные условия Заполните нулем. 

select `stu_name`, coalesce(`total`, 0) as `total`
from `tb_student` as `t1`
left outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- изменить регистрационную запись таблицы удалить столбец ключа ограничения внешнего stu_id 
alter table `tb_record` drop foreign key `fk_record_stu_id`;

-- вставка двух новых записей (Примечание: Там нет школы No. 5566 студентов)
insert into `tb_record` 
values
    (default, 5566, 1111, '2019-09-02', 80),
    (default, 5566, 2222, '2019-09-02', 70);

-- правое внешнее соединение: правая таблица (написанная справа от таблицы соединения) каждой записи может быть 
извлечена, условия не выполняются, даже если таблица заполнена нулем. 
select `stu_name`, `total` from `tb_student` as `t1`
right outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;

-- полное внешнее соединение: левая таблица и правая таблица для каждой записи могут быть извлечены, условия не 
выполняются, даже если таблица заполнена нулем. 
- Описание: MySQL не поддерживает полные внешние соединения, поэтому используйте левое внешнее соединение и правое 
внешнее соединение и установите для представления.  
select `stu_name`, `total`
from `tb_student` as `t1`
left outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`
union 
select `stu_name`, `total` from `tb_student` as `t1`
right outer join (
    select `stu_id`, count(*) as `total`
    from `tb_record` group by `stu_id`
) as `t2` on `t1`.`stu_id`=`t2`.`stu_id`;
```

В приведенном выше DML есть несколько моментов, которые необходимо пояснить:

1. Текущая версия MySQL не поддерживает полные внешние соединения. Выше мы использовали union операцию для 
   объединения результатов левых внешних соединений и правых внешних соединений для достижения эффекта полных 
   внешних соединений. Вы можете использовать приведенную ниже схему, чтобы углубить свое понимание операции соединения таблиц 

2. MySQL поддерживает несколько типов операторов, включающие: арифметические операторы +( -, *, /, %,), операторы 
   сравнения =( <>, <=>, <, <=, >, >=,, .,BETWEEN...AND.. , , , , ,), Логические операторы ( , , ,) и битовые 
   операторы ( , , , , ,), мы можем использовать операторы обработки данных в DML.INIS NULLIS NOT 
   NULLLIKERLIKEREGEXPNOTANDORXOR&|^~>><<    
3. При запросе данных вы можете использовать функции в SELECTоператорах и их предложениях (например, WHEREпредложениях, ORDER BYпредложениях, HAVINGпредложениях и т. Д.). Эти функции включают строковые функции, числовые функции, функции времени и даты, функции обработки и т. Д., Как показано в Показана следующая таблица.

Часто используемые строковые функции.

   | функция                       | значение                    |
   |-----------------------------| ----------------------------------------------------- |
   | `CONCAT`                    | Объедините несколько строк в одну строку             |
   | `FORMAT`                    | Отформатируйте значение в строку и укажите несколько десятичных знаков         |
   | `FROM_BASE64` / `TO_BASE64` | BASE64 декодирование / кодирование                |
   | `BIN` / `OCT` / `HEX`       | Преобразование числового значения в двоичную / восьмеричную / шестнадцатеричную строку     |
   | `LOCATE`                    | 	Найдите позицию подстроки в строке              |
   | `LEFT` / `RIGHT`            | Возвращает символ указанной длины слева / справа от строки         |
   | `LENGTH` / `CHAR_LENGTH`    | Вернуть длину строки в байтах / символах          |
   | `LOWER` / `UPPER`           | 	Возвращает строчную / прописную форму строки              |
   | `LPAD` / `RPAD`             | Если длина строки недостаточна, заполните указанные символы слева / справа от строки |
   | `LTRIM` / `RTRIM`           | Удалите пробелы до / после строки               |
   | `ORD` / `CHAR`              | Возвращает код, соответствующий символу / возвращает символ, соответствующий коду         |
   | `STRCMP`                    | Сравнить строки, вернуть -1, 0, 1 для значений меньше, равно и больше  |
   | `SUBSTRING`                 | Возвращает подстроку указанного диапазона строки               |

Часто используемые числовые функции.

   | функция                                                        | значение                               |
----------------------------------------------------------| -------------------------------------------------------- | ---------------------------------- |
   | `ABS`                                                    | Возвращает абсолютное значение числа.                |
   | `CEILING` / `FLOOR`                                      | Возвращает результат округления числа в большую или меньшую сторону.      |
   | `CONV`                                                   | Преобразование числа из одной базы в другую |
   | `CRC32`                                                  | Вычислить код проверки циклическим избыточным кодом                |
   | `EXP` / `LOG` / `LOG2` / `LOG10`                         | Вычислить экспоненту / логарифм                     |
   | `POW`                                                    | 	Возведение в степень                               |
   | `RAND`                                                   | 	Возвращает случайное число в диапазоне [0,1).             |
   | `ROUND`                                                  | 	Возвращает результат округленного числа.        |
   | `SQRT`                                                   | Возвращает квадратный корень числа.                 |
   | `TRUNCATE`                                               | 	Обрезать число до указанной точности             |
   | `SIN` / `COS` / `TAN` / `COT` / `ASIN` / `ACOS` / `ATAN` | 	Тригонометрическая функция                          |

   Часто используемые функции времени и даты.

   | функция                             | значение                                  |
-------------------------------| ----------------------------- | ------------------------------------- |
   | `CURDATE` / `CURTIME` / `NOW` | Получить текущую дату / время / дату и время         |
   | `ADDDATE` / `SUBDATE`         | Сложить / вычесть два выражения даты и вернуть результат  |
   | `DATE` / `TIME`               | Получить дату / время из строки               |
   | `YEAR` / `MONTH` / `DAY`      | Получить год / месяц / день от даты                 |
   | `HOUR` / `MINUTE` / `SECOND`  | Получить час / минуту / секунду от времени                 |
   | `DATEDIFF` / `TIMEDIFF`       | Возвращает, сколько дней / часов разницы между двумя выражениями времени и даты |
   | `MAKEDATE` / `MAKETIME`       | Сделайте дату / время                    |

  Общие функции процесса

   | функция        | значение                                             |
----------| -------- | ------------------------------------------------ |
   | `IF`     | Возвращать разные значения в зависимости от того, выполняется ли условие                    |
   | `IFNULL` | Если это NULL, вернуть указанное значение, иначе вернуть себя          |
   | `NULLIF` | Если два выражения равны, вернуть NULL, в противном случае вернуть значение первого выражения |

  Другие часто используемые функции.

   | функция                          | значение                          |
----------------------------| -------------------------- | ----------------------------- |
   | `MD5` / `SHA1` / `SHA2`    | Возвращает хеш-дайджест, соответствующий строке      |
   | `CHARSET` / `COLLATION`    | 	Вернуться к правилам набора символов / корректуры          |
   | `USER` / `CURRENT_USER`    | 	Вернуть текущего пользователя                 |
   | `DATABASE`                 | 	Возвращает текущее имя базы данных             |
   | `VERSION`                  | Возвращает текущую версию базы данных           |
   | `FOUND_ROWS` / `ROW_COUNT` | Возвращает количество запрошенных строк / количество затронутых строк|
   | `LAST_INSERT_ID`           | 	Возвращает значение последнего автоматически увеличивающегося первичного ключа.     |
   | `UUID` / `UUID_SHORT`      | Возвращает глобальный уникальный идентификатор.           |

#### DCL（язык управления данными)

Язык управления данными используется для авторизации назначенных пользователей или отзыва назначенных им разрешений. 
Этот набор операций более важен для администраторов баз данных. Минимизация разрешений пользователя (достаточно) 
очень важна для базы данных. Ваша безопасность имеет первостепенное значение.   
```SQL
-- Создайте учетную запись с именем wangdachui и назначьте пароль, учетная запись разрешает доступ с любого хоста в 

create user 'wangdachui'@'%' identified by '123456';

-- Авторизация wangdachui может выполнить базу данных с именем школы выбора и вставки операций 

grant select, insert on `school`.* to 'wangdachui'@'%';

--отзыв wangdachui вставка разрешения на школьной базе данных 
revoke insert on `school`.* from 'wangdachui'@'%';
```

> Примечание. На самом деле создание пользователя, который может разрешить любому хосту входить в систему и иметь 
> права суперадминистратора, не является разумным решением, потому что после утечки или взлома пароля учетной записи 
> база данных столкнется с риском катастрофы.  
### MySQL подробно


Индексы являются наиболее важным средством повышения производительности запросов в реляционных базах данных. Индекс 
в реляционной базе данных похож на оглавление книги. Мы можем представить, что если мы хотим найти определенную 
точку знания из книги, но в этой книге нет оглавления, что это ужасно. было бы! По нашим оценкам, необходимо будет 
отказываться один за другим, чтобы определить, где находится эта точка знания. Хотя создание индекса приведет к 
дополнительным расходам на дисковое пространство, точно так же, как оглавление книги будет занимать часть 
пространства, но сокращение времени запроса после того, как вы пожертвовали пространством, также очень значительно.  

Столбцы всех типов данных в базе данных MySQL можно индексировать. Для механизма хранения InnoDB версии MySQL 8.0 он 
поддерживает три типа индексов, а именно индекс дерева B +, полнотекстовый индекс и индекс R-дерева. Здесь мы только 
представляем наиболее широко используемый индекс дерева B +. Причина использования B + tree очень проста, потому что 
в настоящее время это наиболее эффективная структура данных на основе диска для массового хранения и сортировки 
данных. Дерево B + - это сбалансированное дерево. Высота дерева обычно составляет 3 или 4, но оно может хранить 
данные в диапазоне от одного миллиона до одного миллиарда, и для запроса части данных из этих данных требуется всего 
3 или 4 операции ввода-вывода. 
Дерево B + состоит из корневых узлов, промежуточных узлов и конечных узлов. Листовые узлы используются для хранения 
отсортированных данных. Поскольку записи сортируются по индексу, при поиске данных в листовом узле можно 
использовать двоичный поиск. Этот метод поиска очень эффективен. Когда данных мало, дерево B + имеет только один 
корневой узел, и данные также хранятся на корневом узле. При увеличении количества записей дерево B + будет 
разделено, и корневой узел больше не сохраняет данные, а предоставляет указатель на следующий уровень узлов, чтобы 
помочь быстро определить, на каком листовом узле находятся данные.      

При создании двумерной таблицы мы обычно указываем столбец первичного ключа для таблицы. По умолчанию индексы 
создаются в столбце первичного ключа. Для механизма хранения MySQL InnoDB, потому что он использует структуру 
хранения данных таблицы, организованной по индексу. , первичный ключ. Индекс - это данные всей таблицы, и этот вид 
индекса мы также называем кластеризованным индексом (кластеризованным индексом). Очевидно, что таблица может иметь 
только один кластеризованный индекс, иначе данные таблицы придется сохранять несколько раз. Индекс - это вторичный 
индекс (вторичный индекс) для создания нашего собственного, более часто называемого некластеризованного индекса 
(некластеризованный индекс). С помощью нашего настраиваемого некластеризованного индекса можно найти только 
первичный ключ записи. При получении данных вам может потребоваться запрос через кластеризованный индекс по 
первичному ключу. Это явление называется «возвращением к таблице». Поэтому получение данных через некластеризованный 
индекс обычно лучше, чем получение данных с помощью кластеризованного индекса происходит медленно.          

Далее мы используем простой пример, чтобы проиллюстрировать значение индекса. Например, нам нужно найти студентов по 
их именам. Этот сценарий часто встречается при реальной разработке. Это то же самое, что поиск продуктов по названию 
продукта. Мы можем использовать explainключевые слова MySQL для просмотра плана выполнения SQL (конкретные шаги базы 
данных для выполнения оператора SQL).    


```SQL
explain select * from tb_student where stuname='Иванов'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

В приведенном выше плане выполнения SQL есть несколько пунктов, заслуживающих нашего внимания:

1. `select_type`：Тип запроса。
    - `SIMPLE`: Простой SELECT, без использования операций UNION или подзапросов.
    - `PRIMARY`: Если запрос содержит подзапросы, самый внешний SELECT помечается как PRIMARY.
    - `UNION`: Второй или последующий оператор SELECT в операции UNION.
    - `SUBQUERY`: Первый SELECT в подзапросе.
    - `DERIVED`: Подзапрос SELECT производной таблицы.
2. `table`: Запросить соответствующую таблицу.
3. `type`: Способ, которым MySQL находит строки, удовлетворяющие условиям в таблице, также называется типом доступа, 
    включая: ALL(полное сканирование таблицы), index(полное сканирование индекса, только обход дерева индексов), 
   range(сканирование диапазона индексов), ref(неуникальный сканирование индекса), eq_ref(сканирование уникального индекса), const/ system(запрос постоянного уровня), NULL(нет необходимости обращаться к таблицам или индексам). Среди всех типов доступа, ALL, очевидно, является худшим исполнителем.Полное сканирование таблицы, которое он представляет, означает, что каждая строка в таблице должна быть просканирована, чтобы найти соответствующую строку.
4. `possible_keys`: MySQL может выбрать индекс, но его нельзя использовать .
5. `key`: Индекс, фактически используемый MySQL. Если это так, NULLэто означает, что индекс не используется.
6. `key_len`: Длина используемого индекса, не влияющая на запрос, должна быть как можно короче.
7. `rows`: Количество строк, которые необходимо просканировать для выполнения запроса. Это приблизительное значение .
8. `extra`: О запросе дополнительной информации.

    - `Using filesort`: MySQL не может использовать индекс для завершения операции сортировки.
    - `Using index`: Используйте только информацию индекса и не нужно искать дополнительную информацию в таблице.
    - `Using temporary`: MySQL необходимо использовать временные таблицы для хранения наборов результатов, которые часто используются для группировки и сортировки.
    - `Impossible where`: Предложение where не приведет к появлению подходящих строк.
    - `Distinct`: После того, как MySQL находит первую совпадающую строку, он прекращает поиск дополнительных строк для текущей комбинации строк.
    - `Using where`: Столбец запроса не покрывается индексом, и условие фильтрации не является ведущим столбцом индекса. 

Как видно из приведенного выше плана выполнения, когда мы запрашиваем студентов по их именам, мы фактически 
выполняем полное сканирование таблицы. Само собой разумеется, что производительность этого запроса должна быть очень 
низкой, особенно когда в таблице много строк. . Если нам нужно часто запрашивать учащихся по их имени, мы должны 
создать индекс для столбца, соответствующего имени учащегося, и использовать индекс для ускорения запроса.    

```SQL
create index idx_student_name on tb_student(stuname);
```

Посмотрите еще раз на план выполнения, соответствующий SQL

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

Можно заметить, что после создания индекса по именам учащихся запрос сейчас представляет собой не полное 
сканирование таблицы, а запрос на основе индекса, а просканированная строка представляет собой только одну строку, 
что, очевидно, значительно улучшает производительность запроса. MySQL также позволяет создать индекс префикса, то 
есть создать индекс для первых N символов поля индекса, так что пространство, занимаемое индексом, может быть 
уменьшено (но экономия места, вероятно, приведет к потере времени, времени и пространства являются непримиримыми 
противоречиями ), следующим образом.     

```SQL
create index idx_student_name_1 on tb_student(stuname(1));
```

Указанный выше индекс эквивалентен индексу, созданному на основе первого слова имени студента, давайте посмотрим на 
план выполнения SQL. 

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

Я не знаю, заметили ли вы, что отсканированные на этот раз строки превратились в 2 строки, потому что в таблице студентов есть два студента с фамилией «Линь». Если мы используем только первое слово имени в качестве индекса, мы передадим индекс при запросе. Вы найдете эти две строки.

Если вы хотите удалить индекс, вы можете использовать следующий SQL.

```SQL
alter table tb_student drop index idx_student_name;
```

или

```SQL
drop index idx_student_name on tb_student;
```

При создании индексов мы также можем использовать составные индексы и функциональные индексы (поддерживаются в MySQL 5.7). Использование составных индексов для достижения покрытия индекса может уменьшить ненужные операции сортировки и возврата к таблице, что удвоит производительность запросов, заинтересованные читатели могут провести собственное исследование.

Кратко резюмируем принципы построения индекса для всех:

1. Столбцы, наиболее подходящие для индексации, - это те, которые появляются в предложении WHERE и предложении 
   соединения.
2. Чем больше мощность столбца индекса (больше значений и меньше повторяющихся значений), тем лучше эффект индекса.
3. Использование префиксного индекса может уменьшить пространство, занимаемое индексом, и больше индексов можно 
   кэшировать в памяти.
4. Индекса не так много. Хотя индекс ускоряет операцию чтения (запрос), операция записи (добавление, удаление, 
   модификация) станет медленнее, потому что изменение данных приведет к обновлению индекса, просто например, 
   добавление и удаление глав книги, то же самое для обновления каталога.
5. При использовании механизма хранения InnoDB обычный индекс таблицы сохранит значение первичного ключа , поэтому 
   первичный ключ должен выбирать более короткий тип данных, насколько это возможно , что может эффективно уменьшить пространство, занимаемое индексом, и улучшить кеш-эффект индекса.

 
И, наконец, существует мало необходимости объяснять, индекс В-дерево используются, в дополнении к индексу 
   числового столбца типа определяются за пределами контура эффекта при использовании >, <, >=, <=, BETWEEN...AND... 
   , <>, индекс остается в силе, для столбца типа строки, Если вы используете нечеткий запрос, который не начинается 
   с подстановочного знака, индекс также будет работать, но другие условия приведут к сбою индекса, что означает, 
   что, скорее всего, будет выполнен полный запрос таблицы.    


Представление - это объект в реляционной базе данных, который объединяет набор результатов, состоящий из группы инструкций запроса, в таблицу данных, доступную для запроса. Проще говоря, представление - это виртуальная таблица, но, в отличие от таблицы данных, таблица данных - это структура сущностей, а представление - это виртуальная структура. Вы также можете понимать представление как SQL, который хранится в базе данных и задается имя.

Используя представления, можно получить следующие преимущества:

1. Таблица данных объекта может быть скрыта, чтобы внешние программы не могли знать фактическую структуру данных, что 
позволяет посетителям использовать компоненты таблицы вместо всей таблицы, что снижает риск атак на базу данных.
2. В большинстве случаев представление доступно только для чтения (операция обновления представления обычно имеет 
   множество ограничений), и внешняя программа не может напрямую изменять данные через представление.
3. Повторно используйте операторы SQL, заключите очень сложные запросы в таблицу представления и получите прямой 
   доступ к представлению для извлечения необходимых данных; вы также можете просматривать представление как таблицу данных для запросов на соединение.
4. Представление может возвращать данные в формате, отличном от таблицы данных объекта, и данные могут быть 
   отформатированы при создании представления.


Создайте представление.

```SQL
-- 创建视图
create view `vw_avg_score` 
as 
    select `stu_id`, round(avg(`score`), 1) as `avg_score` 
    from `tb_record` group by `stu_id`;

-- 基于已有的视图创建视图
create view `vw_student_score` 
as 
    select `stu_name`, `avg_score` 
    from `tb_student` natural join `vw_avg_score`;
```

> Совет : поскольку представление не содержит данных, каждый раз, когда вы используете представление, вы должны 
> выполнять запрос для получения данных. Если вы создаете более сложное представление, используя запросы соединения 
> или вложенные запросы, вы можете обнаружить, что производительность запроса резко упадет. . Поэтому перед 
> использованием комплексного представления следует протестировать, чтобы убедиться, что его производительность 
> соответствует потребностям приложения.     


Используйте представления.

```SQL
select * from `vw_student_score` order by `avg_score` desc;
```

```
+--------------+----------+
| stuname      | avgscore |
+--------------+----------+
| Иванов        |     95.6 |
| Петров       |     53.5 |
| Сидоров      |     84.3 |
| Степанов     |     73.8 |
| Волков      |     78.0 |
| Зайцев     |     88.0 |
| Гоголев      |     92.0 |
+--------------+----------+
```

Поскольку представление представляет собой виртуальную таблицу, можно ли обновить данные в представлении? Возможность обновления представления зависит от конкретной ситуации. Следующие типы представлений не могут быть обновлены:

1. Используя функцию совокупного SUM( MIN, MAX, AVG,, и т.д.), , ,, или вид.COUNTDISTINCTGROUP BYHAVINGUNIONUNION ALL
2. SELECT Содержит представления подзапросов.
3. FROM Предложение содержит представление, которое не может быть обновлено.
4. WHERE Подзапрос FROMпредложения относится к представлению таблицы в предложении.


Удалить представление.

```SQL
drop view vw_student_score;
```

> Примечание : Если вы хотите обновить представление, вы можете использовать указанную выше команду, чтобы сначала 
> удалить представление, или вы можете create or replace viewобновить представление , используя команду выше.  

Ознакомьтесь с правилами и ограничениями.

1. Представления могут быть вложенными, а данные, полученные из других представлений, могут использоваться для 
создания нового представления. Представления также можно использовать с таблицами.
2. order by Предложения можно использовать при создании представления , но если они также используются при извлечении 
данных из order byпредставления, исходные в представлении order by будут перезаписаны.
3. Представление не может использовать индекс и не будет запускать выполнение триггеров (из-за соображений 
    производительности при реальной разработке триггеры обычно не рекомендуются, поэтому мы не будем вводить эту 
   концепцию).
#### функция

Слишком много различий между функциями в MySQL и функциями в Python, потому что функции используются для 
инкапсуляции кода, который относительно независим по функциям и будет использоваться повторно. Если вам нужно найти 
какие-то различия, тогда функции в MySQL могут выполнять операторы SQL. В следующем примере мы реализовали функцию 
усечения очень длинных строк с помощью настраиваемой функции.   
```SQL
delimiter $$

create function truncate_string(
    content varchar(10000),
    max_length int unsigned
) returns varchar(10000) no sql
begin
    declare result varchar(10000) default content;
    if char_length(content) > max_length then
        set result = left(content, max_length);
        set result = concat(result, '……');
    end if;
    return result;
end $$

delimiter ;
```

> *Примечание 1. За объявлением функции следует no sql объявление о том, что тело функции не использует операторы 
> SQL; если телу функции необходимо читать данные через SQL, его необходимо объявить как reads sql data.  

> Примечание 2.delimiter Команды до и после определения функции предназначены для изменения разделителя, поскольку 
операторы в теле функции используются для ;обозначения конца. Если разделитель не переопределен, ;код будет усечен и 
выполнен при обнаружении . Очевидно, что это Не тот эффект, который нам нужен.   

Вызов пользовательской функции в запросе.

```SQL
select truncate_string('Пройдитесь со мной по улицам, пока не погаснет весь свет', 10) as short_string;
```

```
+--------------------------------------+
| short_string                         |
+--------------------------------------+
| Пройдитесь со мной по улицам Чэнду, пока не погаснет весь свет             |
+--------------------------------------+
```

#### процесс

Процедура (также называемая хранимой процедурой) - это набор SQL, заранее скомпилированный и хранимый в базе данных. 
Вызывающая процедура может упростить работу разработчиков приложений, уменьшить взаимодействие с сервером базы 
данных и повысить производительность операций с данными. . Фактически, операторы SQL, которые мы использовали до сих 
пор, представляют собой отдельные операторы для одной или нескольких таблиц, но при реальной разработке мы часто 
сталкиваемся с ситуациями, когда для выполнения операции требуется несколько операторов SQL. Например, когда 
веб-сайт электронной коммерции принимает заказы пользователей, ему необходимо выполнить следующую серию обработки.      

1. Проверьте, есть ли в инвентаре соответствующие предметы и достаточно ли инвентаря с помощью запроса.
2. Если в инвентаре есть предметы, вам необходимо заблокировать инвентарь, чтобы гарантировать, что эти предметы 
   больше не будут проданы другим, и уменьшить количество доступных предметов, чтобы отразить правильный уровень инвентаря.
3. Если запасов недостаточно, может потребоваться дальнейшее взаимодействие с поставщиком или, по крайней мере, 
   создание системного подсказки.
4. Независимо от того, было ли принятие заказа успешным или нет, должна быть сгенерирована запись потока, и необходимо 
   сгенерировать сообщение уведомления для соответствующего пользователя.
Мы можем инкапсулировать сложные операции через процесс, что не только помогает обеспечить согласованность данных, но также, если бизнес изменится в будущем, нужно только настроить и изменить процесс. Для пользователя, который вызывает процедуру, процедура не раскрывает детали таблицы данных, и процесс выполнения происходит намного быстрее, чем выполнение набора SQL по одному.

Следующий процесс реализует запрос наивысшего, самого низкого и среднего баллов по определенному курсу. 

```SQL
drop procedure if exists sp_score_stat;

delimiter $$

create procedure sp_score_stat(
	courseId int, 
	out maxScore decimal(4,1), 
	out minScore decimal(4,1),
	out avgScore decimal(4,1)
)
begin
	select max(score) into maxScore from tb_record where cou_id=courseId;
	select min(score) into minScore from tb_record where cou_id=courseId;
	select avg(score) into avgScore from tb_record where cou_id=courseId;
end $$

delimiter ;
```

> Примечание : при определении процедуры, поскольку может потребоваться написать несколько SQL-запросов, и для 
> разделения этих SQL-запросов необходимо использовать точку с запятой в качестве разделителя. Если в это время 
> точка с запятой все еще используется для обозначения конца всего кода, тогда ошибка произойдет в SQL, определяющем 
> процедуру, поэтому мы delimiter $$определили конец всего кода как тег выше $$, тогда точка с запятой в коде больше 
> не будет указывать на конец всего кода, и весь код будет end $$выполняться только тогда, когда встречается . После 
> определения процесса delimiter ;верните терминатор к номеру компонента (восстановите сцену).      

Описанный выше процесс имеет четыре параметра. Первый параметр - это входной параметр, который представляет номер 
курса. Следующие параметры являются выходными параметрами. Поскольку процесс не может определить возвращаемое 
значение, результат выполнения может быть получен только через выходной параметр.Ключевое слово выходного параметра 
состоит в out том, что все параметры являются входными параметрами по умолчанию.    

Вызвать процедуру.

```SQL
call sp_score_stat(1111, @a, @b, @c);
```

Получить значение выходного параметра.

```SQL
select @a as 最高分, @b as 最低分, @c as 平均分;
```

Процесс удаления.

```SQL
drop procedure sp_score_stat;
```

В процессе мы можем определять переменные и условия, мы можем использовать операторы ветвления и цикла, мы можем запрашивать результаты с помощью операций курсора, а также мы можем использовать планировщик событий. Мы не будем здесь пока вводить их. Хотя мы говорили о преимуществах множества процессов, в реальной разработке, если процесс часто используется и в него входит большое количество сложных вычислений, это вызовет огромную нагрузку на сервер базы данных, и база данных часто будет узкое место в производительности.Процесс использования, несомненно, еще хуже. Поэтому для разработки интернет-продуктов мы обычно рекомендуем хранить только базу данных, а сложные вычисления и обработка должны выполняться программой на сервере приложений. Если сервер приложений перегружен, мы можем легко развернуть несколько приложений. Сервер разделить это давление.

Если вас интересуют упомянутые выше представления, функции и процедуры, включая триггеры, которые мы не упомянули, я 
предлагаю вам прочитать учебник по MySQL «MySQL Must Know and Know» для общего понимания, поскольку из-за этих точек 
знаний он может не будет использоваться в вашей будущей работе, и вы можете выучить его, просто чтобы встретиться с 
собеседованием.    
### Новые возможности MySQL

#### JТип JSON
Многие разработчики часто считают, что структурированному хранилищу не хватает гибкости при использовании реляционных баз данных для сохранения данных, потому что все столбцы и соответствующие типы данных должны быть спроектированы заранее. В процессе развития и изменения бизнеса, если вам нужно изменить структуру таблицы, это определенно более хлопотно и неудобно. Начиная с MySQL 5.7, MySQL представил поддержку типа данных JSON (MySQL 8.0 решает проблему узкого места производительности журнала JSON). Хорошее использование типа JSON фактически нарушает границу между реляционными и нереляционными базами данных. Приносит больше удобства операциям с сохранением данных .

Типы JSON в основном делятся на объекты JSON и массивы JSON, как показано ниже.

1. Объект JSON

```JSON
{"name": "Иванов", "tel": "13122335566", "QQ": "957658"}
```

2. JSON массив

```JSON
[1, 2, 3]
```

```JSON
[{"name": "Петров", "tel": "13122335566"}, {"name": "Иванов", "QQ": "123456"}]
```

Где вам нужно использовать тип JSON? В качестве простого примера, многие продукты теперь поддерживают несколько 
методов входа в систему, таких как номер мобильного телефона, WeChat, QQ, Sina Weibo и т. Д. Однако при нормальных 
обстоятельствах мы не требуем от пользователей предоставления всей этой информации, поэтому используйте традиционный 
Метод проектирования, вам необходимо создать несколько столбцов для соответствия нескольким методам входа в систему, 
и вам также может потребоваться разрешить нулевые значения в этих столбцах, что, очевидно, не является хорошим 
выбором; с другой стороны, если продукт добавляет метод входа в систему, тогда необходимо изменить структуру 
предыдущей таблицы, что еще более болезненно. Однако с типом JSON проблема только что решена, и мы можем создать 
дизайн, показанный ниже.        


```SQL
create table `tb_test`
(
`user_id` bigint unsigned,
`login_info` json,
primary key (`user_id`)
) engine=innodb;

insert into `tb_test` values 
    (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),
    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');
```

Если вы хотите запросить мобильный телефон пользователя и идентификатор WeChat, вы можете использовать оператор SQL, 
показанный ниже. 

```SQL
select 
    `user_id`,
    json_unquote(json_extract(`login_info`, '$.tel')) as номер телефона,
    json_unquote(json_extract(`login_info`, '$.wechat')) as имя 
from `tb_test`;
```

```
+---------+-------------+-----------+
| user_id | номер телефноа    | имя      |
+---------+-------------+-----------+
|       1 | 13122335566 | jackfrued |
|       2 | 13599876543 | NULL      |
+---------+-------------+-----------+
```

Поскольку MySQL поддерживает тип JSON, он также предоставляет вспомогательную функцию для обработки данных JSON, как 
и json_extract сумма, использованная выше json_unquote. Конечно, есть более удобный способ написать вышеуказанный SQL,
как показано ниже.   
```SQL
select 
	`user_id`,
    `login_info` ->> '$.tel' as 手机号,
    `login_info` ->> '$.wechat' as 微信
from `tb_test`;
```

В качестве другого примера, если нашему продукту необходимо реализовать функцию портрета пользователя (маркировка 
пользователей), а затем рекомендовать пользователям платформенные услуги или потребительские продукты на основе 
портрета пользователя, мы также можем использовать тип JSON для сохранения данных портрета пользователя. 
схематический код показан ниже.   

Создайте таблицу меток с портретной ориентацией.

```SQL
create table `tb_tags`
(
`tag_id` int unsigned not null comment 'номер тега',
`tag_name` varchar(20) not null comment 'имя тега',
primary key (`tag_id`)
) engine=innodb;

insert into `tb_tags` (`tag_id`, `tag_name`) 
values
     ( . 1 , ' 70 сообщение ' ),
    ( 2 , " после 80-х " ),
    ( 3 , ' пост-90 ' ),
    ( 4 , ' После 00 ' ),
    ( 5 , « Люблю спорт » ),
    ( 6 , « Высокообразованный » ),
    ( 7 , ' мещанство ' ),
    ( 8 , ' Есть место ' ),
    ( 9 , « Есть машина » ),
    ( 10 , « Люблю смотреть фильмы » ),
    ( 11 , « Люблю покупки в Интернете » ),
    ( 12 , « Всегда заказывайте еду на вынос » );
```

#### Оконная функция

MySQL поддерживает оконные функции с версии 8.0. Большинство коммерческих баз данных и некоторые базы данных с открытым исходным кодом уже предоставляют поддержку оконных функций. Некоторые также называют их функциями OLAP (онлайн-анализ и обработка). Просто послушайте название и узнайте статистику и анализ. . Чтобы помочь вам понять функцию окна, давайте сначала поговорим о концепции окна.

Окно можно понимать как набор записей, а оконная функция - это специальная функция, выполняемая над набором записей, 
удовлетворяющих определенным условиям. Для каждой записи функция должна выполняться в этом окне. Функцию окна и 
функцию агрегирования, о которой мы упоминали выше, легко спутать. Основное различие между ними состоит в том, что 
функция агрегирования объединяет несколько записей в одну запись. Функция окна выполняется для каждой записи, и 
количество записей не меняется. после казни. Оконная функция - это не просто несколько функций, это полный набор 
грамматики, функция - только часть грамматики, основная грамматика выглядит следующим образом:      
```SQL
< оконная функция > над (разделение по < имя столбца, используемое для группировки >  порядок по  < имя столбца для сортировки пользователей > )
```

В приведенном выше синтаксисе следующие две функции могут быть размещены на месте оконной функции:

1. Специальная функция окна, lead содержащая lag, first_value, last_value, rank,, dense_rank и row_numberтому подобное.
2. Агрегация функция, sum содержащая: avg, max,, min и count тому подобное.

Приведем несколько простых примеров использования оконных функций.Давайте сначала создадим базу данных и таблицу с 
помощью SQL, как показано ниже. 

```SQL
-- Создание базы данных называются часы и указать набор символов по умолчанию
create database `hrs` default charset utf8mb4;

-- Переключение в базу данных часов 
use `hrs`;

-- создать таблицу отделов
create table `tb_dept`
(
`dno` int not null comment 'нет',
`dname` varchar(10) not null comment 'имя',
`dloc` varchar(20) not null comment 'расположение',
primary key (`dno`)
);

-- вставка четырех отделов 
insert into `tb_dept` values 
    ( 10 , ' Бухгалтерия ' , ' Пекин ' ),
    ( 20 , « Отдел исследований и разработок » , « Чэнду » ),
    ( 30 , « Отдел продаж » , « Чунцин » ),
    ( 40 , « Отдел эксплуатации и обслуживания » , « Шэньчжэнь » );

-- Создание таблицы Employee 
create table `tb_emp`
(
`eno` int not null comment 'номер сотрудника',
`ename` varchar(20) not null comment 'имя сотрудника',
`job` varchar(20) not null comment 'должность',
`mgr` int comment 'номер начальника',
`sal` int not null comment 'зараплата',
`comm` int comment 'комментарий',
`dno` int not null comment 'где номер отдела',
primary key (`eno`),
constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),
constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`)
);

-- Вставка 14 сотрудников 
insert into `tb_emp` values 
    ( 7800 , " Чжан Сан " , " президент " , нуль , 9000 , 1200 , 20 ),
    ( 2056 , « Цяо Фэн » , « Аналитик » , 7800 , 5000 , 1500 , 20 ),
    ( 3088 , « Ли Мочоу » , « Дизайнер » , 2056 , 3500 , 800 , 20 ),
    ( 3211 , « Чжан Вуцзи » , « Программист » , 2056 , 3200 , null , 20 ),
    ( 3233 , « Цю Чуджи » , « Программист » , 2056 , 3400 , null , 20 ),
    ( 3251 , « Чжан Цуйшань » , « Программист » , 2056 , 4000 , null , 20 ),
    ( 5566 , « Сун Юаньцяо » , « Бухгалтер » , 7800 , 4000 , 1000 , 10 ),
    ( 5234 , « Го Цзин » , « Кассир » , 5566 , 2000 , null , 10 ),
    ( 3344 , « Хуанг Ронг » , « начальник отдела продаж » , 7800 , 3000 , 800 , 30 ),
    ( 1359 , « Ху Идао » , « продавец » , 3344 , 1800 , 200 , 30 ),
    ( 4466 , « Мяо Жэньфэн » , « продавец » , 3344 , 2500 , null , 30 ),
    ( 3244 , « Оуян Фэн » , « Программист » , 3088 , 3200 , null , 20 ),
    ( 3577 , « Ян Го » , « Бухгалтерский учет » , 5566 , 2200 , null , 10 ),
    ( 3588 , « Чжу Цзючжэнь » , « Бухгалтерский учет » , 5566 , 2500 , null , 10 );
```

Пример 1. Запросите имена и ежемесячную заработную плату сотрудников, занимающих с 4-го по 6-е места в порядке 
убывания месячной зарплаты. 

```SQL
select * from (
	select 
		`ename`, `sal`,
		row_number() over (order by `sal` desc) as `rank`
	from `tb_emp`
) `temp` where `rank` between 4 and 6;
```

> Примечание. Функция, row_number()использованная выше, может генерировать номер строки для каждой записи. В 
> реальной работе вы можете при необходимости заменить ее функцией rank() или dense_rank(). Чтобы узнать разницу 
> между тремя, вы можете обратиться к официальному документу или прочитать "Легко для понимания" Изучение: оконные 
> функции SQL» Познакомьтесь. В предыдущих версиях MySQL 8 мы могли использовать следующие методы для выполнения 
> аналогичных операций.    
> 
> ```SQL
> select `rank`, `ename`, `sal` from (
>     select @a:=@a+1 as `rank`, `ename`, `sal` 
>     from `tb_emp`, (select @a:=0) as t1 order by `sal` desc
> ) t2 where `rank` between 4 and 6;
> ```

Пример 2: Запросите имена и названия отделов двух сотрудников с самой высокой месячной зарплатой в каждом отделе.



```SQL
select `ename`, `sal`, `dname` 
from (
    select 
        `ename`, `sal`, `dno`,
        rank() over (partition by `dno` order by `sal` desc) as `rank`
    from `tb_emp`
) as `temp` natural join `tb_dept` where `rank`<=2;
```

> Примечание. В предыдущих версиях MySQL 8 мы могли использовать следующие методы для выполнения аналогичных операций.
>
> ```SQL
> select `ename`, `sal`, `dname` from `tb_emp` as `t1` 
natural join `tb_dept` 
where (
    select count(*) from `tb_emp` as `t2` 
    where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`>`t1`.`sal` 
)<2 order by `dno` asc, `sal` desc;
> ```

###  Другой контент

#### Теория парадигмы

Теория парадигм - это руководящая идеология для разработки двумерных таблиц в реляционных базах данных.

1. Первая нормальная форма: диапазон значений каждого столбца таблицы данных состоит из атомарных значений и не 
   может быть разделен.
2. Вторая парадигма: все данные в таблице данных должны полностью зависеть от ключа (первичного ключа и 
   ключа-кандидата) таблицы данных.
3. Третья парадигма: все неключевые атрибуты связаны только с ключами-кандидатами, то есть неключевые атрибуты должны 
   быть независимыми и нерелевантными. 

> Примечание: в реальной работе, из соображений эффективности, мы, вероятно, сделаем антипарадигмальный дизайн при 
> разработке таблицы, то есть намеренно снизим уровень режима и добавим избыточные данные для повышения 
> производительности.  

#### Целостность данных

1. Целостность сущности - каждая сущность уникальна

- Первичный ключ ( primary key) / уникальное ограничение ( unique)
2. Ссылочная целостность (ссылочная целостность) - ссылки на несуществующие объекты не допускаются во взаимосвязи

   - Внешний ключ（`foreign key`）
   
3. Данные о целостности домена действительны
   - Тип и длина данных

   - Непустое ограничение （`not null`）

   - Ограничения значений по умолчанию （`default`）

   - Проверить ограничение（`check`）

     > Примечание. До MySQL 8.x проверка ограничений не работала.

#### Согласованность данных

1. Транзакция: серия операций чтения / записи в базе данных. Либо все эти операции завершаются успешно, либо все терпят неудачу.


2. ACID характеристики транзакций
   - Атомарность: транзакция выполняется как единое целое, а операции с содержащейся в ней базой данных либо 
     выполняются, либо не выполняются.
   - Согласованность: транзакция должна гарантировать, что состояние базы данных изменится с одного согласованного 
     состояния на другое согласованное состояние.
   - Изоляция: когда несколько транзакций выполняются одновременно, выполнение одной транзакции не должно влиять на 
     выполнение других транзакций.
   - Постоянство: изменения в базе данных, сделанные зафиксированной транзакцией, должны постоянно храниться в базе данных. 

3. Операции с транзакциями в MySQL

   - Откройте бизнес-среду

     ```SQL
     start transaction
     ```

   - Подтвердить транзакцию

     ```SQL
     commit
     ```

   - Откат транзакции

     ```SQL
     rollback
     ```

4. Просмотр уровня изоляции транзакции

    ```SQL
    show variables like 'transaction_isolation';
    ```

    ```
    +-----------------------+-----------------+
    | Variable_name         | Value           |
    +-----------------------+-----------------+
    | transaction_isolation | REPEATABLE-READ |
    +-----------------------+-----------------+
    ```

    Можно видеть, что уровень изоляции транзакций MySQL по умолчанию равен `REPEATABLE-READ`。

5. Изменить уровень изоляции транзакции (текущий сеанс)

    ```SQL
    set session transaction isolation level read committed;
    ```

    Просмотрите уровень изоляции транзакции, и результат будет следующим.

    ```
    +-----------------------+----------------+
    | Variable_name         | Value          |
    +-----------------------+----------------+
    | transaction_isolation | READ-COMMITTED |
    +-----------------------+----------------+
    ```

Транзакции реляционной базы данных - большая тема, потому что, когда существует несколько одновременных транзакций, 
обращающихся к данным, могут быть три типа проблем чтения данных (грязное чтение, неповторяющееся чтение, фантомное 
чтение) и два типа проблем обновления данных (первый тип отсутствующих обновлений, второй тип недостающих обновлений)
. Если вы хотите понять эти пять типов вопросов, вы можете прочитать вопрос 80 статьи «Полный сборник вопросов для 
собеседований по Java (часть 1)», опубликованной на веб-сайте CSDN. Чтобы избежать этих проблем, в нижней части 
реляционной базы данных имеется соответствующий механизм блокировки, который можно разделить на блокировки на уровне 
таблицы и блокировки на уровне строк в соответствии с объектами блокировки, а также на разделяемые блокировки и 
эксклюзивные блокировки. блокируется в соответствии с взаимосвязью блокировки одновременных транзакций. Однако 
напрямую использовать блокировки очень проблематично. По этой причине база данных предоставляет пользователям 
механизм автоматической блокировки. Пока пользователь указывает соответствующий уровень изоляции транзакции, база 
данных проанализирует оператор SQL и затем добавит соответствующие блокировки в ресурсы, к которым обращается 
транзакция. Кроме того, база данных будет поддерживать эти блокировки для повышения производительности системы с 
помощью различных средств, которые прозрачны для пользователей. Если вы хотите разобраться в деталях транзакций и 
блокировок MySQL, я рекомендую вам прочитать расширенное руководство «High Performance MySQL» , которое также 
является классической книгой по базам данных.               

Стандарт ANSI / ISO SQL 92 определяет 4 уровня изоляции транзакций, как показано в следующей таблице. Следует 
отметить, что уровень изоляции транзакции и параллелизм доступа к данным противоположны: чем выше уровень изоляции 
транзакции, тем хуже параллелизм. Следовательно, необходимо определить, какой уровень изоляции транзакции 
использовать в соответствии с конкретным приложением, поскольку здесь нет принципа всемогущества.    

### Итого

Знания о SQL и MySQL определенно намного больше, чем перечисленные выше, такие как оптимизация самого SQL, настройка 
производительности MySQL, инструменты, связанные с эксплуатацией и обслуживанием MySQL, резервное копирование и 
восстановление данных MySQL, мониторинг служб MySQL, развертывание архитектуры высокой доступности и т. Д. . Здесь 
невозможно обсудить эту серию вопросов по очереди, поэтому оставьте это объяснению, когда это необходимо. Читатели 
также могут исследовать самостоятельно.    