## Погрузитесь в MySQL

Индексы являются наиболее важным средством повышения производительности запросов в реляционных базах данных. Индекс 
в реляционной базе данных подобен оглавлению книги. Мы можем представить себе, что если мы хотим найти определенную 
точку знания из книги, но в этой книге нет оглавления, что это будет ужасно. быть! По нашим оценкам, необходимо 
будет отказываться один за другим, чтобы определить, где находится эта точка знания. Хотя создание индекса приведет 
к дополнительным расходам на дисковое пространство, точно так же, как оглавление книги будет занимать часть 
пространства, но сокращение времени запроса после того, как вы пожертвовали пространством, также очень значительно.  
 

Столбцы всех типов данных в базе данных MySQL можно индексировать. Для механизма хранения InnoDB версии MySQL 8.0 он 
поддерживает три типа индексов, а именно индекс дерева B +, полнотекстовый индекс и индекс R-дерева. Здесь мы только 
представляем наиболее широко используемый индекс дерева B +. Причина использования B + tree очень проста, потому что 
в настоящее время это наиболее эффективная структура данных на основе диска для массового хранения и сортировки 
данных. Дерево B + - это сбалансированное дерево . Высота дерева обычно составляет 3 или 4, но оно может хранить 
данные в диапазоне от одного миллиона до одного миллиарда, и для запроса части данных из этих данных требуется всего 
3 или 4 операции ввода-вывода.

Дерево B + состоит из корневых узлов, промежуточных узлов и конечных узлов. Листовые узлы используются для хранения 
отсортированных данных. Поскольку записи сортируются по индексу, при поиске данных в листовом узле можно 
использовать двоичный поиск.Этот метод поиска очень эффективен. Когда данных мало, дерево B + имеет только один 
корневой узел, и данные также хранятся на корневом узле. При увеличении количества записей дерево B + будет 
разделено, и корневой узел больше не сохраняет данные, а предоставляет указатель на следующий уровень узлов, чтобы 
помочь быстро определить, на каком листовом узле находятся данные.     

При создании двумерной таблицы мы обычно указываем столбец первичного ключа для таблицы. По умолчанию индексы 
создаются в столбце первичного ключа. Для механизма хранения MySQL InnoDB, поскольку он использует структуру 
хранения данных таблицы, организованной по индексу. , первичный ключ. Индекс - это данные всей таблицы, и этот вид 
индекса мы также называем кластеризованным индексом (кластеризованным индексом). Очевидно, что таблица может иметь 
только один кластеризованный индекс, в противном случае данные в таблице должны быть сохранены несколько раз. Индекс 
- это вторичный индекс (вторичный индекс) для создания нашего собственного, более часто называемого 
  некластеризованного индекса (некластеризованный индекс). С помощью нашего настраиваемого некластеризованного 
  индекса можно найти только первичный ключ записи. При получении данных вам может потребоваться запрос через 
  кластеризованный индекс по первичному ключу. Это явление называется «возвращением к таблице». Поэтому получение 
  данных через некластеризованный индекс обычно лучше, чем получение данных с помощью кластеризованного индекса 
  происходит медленно.

Далее мы используем простой пример, чтобы проиллюстрировать значение индекса. Например, нам нужно найти студентов по 
их именам. Этот сценарий часто встречается при реальной разработке. Это то же самое, что поиск продуктов по названию 
продукта. Мы можем использовать explainключевые слова MySQL для просмотра плана выполнения SQL (конкретные шаги базы 
данных для выполнения оператора SQL).    


```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

В приведенном выше плане выполнения SQL есть несколько пунктов, заслуживающих нашего внимания:

1. `select_type`：Тип запроса。
    - `SIMPLE`：Простой SELECT, без использования операций UNION или подзапросов。
    - `PRIMARY`：Если запрос содержит подзапросы, самый внешний SELECT помечается как PRIMARY.
    - `UNION`：Второй или последующий оператор SELECT в операции UNION.
    - `SUBQUERY`：Первый SELECT в подзапросе.
    - `DERIVED`：Подзапрос SELECT производной таблицы.
2. `table`：Запросить соответствующую таблицу.
3. `type`：Способ, которым MySQL находит строки, удовлетворяющие условиям в таблице, также называется типом доступа, включая: ALL(полное сканирование таблицы), index(полное сканирование индекса, только обход дерева индексов), range(сканирование диапазона индексов), ref(неуникальный сканирование индекса), eq_ref(сканирование уникального индекса), const/ system(запрос постоянного уровня), NULL(нет необходимости обращаться к таблицам или индексам). Среди всех типов доступа, ALL, очевидно, является худшим исполнителем.Полное сканирование таблицы, которое он представляет, означает, что каждая строка в таблице должна быть просканирована, чтобы найти соответствующую строку.
4. `possible_keys`：MySQL может выбрать индекс, но его нельзя использовать。
5. `key`：Индекс, фактически используемый MySQL. Если это так, NULL это означает, что индекс не используется。
6. `key_len`：Длина используемого индекса, если она не влияет на запрос, чем короче, тем лучше。
7. `rows`：Количество строк, которые необходимо просканировать для выполнения запроса. Это приблизительное значение。
8. `extra`：О запросе дополнительной информации.
    - `Using filesort`：MySQL не может использовать индекс для завершения операции сортировки.
    - `Using index`：Используйте только информацию индекса и не нужно искать дополнительную информацию в таблице.
    - `Using temporary`：MySQL необходимо использовать временные таблицы для хранения наборов результатов, которые 
      часто используются для группировки и сортировки. 
    - `Impossible where`：Предложение whereне приведет к появлению подходящих строк。
    - `Distinct`：После того, как MySQL находит первую совпадающую строку, он прекращает поиск дополнительных строк для текущей комбинации строк。
    - `Using where`：Столбец запроса не покрывается индексом, и условие фильтрации не является ведущим столбцом индекса.

Как видно из приведенного выше плана выполнения, когда мы запрашиваем студентов по их именам, мы фактически 
выполняем полное сканирование таблицы. Само собой разумеется, что производительность этого запроса должна быть очень 
низкой, особенно когда в таблице много строк. Если нам нужно часто запрашивать учащихся по их имени, мы должны 
создать индекс для столбца, соответствующего имени учащегося, и использовать индекс для ускорения запроса.    
```SQL
create index idx_student_name on tb_student(stuname);
```

Посмотрите еще раз на план выполнения, соответствующий SQL только что.

```SQL
explain select * from tb_student where stuname='Иванов'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

Можно заметить, что после создания индекса по именам учащихся запрос сейчас представляет собой не полное 
сканирование таблицы, а запрос на основе индекса, а просканированная строка представляет собой только одну строку, 
что, очевидно, значительно улучшает производительность запроса. MySQL также позволяет создать индекс префикса, то 
есть создать индекс для первых N символов поля индекса, так что пространство, занимаемое индексом, может быть 
уменьшено (но экономия места, вероятно, приведет к потере времени, времени и пространства являются непримиримые 
противоречия ), следующим образом.     
```SQL
create index idx_student_name_1 on tb_student(stuname(1));
```

Указанный выше индекс эквивалентен индексу, созданному на основе первого слова имени студента, давайте посмотрим на 
план выполнения SQL. 

```SQL
explain select * from tb_student where stuname='Иванов'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

Я не знаю, заметили ли вы, что отсканированные на этот раз строки превратились в 2 строки, потому что в таблице 
студентов есть два студента с фамилией «Иванов». Если мы используем только первое слово имени в качестве индекса, мы 
передадим индекс при запросе. Вы найдете эти две строки.

Если вы хотите удалить индекс, вы можете использовать следующий SQL.

```SQL
alter table tb_student drop index idx_student_name;
```

или

```SQL
drop index idx_student_name on tb_student;
```

При создании индексов мы также можем использовать составные индексы и функциональные индексы (поддерживаются в 
MySQL 5.7). Использование составных индексов для достижения покрытия индекса может уменьшить ненужные операции 
сортировки и возврата к таблице, что удвоит производительность запросов, заинтересованные читатели могут провести 
собственное исследование.

Кратко резюмируем принципы построения индекса для всех:

1. Столбцы, наиболее подходящие для индексации, - это те, которые появляются в предложении WHERE и предложении соединения.
2. Чем больше мощность столбца индекса (больше значений и меньше повторяющихся значений), тем лучше эффект индекса.
3. Использование префиксного индекса может уменьшить пространство, занимаемое индексом, и больше индексов можно 
   кэшировать в памяти.
4. Индекса не так много . Хотя индекс ускоряет операцию чтения (запрос), операция записи (добавление, удаление, 
   модификация) станет медленнее, потому что изменение данных приведет к обновлению индекса, просто например, добавление и удаление глав книги, то же самое для обновления каталога.
5. При использовании механизма хранения InnoDB обычный индекс таблицы сохранит значение первичного ключа , поэтому 
   первичный ключ должен выбирать более короткий тип данных, насколько это возможно , что может эффективно уменьшить 
   пространство, занимаемое индексом, и улучшить кеш-эффект индекса. 

И, наконец, существует мало необходимости объяснять, индекс В-дерево Ьшо используются, в дополнении к индексу 
числового столбца типа определяются за пределами контура эффекта при использовании >, <, >=, <=, BETWEEN...AND... , 
<>, индекс остается в силе, для столбца типа строки, Если вы используете нечеткий запрос, который не начинается с 
подстановочного знака, индекс также будет работать, но другие условия приведут к сбою индекса, что означает, что, 
скорее всего, будет выполнен полный запрос таблицы.    


### Представление

Представление - это объект, который объединяет набор результатов, состоящий из группы инструкций запроса, в 
запрашиваемую таблицу данных в реляционной базе данных. Проще говоря, представление - это виртуальная таблица, но, в 
отличие от таблицы данных, таблица данных - это структура сущностей, а представление - это виртуальная структура. Вы 
также можете понимать представление как SQL, который хранится в базе данных и задается имя.   

Используя представления, можно получить следующие преимущества:

1. Таблица данных объекта может быть скрыта, чтобы внешние программы не могли знать фактическую структуру данных, 
   что позволяет посетителям использовать компоненты таблицы вместо всей таблицы, что снижает риск атак на базу 
   данных.  
2. В большинстве случаев представление доступно только для чтения (операция обновления представления обычно имеет 
   множество ограничений), и внешняя программа не может напрямую изменять данные через представление. 
3. Повторно используйте операторы SQL, заключите очень сложные запросы в таблицу представления и получите прямой 
   доступ к представлению для извлечения требуемых данных; вы также можете просматривать представление как таблицу 
   данных для запросов на соединение. 
4. Представление может возвращать данные в формате, отличном от таблицы данных объекта, и данные могут быть 
   отформатированы при создании представления. 

Создайте представление.

```SQL
-- Создание Просмотр 
create view `vw_avg_score` 
as 
    select `stu_id`, round(avg(`score`), 1) as `avg_score` 
    from `tb_record` group by `stu_id`;

-- создать представление на основе существующего зрения
create view `vw_student_score` 
as 
    select `stu_name`, `avg_score` 
    from `tb_student` natural join `vw_avg_score`;
```

> Совет: поскольку представление не содержит данных, каждый раз, когда вы используете представление, вы должны 
> выполнять запрос для получения данных. Если вы создаете более сложное представление, используя запросы соединения 
> или вложенные запросы, вы можете обнаружить, что производительность запроса резко упадет. . Поэтому перед 
> использованием комплексного представления следует протестировать, чтобы убедиться, что его производительность 
> соответствует потребностям приложения.

Используйте представления.

```SQL
select * from `vw_student_score` order by `avg_score` desc;
```



Поскольку представление представляет собой виртуальную таблицу, можно ли обновить данные в представлении? 
Возможность обновления представления зависит от конкретной ситуации. Следующие типы представлений не могут быть 
обновлены:  

1. Используя функцию совокупного SUM( MIN, MAX, AVG,, и т.д.), , ,, или вид.COUNTDISTINCTGROUP BYHAVINGUNIONUNION ALL
2. SELECT Содержит представления подзапросов.
3. FROM Предложение содержит представление, которое не может быть обновлено.
4. WHERE Подзапрос FROM предложения относится к представлению таблицы в предложении.


Удалить представление.

```SQL
drop view vw_student_score;
```

> Примечание. Если вы хотите обновить представление, вы можете использовать указанную выше команду, чтобы сначала 
> удалить представление, или вы можете create or replace view обновить представление, используя указанную выше 
> команду.

Ознакомьтесь с правилами и ограничениями.

1. Представления могут быть вложенными, а данные, полученные из других представлений, могут использоваться для создания нового представления. Представления также можно использовать с таблицами.
2. order byПредложения можно использовать при создании представления , но если они также используются при извлечении 
   данных из order byпредставления, исходные в представлении order byбудут перезаписаны.
3. Представление не может использовать индекс и не будет запускать выполнение триггеров (из-за соображений 
   производительности при реальной разработке триггеры обычно не рекомендуются, поэтому мы не будем вводить эту концепцию). 


### функция
Слишком много различий между функциями в MySQL и функциями в Python, потому что функции используются для 
инкапсуляции кода, который относительно независим по функциям и будет использоваться повторно. Если вам нужно найти 
какие-то различия, тогда функции в MySQL могут выполнять операторы SQL. В следующем примере мы реализовали функцию 
усечения очень длинных строк с помощью настраиваемой функции.   


```SQL
delimiter $$

create function truncate_string(
    content varchar(10000),
    max_length int unsigned
) returns varchar(10000) no sql
begin
    declare result varchar(10000) default content;
    if char_length(content) > max_length then
        set result = left(content, max_length);
        set result = concat(result, '……');
    end if;
    return result;
end $$

delimiter ;
```

> Примечание 1. За объявлением функции следует no sqlобъявление о том, что тело функции не использует операторы SQL; 
> если телу функции необходимо читать данные через SQL, его необходимо объявить как reads sql data.

> Примечание 2.delimiter Команды до и после определения функции предназначены для изменения разделителя, поскольку 
операторы в теле функции используются для; обозначения конца. Если разделитель не переопределен, ;код будет усечен 
> и выполнен при обнаружении. Очевидно, что это Не тот эффект, который нам нужен. 


Вызов пользовательской функции в запросе.

```SQL
select truncate_string('Пройдитесь со мной по улицам, пока не погаснет весь свет ', 10) as short_string;
```

```
+--------------------------------------+
| short_string                         |
+--------------------------------------+
| Пройдитесь со мной по улицам, пока не погаснет весь свет                |
+--------------------------------------+
```

### 过程

Процедура (также называемая хранимой процедурой) - это набор SQL, заранее скомпилированный и хранимый в базе данных. 
Вызывающая процедура может упростить работу разработчиков приложений, уменьшить взаимодействие с сервером базы 
данных и повысить производительность операций с данными. Фактически, операторы SQL, которые мы использовали до сих 
пор, представляют собой отдельные операторы для одной или нескольких таблиц, но при реальной разработке мы часто 
сталкиваемся с ситуациями, когда для выполнения операции требуется несколько операторов SQL. Например, когда 
веб-сайт электронной коммерции принимает заказы пользователей, ему необходимо выполнить следующую серию обработки. 


1. Проверьте, есть ли в инвентаре соответствующие предметы и достаточно ли инвентаря с помощью запроса.
2. Если в инвентаре есть предметы, вам необходимо заблокировать инвентарь, чтобы гарантировать, что эти предметы 
   больше не будут проданы другим, и уменьшить количество доступных предметов, чтобы отразить правильный уровень инвентаря.
3. Если запасов недостаточно, может потребоваться дальнейшее взаимодействие с поставщиком или, по крайней мере, 
   создание системной подсказки.
4. Независимо от того, было ли принятие заказа успешным или нет, должна быть сгенерирована запись потока, и необходимо 
   сгенерировать сообщение уведомления для соответствующего пользователя. 

Мы можем инкапсулировать сложные операции через процесс, что не только помогает обеспечить согласованность данных, 
но и, если бизнес изменится в будущем, нужно только настроить и изменить процесс. Для пользователя, который 
вызывает процедуру, процедура не раскрывает детали таблицы данных, и процесс выполнения происходит намного быстрее, 
чем выполнение набора SQL по одному.

Следующий процесс реализует запрос наивысшего, самого низкого и среднего баллов по определенному курсу.

```SQL
drop procedure if exists sp_score_stat;

delimiter $$

create procedure sp_score_stat(
	courseId int, 
	out maxScore decimal(4,1), 
	out minScore decimal(4,1),
	out avgScore decimal(4,1)
)
begin
	select max(score) into maxScore from tb_record where cou_id=courseId;
	select min(score) into minScore from tb_record where cou_id=courseId;
	select avg(score) into avgScore from tb_record where cou_id=courseId;
end $$

delimiter ;
```

> Примечание : при определении процедуры, поскольку может потребоваться написать несколько SQL-запросов, и для 
> разделения этих SQL-запросов необходимо использовать точку с запятой в качестве разделителя. Если в это время 
> точка с запятой все еще используется для обозначения конца всего кода, тогда ошибка произойдет в SQL, определяющем 
> процедуру, поэтому мы delimiter $$определили конец всего кода как тег выше $$, тогда точка с запятой в коде больше 
> не будет указывать на конец всего кода, и весь код будет end $$выполняться только тогда, когда встречается . После 
> определения процесса delimiter ;верните терминатор к номеру компонента (восстановите сцену).      


Описанный выше процесс имеет четыре параметра. Первый параметр - это входной параметр, который представляет номер 
курса. Следующие параметры являются выходными параметрами. Поскольку процесс не может определить возвращаемое 
значение, результат выполнения может быть получен только через выходной параметр. Ключевое слово выходного параметра 
состоит в out том, что все параметры являются входными параметрами по умолчанию.


Вызвать процедуру.

```SQL
call sp_score_stat(1111, @a, @b, @c);
```

Получить значение выходного параметра.

```SQL
select @a as 最高分, @b as 最低分, @c as 平均分;
```

Процесс удаления.

```SQL
drop procedure sp_score_stat;
```

В процессе мы можем определять переменные и условия, мы можем использовать операторы ветвления и цикла, мы можем 
запрашивать результаты с помощью операций курсора, а также мы можем использовать планировщики событий. Мы не будем 
здесь пока вводить их. Хотя мы говорили о преимуществах многих процессов, в реальной разработке, если процесс часто 
используется и в него включается большое количество сложных вычислений, это вызовет огромную нагрузку на сервер базы 
данных, и база данных часто оказывается узкое место в производительности. Процесс использования, несомненно, еще хуже.
Поэтому для разработки интернет-продуктов мы обычно рекомендуем хранить только базу данных, а сложные вычисления и 
обработка должны выполняться программой на сервере приложений. Если сервер приложений перегружен, мы можем легко 
развернуть несколько приложений. Сервер разделить это давление.       

Если вас интересуют упомянутые выше представления, функции и процедуры, включая триггеры, которые мы не упомянули, я 
предлагаю вам прочитать вводную книгу MySQL «MySQL Must Know and Know» для общего понимания, поскольку эти точки 
знаний могут не будет использоваться в вашей будущей работе, и вы можете выучить его только перед собеседов   
### Новые возможности MySQL

#### Тип JSON

Многие разработчики часто считают, что структурированному хранилищу не хватает гибкости при использовании 
реляционных баз данных для сохранения данных, потому что все столбцы и соответствующие типы данных должны быть 
спроектированы заранее. В процессе развития и изменения бизнеса, если вам нужно изменить структуру таблицы, это 
определенно более хлопотно и неудобно. Начиная с MySQL 5.7, MySQL представил поддержку типа данных JSON (MySQL 8.0 
решает проблему узкого места производительности журнала JSON). Хорошее использование типа JSON фактически нарушает 
границу между реляционными и нереляционными базами данных. Приносит больше удобства операциям с сохранением данных . 


Типы JSON в основном делятся на объекты JSON и массивы JSON, как показано ниже.

1. Объект JSON

```JSON
{"name": "Иванов", "tel": "13122335566", "QQ": "957658"}
```

2. Массив JSON

```JSON
[1, 2, 3]
```

```JSON
[{"name": "Иванов", "tel": "13122335566"}, {"name": "Петров", "QQ": "123456"}]
```

Где вам нужно использовать тип JSON? В качестве простого примера, многие продукты теперь поддерживают несколько 
методов входа в систему, таких как номер мобильного телефона, WeChat, QQ, Sina Weibo и т. Д. Однако при нормальных 
обстоятельствах мы не требуем от пользователей предоставления всей этой информации, поэтому используйте традиционный 
Метод проектирования, вам необходимо создать несколько столбцов для соответствия нескольким методам входа в систему, 
и вам также может потребоваться разрешить нулевые значения в этих столбцах, что, очевидно, не является хорошим 
выбором; с другой стороны, если продукт добавляет метод входа в систему, тогда необходимо изменить структуру 
предыдущей таблицы, что еще более болезненно. Однако с типом JSON проблема только что решена, и мы можем создать 
дизайн, показанный ниже.



```SQL
create table `tb_test`
(
`user_id` bigint unsigned,
`login_info` json,
primary key (`user_id`)
) engine=innodb;

insert into `tb_test` values 
    (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),
    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');
```

Если вы хотите запросить мобильный телефон пользователя и идентификатор WeChat, вы можете использовать оператор SQL, 
показанный ниже. 

```SQL
select 
    `user_id`,
    json_unquote(json_extract(`login_info`, '$.tel')) as номер телефона,
    json_unquote(json_extract(`login_info`, '$.wechat')) as ник
from `tb_test`;
```

```
+---------+-------------+-----------+
| user_id | номер телефона      | ник       |
+---------+-------------+-----------+
|       1 | 13122335566 | jackfrued |
|       2 | 13599876543 | NULL      |
+---------+-------------+-----------+
```

Поскольку MySQL поддерживает тип JSON, он также предоставляет вспомогательную функцию для обработки данных JSON, как 
и json_extract сумма, использованная выше json_unquote. Конечно, есть более удобный способ написать вышеуказанный SQL,
как показано ниже.   

```SQL
select 
	`user_id`,
    `login_info` ->> '$.tel' as номер телефона,
    `login_info` ->> '$.wechat' as ник
from `tb_test`;
```

В качестве другого примера, если нашему продукту необходимо реализовать функцию портрета пользователя (маркировка 
пользователей), а затем рекомендовать пользователям платформенные услуги или потребительские продукты на основе 
портрета пользователя, мы также можем использовать тип JSON для сохранения данных портрета пользователя. 
схематический код показан ниже.

Создайте таблицу меток с портретной ориентацией.

```SQL
create table `tb_tags`
(
`tag_id` int unsigned not null comment 'ID',
`tag_name` varchar(20) not null comment 'имя',
primary key (`tag_id`)
) engine=innodb;

insert into `tb_tags` (`tag_id`, `tag_name`) 
values
    ( . 1 , ' 70 сообщение ' ),
    ( 2 , " после 80-х " ),
    ( 3 , ' пост-90 ' ),
    ( 4 , ' После 00 ' ),
    ( 5 , « Люблю спорт » ),
    ( 6 , « Высокообразованный » ),
    ( 7 , ' мещанство ' ),
    ( 8 , ' Есть место ' ),
    ( 9 , « Есть машина » ),
    ( 10 , « Люблю смотреть фильмы » ),
    ( 11 , « Люблю покупки в Интернете » ),
    ( 12 , « Всегда заказывайте еду на вынос » );
```

Отметьте пользователей.

```SQL
create table `tb_users_tags`
(
`user_id` bigint unsigned not null comment 'ID',
`user_tags` json not null comment 'имя'
) engine=innodb;

insert into `tb_users_tags` values 
    (1, '[2, 6, 8, 10]'),
    (2, '[3, 10, 12]'),
    (3, '[3, 8, 9, 11]');
```

Затем мы используем набор запросов, чтобы понять изобретательность типа JSON.

1. Запросите 10 идентификатор пользователя, который любит смотреть фильмы (с этим тегом).

    ```SQL
    select * from `tb_users` where 10 member of (user_tags->'$');
    ```

2. Запросите идентификатор пользователя 10после 80-х (с 2этим тегом), который любит смотреть фильмы (с этим тегом).

    ```
    select * from `tb_users` where json_contains(user_tags->'$', '[2, 10]');

3. Запросите идентификатор пользователя, который любит смотреть фильмы, или тех, кто родился в 80-х или 90-х годах.

    ```SQL
    select `user_id` from `tb_users_tags` where json_overlaps(user_tags->'$', '[2, 3, 10]');
    ```

> Примечание . В приведенном выше запросе используются member ofпредикат и две функции JSON. json_containsВы можете 
> проверить, содержит ли массив JSON указанный элемент, а также json_overlapsпроверить, перекрывается ли массив JSON 
> с указанным массивом.   


#### Оконная функция

MySQL поддерживает оконные функции с версии 8.0. Большинство коммерческих баз данных и некоторые базы данных с открытым исходным кодом уже предоставляют поддержку оконных функций, а некоторые также называют их функциями OLAP (онлайн-анализ и обработка). Просто слушайте название и узнавайте статистику и анализ. Связанный. Чтобы помочь вам понять функцию окна, давайте сначала поговорим о концепции окна.

Окно можно понимать как набор записей, а оконная функция - это специальная функция, выполняемая над набором записей, 
удовлетворяющих определенным условиям. Для каждой записи функция должна выполняться в этом окне. Функцию окна и 
функцию агрегирования, о которой мы упоминали выше, легко спутать. Основное различие между ними состоит в том, что 
функция агрегирования объединяет несколько записей в одну запись. Функция окна выполняется для каждой записи, и 
количество записей не меняется. после казни. Оконная функция - это не просто несколько функций, это полный набор 
грамматики, функция - это только часть грамматики, основная грамматика выглядит следующим образом:



```SQL
< оконная функция > над (разделение по < имя столбца, используемое для группировки >  порядок по  < имя столбца для 
сортировки пользователей > ) 
```

В приведенной выше грамматике на место оконной функции могут быть помещены следующие две функции:

1. Специальная функция окна, leadсодержащая lag, first_value, last_value, rank,, dense_rankи row_numberтому подобное. 
2. Агрегация функция, sumсодержащая: avg, max,, minи countтому подобное.


Приведем несколько простых примеров использования оконных функций. Давайте сначала создадим базу данных и таблицу с 
   помощью SQL, как показано ниже. 
```SQL
-- Создание базы данных называются часы и указать набор символов по умолчанию в 
create database `hrs` default charset utf8mb4;

-- Переключение в базу данных часов 
use `hrs`;

-- создать таблицу отделов
create table `tb_dept`
(
`dno` int not null comment 'нет',
`dname` varchar(10) not null comment 'имя',
`dloc` varchar(20) not null comment 'расположение',
primary key (`dno`)
);

-- вставка четырех отделов
insert into `tb_dept` values 
    ( 10 , ' Бухгалтерия ' , ' Пекин ' ),
    ( 20 , « Отдел исследований и разработок » , « Чэнду » ),
    ( 30 , « Отдел продаж » , « Чунцин » ),
    ( 40 , « Отдел эксплуатации и обслуживания » , « Шэньчжэнь » );

-- Создание таблицы Employee 
create table `tb_emp`
(
`eno` int not null comment 'номер сотрудника ',
`ename` varchar(20) not null comment 'Имя сотрудника',
`job` varchar(20) not null comment 'должность',
`mgr` int comment 'номер начальника',
`sal` int not null comment 'Ежемесячная зарплата сотрудников',
`comm` int comment 'ежемесячно субсидия',
`dno` int not null comment 'где номер отдела',
primary key (`eno`),
constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),
constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`)
);

--  Вставка 14 сотрудников 
insert into `tb_emp` values 
    ( 7800 , " Чжан Сан " , " президент " , нуль , 9000 , 1200 , 20 ),
    ( 2056 , « Цяо Фэн » , « Аналитик » , 7800 , 5000 , 1500 , 20 ),
    ( 3088 , « Ли Мочоу » , « Дизайнер » , 2056 , 3500 , 800 , 20 ),
    ( 3211 , « Чжан Вуцзи » , « Программист » , 2056 , 3200 , null , 20 ),
    ( 3233 , « Цю Чуджи » , « Программист » , 2056 , 3400 , null , 20 ),
    ( 3251 , « Чжан Цуйшань » , « Программист » , 2056 , 4000 , null , 20 ),
    ( 5566 , « Сун Юаньцяо » , « Бухгалтер » , 7800 , 4000 , 1000 , 10 ),
    ( 5234 , « Го Цзин » , « Кассир » , 5566 , 2000 , null , 10 ),
    ( 3344 , « Хуанг Ронг » , « начальник отдела продаж » , 7800 , 3000 , 800 , 30 ),
    ( 1359 , « Ху Идао » , « продавец » , 3344 , 1800 , 200 , 30 ),
    ( 4466 , « Мяо Жэньфэн » , « продавец » , 3344 , 2500 , null , 30 ),
    ( 3244 , « Оуян Фэн » , « Программист » , 3088 , 3200 , null , 20 ),
    ( 3577 , « Ян Го » , « Бухгалтерский учет » , 5566 , 2200 , null , 10 ),
    ( 3588 , « Чжу Цзючжэнь » , « Бухгалтерский учет » , 5566 , 2500 , null , 10 );
```

Пример 1. Запросите имена и ежемесячную заработную плату сотрудников, занимающих с 4-го по 6-е места в порядке 
убывания месячной зарплаты. 

```SQL
select * from (
	select 
		`ename`, `sal`,
		row_number() over (order by `sal` desc) as `rank`
	from `tb_emp`
) `temp` where `rank` between 4 and 6;
```

> Примечание . Функция, row_number()использованная выше, может генерировать номер строки для каждой записи. В 
> реальной работе вы можете при необходимости заменить ее функцией rank()или dense_rank(). Чтобы узнать разницу 
> между тремя, вы можете обратиться к официальному документу или прочитать "Легко для понимания" Изучение: оконные 
> функции SQL » Познакомьтесь. В предыдущих версиях MySQL 8 мы могли использовать следующие методы для выполнения 
> аналогичных операций.
> 
> 
> ```SQL
> select `rank`, `ename`, `sal` from (
>     select @a:=@a+1 as `rank`, `ename`, `sal` 
>     from `tb_emp`, (select @a:=0) as t1 order by `sal` desc
> ) t2 where `rank` between 4 and 6;
> ```

Пример 2: Запросите имена и названия отделов двух сотрудников с самой высокой месячной зарплатой в каждом отделе.


```SQL
select `ename`, `sal`, `dname` 
from (
    select 
        `ename`, `sal`, `dno`,
        rank() over (partition by `dno` order by `sal` desc) as `rank`
    from `tb_emp`
) as `temp` natural join `tb_dept` where `rank`<=2;
```

> Примечание. В предыдущих версиях MySQL 8 мы могли использовать следующие методы для выполнения аналогичных операций.


> ```SQL
> select `ename`, `sal`, `dname` from `tb_emp` as `t1` 
natural join `tb_dept` 
where (
    select count(*) from `tb_emp` as `t2` 
    where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`>`t1`.`sal` 
)<2 order by `dno` asc, `sal` desc;
> ```

###  Другой контент

#### Теория парадигмы

Теория парадигм - это руководящая идеология для разработки двумерных таблиц в реляционных базах данных.

1. Первая нормальная форма: диапазон значений каждого столбца таблицы данных состоит из атомарных значений и не может 
быть разделен.
2. Вторая парадигма: все данные в таблице данных должны полностью зависеть от ключа (первичного ключа и 
   ключа-кандидата) таблицы данных.
3. Третья парадигма: все неключевые атрибуты связаны только с ключами-кандидатами, то есть неключевые атрибуты должны 
быть независимыми и не связанными. 

> Примечание: в реальной работе, из соображений эффективности, мы, вероятно, сделаем антипарадигмальный дизайн при 
> разработке таблицы, то есть намеренно снизим уровень режима и добавим избыточные данные для повышения 
> производительности.   

#### Целостность данных

1. Целостность сущности - каждая сущность уникальна

- Первичный ключ ( primary key) / уникальное ограничение ( unique)
2. Ссылочная целостность (ссылочная целостность) - ссылки на несуществующие объекты не допускаются во взаимосвязи

- Внешний ключ ( foreign key)
3. Данные о целостности домена действительны

- Тип и длина данных
- Непустое ограничение ( not null)
- Ограничения значений по умолчанию ( default)
- Проверить ограничение ( check)

     > Примечание. До MySQL 8.x проверка ограничений не работала.

#### Согласованность данных

1. Транзакция: серия операций чтения / записи в базе данных. Либо все эти операции завершаются успешно, либо все 
   терпят неудачу. 

2. ACID характеристики транзакций

- Атомарность: транзакция выполняется как единое целое, а операции с содержащейся в ней базой данных либо выполняются,
либо не выполняются.
- Согласованность: транзакция должна гарантировать, что состояние базы данных изменится с одного согласованного 
  состояния на другое согласованное состояние.
- Изоляция: когда несколько транзакций выполняются одновременно, выполнение одной транзакции не должно влиять на 
  выполнение других транзакций.
- Постоянство: изменения в базе данных, сделанные зафиксированной транзакцией, должны постоянно храниться в базе данных.


3. Операции с транзакциями в MySQL

   - Откройте бизнес-среду

     ```SQL
     start transaction
     ```

   - Подтвердить транзакцию

     ```SQL
     commit
     ```

   - Откат транзакции

     ```SQL
     rollback
     ```

4. Просмотр уровня изоляции транзакции

    ```SQL
    show variables like 'transaction_isolation';
    ```

    ```
    +-----------------------+-----------------+
    | Variable_name         | Value           |
    +-----------------------+-----------------+
    | transaction_isolation | REPEATABLE-READ |
    +-----------------------+-----------------+
    ```

    Можно видеть, что уровень изоляции транзакций MySQL по умолчанию равен REPEATABLE-READ.

5. Изменить уровень изоляции транзакции (текущий сеанс)

    ```SQL
    set session transaction isolation level read committed;
    ```

    Просмотрите уровень изоляции транзакции, и результат будет следующим.

    ```
    +-----------------------+----------------+
    | Variable_name         | Value          |
    +-----------------------+----------------+
    | transaction_isolation | READ-COMMITTED |
    +-----------------------+----------------+
    ```

Транзакции реляционной базы данных - большая тема, потому что, когда есть несколько одновременных транзакций, 
обращающихся к данным, могут быть три типа проблем чтения данных (грязное чтение, неповторяющееся чтение и фантомное 
чтение) и два типа проблем обновления данных (первый тип недостающих обновлений, второй тип недостающих обновлений). 
Если вы хотите понять эти пять типов вопросов, вы можете прочитать вопрос 80 статьи «Полный сборник вопросов для 
собеседований по Java ( часть 1 )», опубликованной на веб-сайте CSDN . Чтобы избежать этих проблем, в нижней части 
реляционной базы данных имеется соответствующий механизм блокировки, который можно разделить на блокировки на уровне 
таблицы и блокировки на уровне строк в соответствии с объектами блокировки, а также на разделяемые блокировки и 
эксклюзивные блокировки. блокируется в соответствии с взаимосвязью блокировки одновременных транзакций. Однако 
использовать блокировки напрямую очень проблематично. По этой причине база данных предоставляет пользователям 
механизм автоматической блокировки. Пока пользователь указывает соответствующий уровень изоляции транзакции, база 
данных будет анализировать операторы SQL, а затем добавлять соответствующие блокировки в ресурсы, к которым 
обращается транзакция. Кроме того, база данных будет поддерживать эти блокировки для повышения производительности 
системы с помощью различных средств, которые прозрачны для пользователей. Если вы хотите разобраться в деталях 
транзакций и блокировок MySQL, я рекомендую вам прочитать расширенное руководство «High Performance MySQL» , которое 
также является классической книгой по базам данных.

Стандарт ANSI / ISO SQL 92 определяет 4 уровня изоляции транзакций, как показано в следующей таблице. Следует 
отметить, что уровень изоляции транзакции и параллелизм доступа к данным противоположны: чем выше уровень изоляции 
транзакции, тем хуже параллелизм. Следовательно, необходимо определить, какой уровень изоляции транзакции 
использовать в соответствии с конкретным приложением, поскольку здесь нет принципа всемогущества.    

### Итого

Знания о SQL и MySQL определенно намного больше, чем перечисленные выше, такие как оптимизация самого SQL, настройка 
производительности MySQL, инструменты, связанные с эксплуатацией и обслуживанием MySQL, резервное копирование и 
восстановление данных MySQL, мониторинг служб MySQL, развертывание архитектуры высокой доступности и т. Д. . 
Невозможно обсудить здесь эту серию вопросов по очереди, поэтому оставьте это объяснению, когда это необходимо. 
Читатели также могут исследовать самостоятельно.