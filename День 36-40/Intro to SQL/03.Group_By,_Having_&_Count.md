# 03.Group_By,_Having_&_Count
### Введение
Теперь, когда вы можете выбирать необработанные данные, вы готовы научиться группировать свои данные и подсчитывать 
вещи в этих группах. Это может помочь вам ответить на такие вопросы, как: 

### Сколько фруктов каждого вида продано в нашем магазине?
Сколько видов животных лечила ветеринарная служба?
Для этого вы узнаете о трех новых методах: GROUP BY, HAVING и COUNT(). Еще раз, мы будем использовать эту выдуманную 
таблицу информации о домашних животных. 



### СЧИТАТЬ()
COUNT(), как вы могли догадаться из названия, возвращает количество вещей. Если вы передадите ему имя столбца, он 
вернет количество записей в этом столбце. 

Например, если мы ВЫБЕРЕМ COUNT() столбца ID в таблице домашних животных, он вернет 4, потому что в таблице 4 ID.

COUNT() — это пример агрегатной функции, которая принимает много значений и возвращает одно. (Другие примеры 
агрегатных функций включают SUM(), AVG(), MIN() и MAX().) Как вы заметили на рисунке выше, агрегатные функции вводят 
странные имена столбцов (например, f0__). Позже в этом руководстве вы узнаете, как изменить имя на более 
описательное.   

### ГРУППА ПО
GROUP BY принимает имя одного или нескольких столбцов и обрабатывает все строки с одинаковым значением в этом 
столбце как единую группу, когда вы применяете агрегатные функции, такие как COUNT(). 

Например, предположим, что мы хотим знать, сколько животных каждого типа есть в таблице домашних животных. Мы можем 
использовать GROUP BY, чтобы сгруппировать строки, которые имеют одинаковое значение в столбце Animal, а 
использовать COUNT(), чтобы узнать, сколько идентификаторов у нас есть в каждой группе.  



Он возвращает таблицу с тремя строками (по одной для каждого отдельного животного). Мы видим, что таблица pets 
содержит 1 кролика, 1 собаку и 2 кошек. 

### ГРУППИРОВАТЬ ПО... ИМЕЮЩЕМУ
HAVING используется в сочетании с GROUP BY для игнорирования групп, которые не соответствуют определенным критериям.

Таким образом, этот запрос, например, будет включать только группы, в которых есть более одного идентификатора.

Поскольку указанному критерию соответствует только одна группа, запрос вернет таблицу только с одной строкой.

### Пример. Какие комментарии Hacker News вызвали наибольшее обсуждение?
Готовы увидеть пример на реальном наборе данных? Набор данных Hacker News содержит информацию об историях и 
комментариях с сайта социальной сети Hacker News. 

Мы будем работать с таблицей комментариев и начнем с вывода первых нескольких строк. 
```python
from google.cloud import bigquery

# Create a "Client" object
client = bigquery.Client()

# Construct a reference to the "hacker_news" dataset
dataset_ref = client.dataset("hacker_news", project="bigquery-public-data")

# API request - fetch the dataset
dataset = client.get_dataset(dataset_ref)

# Construct a reference to the "comments" table
table_ref = dataset_ref.table("comments")

# API request - fetch the table
table = client.get_table(table_ref)

# Preview the first five lines of the "comments" table
client.list_rows(table, max_results=5).to_dataframe()
```
Давайте воспользуемся таблицей, чтобы увидеть, какие комментарии вызвали наибольшее количество ответов. С:

- в родительском столбце указан комментарий, на который был дан ответ, и
- столбец id имеет уникальный идентификатор, используемый для идентификации каждого комментария,
мы можем СГРУППИРОВАТЬ ПО родительскому столбцу и СЧИТАТЬ() по столбцу идентификатора, чтобы выяснить количество 
  комментариев, которые были сделаны в качестве ответов на конкретный комментарий. (Это может не иметь смысла сразу 
  — не торопитесь, чтобы убедиться, что все ясно!)  

Кроме того, поскольку нас интересуют только популярные комментарии, мы рассмотрим комментарии с более чем десятью 
ответами. Таким образом, мы будем возвращать только группы, ИМЕЮЩИЕ более десяти идентификаторов. 
```python
# Query to select comments that received more than 10 replies
query_popular = """
                SELECT parent, COUNT(id)
                FROM `bigquery-public-data.hacker_news.comments`
                GROUP BY parent
                HAVING COUNT(id) > 10
                """
```
Теперь, когда наш запрос готов, давайте запустим его и сохраним результаты в pandas DataFrame:
```python
# Set up the query (cancel the query if it would use too much of 
# your quota, with the limit set to 10 GB)
safe_config = bigquery.QueryJobConfig(maximum_bytes_billed=10**10)
query_job = client.query(query_popular, job_config=safe_config)

# API request - run the query, and convert the results to a pandas DataFrame
popular_comments = query_job.to_dataframe()

# Print the first five rows of the DataFrame
popular_comments.head()
```
Каждая строка в кадре данных Popular_comments соответствует комментарию, на который было получено более десяти 
ответов. Например, комментарий с ID 801208 получил 56 ответов. 

### Псевдонимы и другие улучшения
Пара советов, которые сделают ваши запросы еще лучше:

Столбец, полученный в результате COUNT(id), был назван f0__. Это не очень описательное имя. Вы можете изменить имя, 
добавив AS NumPosts после указания агрегации. Это называется алиасингом, и он будет рассмотрен более подробно в 
следующем уроке.  
Если вы когда-либо не знали, что поместить в функцию COUNT(), вы можете использовать COUNT(1) для подсчета строк в 
каждой группе. Большинство людей считают его особенно читабельным, потому что мы знаем, что он не фокусируется на 
других столбцах. Он также сканирует меньше данных, чем если бы были предоставлены имена столбцов (что делает его 
быстрее и использует меньше вашей квоты доступа к данным). 


Используя эти приемы, мы можем переписать наш запрос:

```python
# Improved version of earlier query, now with aliasing & improved readability
query_improved = """
                 SELECT parent, COUNT(1) AS NumPosts
                 FROM `bigquery-public-data.hacker_news.comments`
                 GROUP BY parent
                 HAVING COUNT(1) > 10
                 """

safe_config = bigquery.QueryJobConfig(maximum_bytes_billed=10**10)
query_job = client.query(query_improved, job_config=safe_config)

# API request - run the query, and convert the results to a pandas DataFrame
improved_df = query_job.to_dataframe()

# Print the first five rows of the DataFrame
improved_df.head()
```
Теперь у вас есть нужные данные, и у них есть описательные имена. Это хороший стиль.

### Примечание по использованию GROUP BY
Обратите внимание: поскольку он сообщает SQL, как применять агрегатные функции (например, COUNT()), нет смысла 
использовать GROUP BY без агрегатной функции. Точно так же, если у вас есть какое-либо предложение GROUP BY, все 
переменные должны быть переданы либо в  

СГРУППИРОВАТЬ по команде или
агрегирующая функция.
Рассмотрим запрос ниже:
```python
query_good = """
             SELECT parent, COUNT(id)
             FROM `bigquery-public-data.hacker_news.comments`
             GROUP BY parent
             """
```
Обратите внимание, что есть две переменные: parent и id.

- родитель был передан команде GROUP BY (в родительском GROUP BY), и
- id был передан агрегатной функции (в COUNT(id)).

И этот запрос не будет работать, потому что столбец автора не передается агрегатной функции или предложению GROUP BY:
```python
query_bad = """
            SELECT author, parent, COUNT(id)
            FROM `bigquery-public-data.hacker_news.comments`
            GROUP BY parent
            """
```
Если вы совершите эту ошибку, вы получите сообщение об ошибке SELECT список ссылок на столбец (имя столбца), который 
не сгруппирован и не агрегирован. 


