# Joining Data
#### Введение
У вас есть инструменты для получения данных из одной таблицы в любом формате. Но что, если нужные вам данные 
распределены по нескольким таблицам? 

Вот где ПРИСОЕДИНЯЙТЕСЬ! JOIN невероятно важен в практических рабочих процессах SQL. Итак, приступим.

#### Пример
Мы будем использовать нашу таблицу воображаемых домашних животных, состоящую из трех столбцов:

- ID - идентификационный номер питомца
- Имя - имя питомца
- Животное - вид животного



Мы также добавим еще одну таблицу, называемую владельцами. Эта таблица также имеет три столбца:

- ID - идентификационный номер владельца (отличный от идентификационного номера питомца)
- Имя - имя владельца
- Pet_ID — идентификационный номер питомца, принадлежащий владельцу (соответствует идентификационному номеру питомца 
  в таблице домашних животных)


Чтобы получить информацию, относящуюся к определенному домашнему животному, мы сопоставляем столбец ID в таблице 
домашних животных со столбцом Pet_ID в таблице владельцев. 



#### Например,

- таблица pets показывает, что доктор Харрис Бонкерс является домашним животным с ID 1.
- Таблица владельцев показывает, что Обри Литтл является владельцем питомца с идентификатором 1.
- Сопоставляя эти два факта, доктор Харрис Бонкерс принадлежит Обри Литтлу.

К счастью, нам не нужно делать это вручную, чтобы выяснить, какой хозяин с каким питомцем идет. В следующем разделе 
вы узнаете, как использовать JOIN для создания новой таблицы, объединяющей информацию из таблиц pets и owner. 

### ПРИСОЕДИНИТЬСЯ
Используя JOIN, мы можем написать запрос для создания таблицы всего с двумя столбцами: имя питомца и имя владельца.



Мы объединяем информацию из обеих таблиц, сопоставляя строки, в которых столбец идентификатора в таблице домашних 
животных соответствует столбцу Pet_ID в таблице владельцев. 

В запросе ON определяет, какой столбец в каждой таблице использовать для объединения таблиц. Обратите внимание: 
поскольку столбец ID существует в обеих таблицах, нам нужно уточнить, какой из них использовать. Мы используем p.ID 
для ссылки на столбец ID из таблицы pets, а o.Pet_ID — на столбец Pet_ID из таблицы owners.  

В общем, когда вы соединяете таблицы, хорошей привычкой является указывать, из какой таблицы берется каждый из ваших 
столбцов. Таким образом, вам не нужно подтягивать схему каждый раз, когда вы возвращаетесь к чтению запроса.  

Тип JOIN, который мы используем сегодня, называется INNER JOIN. Это означает, что строка будет помещена в конечную 
выходную таблицу только в том случае, если значение в столбцах, которые вы используете для их объединения, 
отображается в обеих таблицах, к которым вы присоединяетесь. Например, если бы идентификатор Тома, равный 4, не 
существовал в таблице домашних животных, мы бы получили только 3 строки из этого запроса. Существуют и другие типы 
JOIN, но INNER JOIN очень широко используется, поэтому лучше всего начать с него.    

Пример. Сколько файлов распространяется на каждый тип лицензии на программное обеспечение?
GitHub — самое популярное место для совместной работы над программными проектами. Репозиторий GitHub (или 
репозиторий) — это набор файлов, связанных с конкретным проектом. 

Большинство репозиториев на GitHub распространяются в соответствии с определенной юридической лицензией, которая 
определяет юридические ограничения на их использование. В нашем примере мы посмотрим, сколько различных файлов было 
выпущено по каждой лицензии.  

Мы будем работать с двумя таблицами в базе данных. Первая таблица — это таблица лицензий, которая содержит имя 
каждого репозитория GitHub (в столбце repo_name) и соответствующую лицензию. Вот вид на первые пять рядов. 

```python
from google.cloud import bigquery

# Create a "Client" object
client = bigquery.Client()

# Construct a reference to the "github_repos" dataset
dataset_ref = client.dataset("github_repos", project="bigquery-public-data")

# API request - fetch the dataset
dataset = client.get_dataset(dataset_ref)

# Construct a reference to the "licenses" table
licenses_ref = dataset_ref.table("licenses")

# API request - fetch the table
licenses_table = client.get_table(licenses_ref)

# Preview the first five lines of the "licenses" table
client.list_rows(licenses_table, max_results=5).to_dataframe()
```
Вторая таблица — это таблица sample_files, которая предоставляет, помимо прочего, репозиторий GitHub, которому 
принадлежит каждый файл (в столбце repo_name). Первые несколько строк этой таблицы напечатаны ниже. 

```python
# Construct a reference to the "sample_files" table
files_ref = dataset_ref.table("sample_files")

# API request - fetch the table
files_table = client.get_table(files_ref)

# Preview the first five lines of the "sample_files" table
client.list_rows(files_table, max_results=5).to_dataframe()
```
Затем мы напишем запрос, который использует информацию из обеих таблиц, чтобы определить, сколько файлов выпущено по 
каждой лицензии. 
```python
# Query to determine the number of files per license, sorted by number of files
query = """
        SELECT L.license, COUNT(1) AS number_of_files
        FROM `bigquery-public-data.github_repos.sample_files` AS sf
        INNER JOIN `bigquery-public-data.github_repos.licenses` AS L 
            ON sf.repo_name = L.repo_name
        GROUP BY L.license
        ORDER BY number_of_files DESC
        """

# Set up the query (cancel the query if it would use too much of 
# your quota, with the limit set to 10 GB)
safe_config = bigquery.QueryJobConfig(maximum_bytes_billed=10**10)
query_job = client.query(query, job_config=safe_config)

# API request - run the query, and convert the results to a pandas DataFrame
file_count_by_license = query_job.to_dataframe()
```
Мы начнем с JOIN (выделено синим цветом выше). Это определяет источники данных и способ их объединения. Мы 
используем ON, чтобы указать, что мы объединяем таблицы, сопоставляя значения в столбцах repo_name в таблицах.  

Далее поговорим о SELECT и GROUP BY (выделено желтым). GROUP BY разбивает данные на разные группы для каждой 
лицензии, прежде чем мы ПОДСЧЕТ количество строк в таблице sample_files, соответствующих каждой лицензии. (Помните, 
что вы можете подсчитать количество строк с помощью COUNT(1).)  

Наконец, ORDER BY (выделен фиолетовым цветом) сортирует результаты таким образом, что лицензии с большим количеством 
файлов появляются первыми. 

Это был большой запрос, но он дал нам хорошую таблицу, в которой указано, сколько файлов было зафиксировано под 
каждой лицензией: 

```python
# Print the DataFrame
file_count_by_license
```






