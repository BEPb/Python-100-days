# Maximum Pooling
# Введение
# В этих упражнениях вы завершите извлечение признаков, начатое в упражнении 2, исследуете, как создается
# инвариантность за счет максимального объединения, а затем рассмотрите другой вид объединения: средний пул.
#
# Запустите ячейку ниже, чтобы все настроить.
# Setup feedback system
from learntools.core import binder
binder.bind(globals())
from learntools.computer_vision.ex3 import *

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from matplotlib import gridspec
import learntools.computer_vision.visiontools as visiontools

plt.rc('figure', autolayout=True)
plt.rc('axes', labelweight='bold', labelsize='large',
       titleweight='bold', titlesize=18, titlepad=10)
plt.rc('image', cmap='magma')

# Запустите эту ячейку, чтобы вернуться к тому месту, где вы остановились на предыдущем уроке. На этот раз мы будем
# использовать предопределенное ядро.

# Read image
image_path = '../input/computer-vision-resources/car_illus.jpg'
image = tf.io.read_file(image_path)
image = tf.io.decode_jpeg(image, channels=1)
image = tf.image.resize(image, size=[400, 400])

# Embossing kernel
kernel = tf.constant([
    [-2, -1, 0],
    [-1, 1, 1],
    [0, 1, 2],
])

# Reformat for batch compatibility.
image = tf.image.convert_image_dtype(image, dtype=tf.float32)
image = tf.expand_dims(image, axis=0)
kernel = tf.reshape(kernel, [*kernel.shape, 1, 1])
kernel = tf.cast(kernel, dtype=tf.float32)

image_filter = tf.nn.conv2d(
    input=image,
    filters=kernel,
    strides=1,
    padding='VALID',
)

image_detect = tf.nn.relu(image_filter)

# Show what we have so far
plt.figure(figsize=(12, 6))
plt.subplot(131)
plt.imshow(tf.squeeze(image), cmap='gray')
plt.axis('off')
plt.title('Input')
plt.subplot(132)
plt.imshow(tf.squeeze(image_filter))
plt.axis('off')
plt.title('Filter')
plt.subplot(133)
plt.imshow(tf.squeeze(image_detect))
plt.axis('off')
plt.title('Detect')
plt.show();

# 1) Примените объединение к конденсату
# Для последнего шага в последовательности примените максимальное объединение с использованием окна объединения 2 ×
# 2. Вы можете скопировать этот код, чтобы начать:
image_condense = tf.nn.pool(
    input=image_detect,
    window_shape=(2, 2),
    pooling_type='MAX',
    strides=(2, 2),
    padding='SAME',
)

# Мы узнали о том, как слои MaxPool2D наделяют сверточную сеть свойством трансляционной инвариантности на небольшие
# расстояния. В этом упражнении вы сможете увидеть это в действии.
# Следующая ячейка кода случайным образом применит небольшой сдвиг к кругу, а затем несколько раз сожмет изображение
# с максимальным объединением. Запустите ячейку один раз и обратите внимание на изображение, которое получится в конце.

REPEATS = 4
SIZE = [64, 64]

# Create a randomly shifted circle
image = visiontools.circle(SIZE, r_shrink=4, val=1)
image = tf.expand_dims(image, axis=-1)
image = visiontools.random_transform(image, jitter=3, fill_method='replicate')
image = tf.squeeze(image)

plt.figure(figsize=(16, 4))
plt.subplot(1, REPEATS+1, 1)
plt.imshow(image, vmin=0, vmax=1)
plt.title("Original\nShape: {}x{}".format(image.shape[0], image.shape[1]))
plt.axis('off')

# Now condense with maximum pooling several times
for i in range(REPEATS):
    ax = plt.subplot(1, REPEATS+1, i+2)
    image = tf.reshape(image, [1, *image.shape, 1])
    image = tf.nn.pool(image, window_shape=(2,2), strides=(2, 2), padding='SAME', pooling_type='MAX')
    image = tf.squeeze(image)
    plt.imshow(image, vmin=0, vmax=1)
    plt.title("MaxPool {}\nShape: {}x{}".format(i+1, image.shape[0], image.shape[1]))
    plt.axis('off')

# 2) Изучите инвариантность
# Предположим, вы сделали небольшой сдвиг в другом направлении - как вы ожидаете, что это повлияет на полученное
# изображение? Если хотите, попробуйте запустить ячейку еще несколько раз, чтобы получить новый случайный сдвиг.


# Решение: в этом руководстве мы говорили о том, как максимальный пул обеспечивает инвариантность перевода на малых
# расстояниях. Это означает, что мы ожидаем исчезновения небольших сдвигов после повторного максимального
# объединения. Если вы запустите ячейку несколько раз, вы увидите, что результирующее изображение всегда одно и то
# же; операция объединения уничтожает эти небольшие переводы.



# Объединение глобального среднего значения¶
# В предыдущем упражнении мы упоминали, что среднее объединение в значительной степени заменено максимальным
# объединением в сверточной базе. Однако существует своего рода объединение средних значений, которое до сих пор
# широко используется в заголовке свёрточной сети. Это средний глобальный пул. Слой GlobalAvgPool2D часто
# используется в качестве альтернативы некоторым или всем скрытым плотным слоям в головной части сети, например:

# model = keras.Sequential ([
#     pretrained_base,
#     Layers.GlobalAvgPool2D (),
#     Layers.Dense (1, activate = 'sigmoid'),
# ])

# Что делает этот слой? Обратите внимание, что у нас больше нет слоя Flatten, который обычно следует за базовым для
# преобразования данных 2D-объекта в 1D-данные, необходимые классификатору. Теперь эту функцию выполняет слой
# GlobalAvgPool2D. Но вместо того, чтобы «разложить» функцию (как Flatten), она просто заменяет всю карту функций ее
# средним значением. Хотя он очень разрушителен, он часто работает достаточно хорошо и имеет то преимущество,
# что сокращает количество параметров в модели.
#
# Давайте посмотрим, что делает GlobalAvgPool2D на некоторых случайно сгенерированных картах функций. Это поможет нам
# понять, как можно «сгладить» стопку карт функций, созданных базой.
#
# Выполните эту следующую ячейку несколько раз, пока не почувствуете, как работает этот новый слой.
# Поскольку каждая из карт функций 5 × 5 была уменьшена до одного значения, глобальное объединение уменьшило
# количество параметров, необходимых для представления этих функций, в 25 раз - существенная экономия!
#
# Теперь мы перейдем к пониманию объединенных функций.
# После того, как мы объединили функции в одно значение, достаточно ли у головы информации для определения класса?
# Эта часть упражнения исследует этот вопрос.
#
# Давайте передадим несколько изображений из нашего набора данных Car или Truck через VGG16 и рассмотрим особенности,
# которые появляются после объединения. Сначала запустите эту ячейку, чтобы определить модель и загрузить набор данных.

from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.preprocessing import image_dataset_from_directory

# Load VGG16
pretrained_base = tf.keras.models.load_model(
    '../input/cv-course-models/cv-course-models/vgg16-pretrained-base',
)

model = keras.Sequential([
    pretrained_base,
    # Attach a global average pooling layer after the base
    layers.GlobalAvgPool2D(),
])

# Load dataset
ds = image_dataset_from_directory(
    '../input/car-or-truck/train',
    labels='inferred',
    label_mode='binary',
    image_size=[128, 128],
    interpolation='nearest',
    batch_size=1,
    shuffle=True,
)

ds_iter = iter(ds)

# Обратите внимание, как мы прикрепили слой GlobalAvgPool2D после предварительно обученной базы VGG16. Обычно VGG16
# создает 512 карт характеристик для каждого изображения. Слой GlobalAvgPool2D уменьшает каждое из них до одного
# значения, «средний пиксель», если хотите.
#
# В следующей ячейке будет запущено изображение из набора данных «Автомобиль» или «Грузовик» через VGG16 и показаны
# средние 512 пикселей, созданные GlobalAvgPool2D. Запустите ячейку несколько раз и сравните пиксели, создаваемые
# автомобилями, с пикселями, создаваемыми грузовиками.

# 3) Поймите объединенные функции
# Что ты видишь? Достаточно ли различаются объединенные функции для легковых и грузовых автомобилей, чтобы различать
# их? Как бы вы интерпретировали эти совокупные ценности? Как это могло помочь классификации? После того,
# как вы подумали об этом, запустите следующую ячейку, чтобы получить ответ. (Или сначала посмотрите подсказку!)

# База VGG16 производит 512 карт функций. Мы можем думать о каждой карте функций как о представлении некоторой
# высокоуровневой визуальной функции в исходном изображении - возможно, колеса или окна. Объединение карты дает нам
# одно число, которое мы можем рассматривать как оценку для этой функции: большое, если функция присутствует,
# маленькое, если она отсутствует. Автомобили, как правило, получают высокие баллы за один набор функций, а грузовики
# - за другие. Теперь вместо того, чтобы пытаться сопоставить необработанные объекты с классами, голова должна
# работать только с теми оценками, которые произвел GlobalAvgPool2D, и решить эту проблему гораздо проще.


# В современных свёртках часто используется глобальный средний пул. Одним из больших преимуществ является то,
# что он значительно уменьшает количество параметров в модели, при этом сообщая вам, присутствовала ли какая-либо
# функция на изображении или нет - что для классификации обычно все, что имеет значение. Если вы создаете сверточный
# классификатор, его стоит попробовать!
#
# Вывод
# В этом уроке мы исследовали последнюю операцию в процессе извлечения признаков: уплотнение с максимальным
# объединением. Объединение в пулы является одной из основных характеристик сверточных сетей и помогает обеспечить им
# некоторые из характерных преимуществ: эффективность с визуальными данными, уменьшенный размер параметра по
# сравнению с плотными сетями, инвариантность трансляции. Мы видели, что он используется не только в базе во время
# извлечения признаков, но также может использоваться в голове во время классификации. Понимание этого важно для
# полного понимания коннетов.