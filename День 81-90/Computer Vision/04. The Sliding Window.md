## The Sliding Window
Введение

В предыдущих двух уроках мы узнали о трех операциях, выполняющих извлечение признаков из изображения:

- фильтр со сверточным слоем
- обнаружить с активацией ReLU
- конденсировать с максимальным объединяющим слоем


Операции свертки и объединения имеют общую особенность: они оба выполняются в скользящем окне. При свертке это 
«окно» задается размерами ядра, параметром kernel_size. При объединении это окно объединения, заданное параметром 
pool_size.

### Двумерное скользящее окно.
Есть два дополнительных параметра, влияющих на слои свертки и объединения - это шаги окна и необходимость 
использования отступов по краям изображения. Параметр strides говорит, как далеко окно должно перемещаться на каждом 
шаге, а параметр padding описывает, как мы обрабатываем пиксели по краям ввода.  

С этими двумя параметрами определение двух слоев становится следующим:
```python
from tensorflow import keras
from tensorflow.keras import layers

model = keras.Sequential([
    layers.Conv2D(filters=64,
                  kernel_size=3,
                  strides=1,
                  padding='same',
                  activation='relu'),
    layers.MaxPool2D(pool_size=2,
                     strides=1,
                     padding='same')
    # More layers follow
])
```
### Шаг (Stride)
Расстояние, на которое окно перемещается на каждом шаге, называется шагом. Нам нужно указать шаг в обоих измерениях 
изображения: один для перемещения слева направо, а другой для перемещения сверху вниз. Эта анимация показывает шаги 
= (2, 2), движение на 2 пикселя за каждый шаг.   

Раздвижное окно с шагом (2, 2).
Какой эффект дает шаг? Когда шаг в любом направлении больше 1, скользящее окно будет пропускать некоторые пиксели во 
входных данных на каждом шаге. 

Поскольку мы хотим, чтобы для классификации использовались высококачественные функции, сверточные слои чаще всего 
имеют strides = (1, 1). Увеличение шага означает, что мы упускаем потенциально ценную информацию в нашем резюме. 
Однако максимальные уровни объединения почти всегда будут иметь значения шага больше 1, например (2, 2) или (3, 3), 
но не больше, чем само окно.   

Наконец, обратите внимание, что когда значение шагов в обоих направлениях одинаковое, вам нужно только установить 
это число; например, вместо strides = (2, 2) вы можете использовать strides = 2 для настройки параметра. 

### Обивка (Padding)
При выполнении вычисления скользящего окна возникает вопрос, что делать на границах ввода. Пребывание полностью 
внутри входного изображения означает, что окно никогда не будет располагаться прямо над этими граничными пикселями, 
как это происходит с каждым другим пикселем во входном изображении. Может быть проблема, поскольку мы не 
обрабатываем все пиксели одинаково?   

Что делает свертка с этими граничными значениями, определяется ее параметром заполнения. В TensorFlow у вас есть два 
варианта выбора: padding = 'same' или padding = 'valid'. С каждым есть компромисс. 

Когда мы устанавливаем padding = 'valid', окно свертки останется полностью внутри ввода. Недостатком является то, 
что результат сжимается (теряются пиксели) и сжимается больше для больших ядер. Это ограничит количество слоев, 
которые может содержать сеть, особенно когда входы имеют небольшой размер.   

Альтернативой является использование padding = 'same'. Хитрость здесь в том, чтобы заполнить вход нулями вокруг его 
границ, используя ровно столько нулей, чтобы размер вывода был таким же, как размер ввода. Однако это может привести 
к ослаблению влияния пикселей на границах. На анимации ниже показано скользящее окно с одинаковым заполнением.  

Модель VGG, которую мы рассматривали, использует одно и то же заполнение для всех сверточных слоев. В большинстве 
современных сетей используется комбинация этих двух типов. (Еще один параметр для настройки!) 

### Пример - изучение раздвижных окон
Чтобы лучше понять влияние параметров скользящего окна, может помочь наблюдение за выделением признаков на 
изображении с низким разрешением, чтобы мы могли видеть отдельные пиксели. Давайте просто посмотрим на простой круг. 

Следующая скрытая ячейка создаст для нас изображение и ядро.
```python
import tensorflow as tf
import matplotlib.pyplot as plt

plt.rc('figure', autolayout=True)
plt.rc('axes', labelweight='bold', labelsize='large',
       titleweight='bold', titlesize=18, titlepad=10)
plt.rc('image', cmap='magma')

image = circle([64, 64], val=1.0, r_shrink=3)
image = tf.reshape(image, [*image.shape, 1])
# Bottom sobel
kernel = tf.constant(
    [[-1, -2, -1],
     [0, 0, 0],
     [1, 2, 1]],
)

show_kernel(kernel)
```

Архитектура VGG довольно проста. Он использует свертку с шагом 1 и максимальное объединение с окнами 2 × 2 и шагом 2.
Мы включили функцию в служебный скрипт visiontools, которая покажет нам все шаги. 

```python
show_extraction(
    image, kernel,

    # Window parameters
    conv_stride=1,
    pool_size=2,
    pool_stride=2,

    subplot_shape=(1, 4),
    figsize=(14, 6),
)
```
И это очень хорошо работает! Ядро было разработано для обнаружения горизонтальных линий, и мы можем видеть, что в 
результирующей карте функций более горизонтальные части ввода имеют наибольшую активацию. 

Что бы произошло, если бы мы изменили шаг свертки на 3?

```python
show_extraction(
    image, kernel,

    # Window parameters
    conv_stride=3,
    pool_size=2,
    pool_stride=2,

    subplot_shape=(1, 4),
    figsize=(14, 6),    
)
```

Похоже, это снижает качество извлеченного объекта. Наш круг ввода довольно "мелко детализирован", его ширина 
составляет всего 1 пиксель. Свертка с 3-мя шагами слишком грубая, чтобы из нее можно было построить хорошую карту 
характеристик.  

Иногда модель будет использовать свертку с большим шагом на начальном слое. Обычно это также связано с большим ядром.
Модель ResNet50, например, использует ядра 7 × 7 с шагом 2 на первом уровне. Похоже, что это ускоряет создание 
крупномасштабных функций без ущерба для слишком большого количества вводимой информации.  

### Вывод
В этом уроке мы рассмотрели характерные вычисления, общие как для свертки, так и для объединения: скользящее окно и 
параметры, влияющие на его поведение в этих слоях. Этот стиль оконных вычислений вносит большой вклад в то, что 
характерно для сверточных сетей, и является важной частью их функционирования.  



