Target Encoding (Целевое кодирование)
###Вступление
Большинство методов, которые мы видели в этом курсе, предназначены для числовых функций. Методика, которую мы 
рассмотрим в этом уроке, целевое кодирование, вместо этого предназначена для категориальных функций. Это метод 
кодирования категорий в виде чисел, например, горячее кодирование или кодирование меток, с той разницей, что он 
также использует цель для создания кодировки. Это делает это тем, что мы называем техникой контролируемой 
разработки функций.

```python
import pandas as pd

autos = pd.read_csv("../input/fe-course-data/autos.csv")
```


###Целевое кодирование
Целевая кодировка - это любой вид кодировки, который заменяет категории функции некоторым числом, полученным из цели.

Простой и эффективный вариант - применить групповое агрегирование из Урока 3, как среднее. Используя набор данных 
Automobiles, вычисляется средняя цена каждой марки автомобиля:

```python
autos["make_encoded"] = autos.groupby("make")["price"].transform("mean")

autos[["make", "price", "make_encoded"]].head(10)
```
сделать цену make_encoded
0 альфа-ромеро 13495 15498.333333
1 альфа-ромеро 16500 15498.333333
2 альфа-ромеро 16500 15498.333333
3 ауди 13950 17859.166667
4 ауди 17450 17859.166667
5 Ауди 15250 17859.166667
6 ауди 17710 17859.166667
7 ауди 18920 17859.166667
8 ауди 23875 17859.166667
9 bmw 16430 26118.750000

Такой вид целевой кодировки иногда называют средней кодировкой. Применительно к двоичной цели это также называется 
подсчетом ячеек. (Другие названия, которые вы можете встретить, включают: кодирование вероятности, кодирование 
воздействия и кодирование с исключением одного.)

###Сглаживание
Однако такая кодировка создает несколько проблем. Во-первых, это неизвестные категории. Целевые кодировки создают 
особый риск переобучения, что означает, что их нужно обучать на независимом "кодирующем" разбиении. Когда вы 
присоединяете кодировку к будущим разбиениям, Pandas будет заполнять отсутствующие значения для любых категорий, не 
представленных в разбиении кодировки. Эти недостающие значения вам придется как-то вменять.

Во-вторых, это редкие категории. Когда категория встречается в наборе данных всего несколько раз, любая статистика, 
рассчитанная по ее группе, вряд ли будет очень точной. В наборе данных «Автомобили» создание mercurcy выполняется 
только один раз. «Средняя» цена, которую мы рассчитали, - это всего лишь цена одного автомобиля, которая может не 
очень хорошо отражать любые Mercury, которые мы можем увидеть в будущем. Целевое кодирование редких категорий может 
повысить вероятность переобучения.

Решение этих проблем - добавить сглаживание. Идея состоит в том, чтобы совместить средний показатель по категории с 
общим средним. Редкие категории получают меньший вес в среднем по своей категории, в то время как пропущенные 
категории получают только общее среднее значение.

В псевдокоде:

```python
encoding = weight * in_category + (1 - weight) * overall
```
где вес - это значение от 0 до 1, рассчитанное на основе частоты категории.

Простой способ определить значение веса - вычислить m-оценку:

```python
weight = n / (n + m)
```
где n - общее количество раз, когда эта категория встречается в данных. Параметр m определяет «коэффициент 
сглаживания». Чем больше значение m, тем больше вес в общей оценке.


В наборе данных Automobiles есть три автомобиля марки Chevrolet. Если вы выберете m = 2,0, тогда категория 
chevrolet будет закодирована как 60% от средней цены Chevrolet плюс 40% от общей средней цены.

```python
chevrolet = 0.6 * 6000.00 + 0.4 * 13285.03
```

Выбирая значение для m, подумайте, насколько шумным, по вашему мнению, будут категории. Сильно ли различается цена 
автомобиля в зависимости от марки? Вам понадобится много данных, чтобы получить точные оценки? Если да, то лучше 
выбрать для m большее значение; если бы средняя цена для каждой марки была относительно стабильной, можно было бы 
допустить меньшее значение.

###Примеры использования целевой кодировки
Целевая кодировка отлично подходит для:
Функции с высокой мощностью: функцию с большим количеством категорий может быть проблематично закодировать: горячая 
кодировка создаст слишком много функций, а альтернативы, такие как кодирование метки, могут не подходить для этой 
функции. Целевая кодировка выводит числа для категорий, используя наиболее важное свойство функции: ее связь с целью.
Возможности, мотивированные доменом. Исходя из предыдущего опыта, вы могли подозревать, что категориальная функция 
должна быть важной, даже если она получила низкую оценку с помощью метрики функции. Целевая кодировка может помочь 
выявить истинную информативность функции.
Пример - MovieLens1M
Набор данных MovieLens1M содержит миллион оценок фильмов пользователями веб-сайта MovieLens с функциями, 
описывающими каждого пользователя и фильм. Эта скрытая ячейка настраивает все:

```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import warnings

plt.style.use("seaborn-whitegrid")
plt.rc("figure", autolayout=True)
plt.rc(
    "axes",
    labelweight="bold",
    labelsize="large",
    titleweight="bold",
    titlesize=14,
    titlepad=10,
)
warnings.filterwarnings('ignore')


df = pd.read_csv("../input/fe-course-data/movielens1m.csv")
df = df.astype(np.uint8, errors='ignore') # reduce memory footprint
print("Number of Unique Zipcodes: {}".format(df["Zipcode"].nunique()))
```
Количество уникальных почтовых индексов: 3439


Имея более 3000 категорий, функция Zipcode является хорошим кандидатом для целевой кодировки, а размер этого набора 
 данных (более миллиона строк) означает, что мы можем сэкономить некоторые данные для создания кодировки.

Мы начнем с создания 25% разделения для обучения целевого кодировщика.

```python
X = df.copy()
y = X.pop('Rating')

X_encode = X.sample(frac=0.25)
y_encode = y[X_encode.index]
X_pretrain = X.drop(X_encode.index)
y_train = y[X_pretrain.index]
```

Пакет category_encoders в scikit-learn-contrib реализует кодировщик m-оценки, который мы будем использовать для 
 кодирования нашей функции Zipcode.

```python
from category_encoders import MEstimateEncoder

# Create the encoder instance. Choose m to control noise.
# Создать экземпляр кодировщика. Выберите m, чтобы контролировать шум.
encoder = MEstimateEncoder(cols=["Zipcode"], m=5.0)

# Fit the encoder on the encoding split.
# Установите кодировщик на разделение кодировки.
encoder.fit(X_encode, y_encode)

# Encode the Zipcode column to create the final training data
# Кодировать столбец Zipcode для создания окончательных данных обучения
X_train = encoder.transform(X_pretrain)
```

Давайте сравним закодированные значения с целевым, чтобы увидеть, насколько информативным может быть наша кодировка.

```python
plt.figure(dpi=90)
ax = sns.distplot(y, kde=False, norm_hist=True)
ax = sns.kdeplot(X_train.Zipcode, color='r', ax=ax)
ax.set_xlabel("Rating")
ax.legend(labels=['Zipcode', 'Rating']);
```

Распределение функции закодированного почтового индекса примерно соответствует распределению фактических оценок, а 
это означает, что зрители фильма достаточно различались в своих оценках от почтового индекса к почтовому индексу, 
чтобы наша целевая кодировка могла захватывать полезную информацию. 