# Вступление
# В этом руководстве вы узнали, как создать достаточно интеллектуального агента с помощью алгоритма минимакса. В
# этом упражнении вы проверите свое понимание и представите своего агента для участия в конкурсе.

# 1) Присмотритесь
# Эвристика из учебника рассматривает все группы из четырех соседних местоположений сетки в одной строке,
# столбце или диагонали и назначает точки для каждого вхождения следующих шаблонов:
#
# Неужели действительно необходимо использовать такое количество чисел для определения эвристики? Попробуйте
# упростить его, как показано на изображении ниже.
# Как каждая эвристика оценивает потенциальные ходы в приведенном ниже примере (где в этом случае агент смотрит
# только на один шаг вперед)? Какая эвристика позволит агенту выбрать лучший ход?

# Решение: первая эвристика гарантированно выберет столбец 2, чтобы заблокировать победу противника. Вторая
# эвристика выбирает либо столбец 2, либо столбец 3 (каждый из которых выбирается с вероятностью 50%). Таким
# образом, для этого игрового поля лучше использовать первую эвристику. В общем, мы можем ожидать, что первая
# эвристика будет лучшей эвристикой, поскольку мы не можем доверять второй эвристике, чтобы помешать оппоненту
# выиграть.



# 2) Подсчитайте листья
# В туториале мы работали с небольшим деревом игр.

# В приведенном выше игровом дереве есть 8 узловых листьев, которые появляются в нижней части дерева. По
# определению, «листовые узлы» в дереве игры - это узлы, ниже которых нет узлов.
#
# В соревновании ConnectX деревья игр будут намного больше!
#
# Чтобы увидеть это, рассмотрим минимаксного агента, который пытается спланировать свой первый ход,
# когда все столбцы на игровом поле пусты. Предположим, агент строит игровое дерево глубины 3. Сколько листовых
#  узлов в игровом дереве?
#
# Используйте свой ответ, чтобы заполнить бланк ниже.
# # Заполнить бланк
num_leaves = 7*7*7



# 3) Какой ход выберет агент?
# В этом вопросе вы проверите свое понимание минимаксного алгоритма. Помните, что с помощью этого алгоритма
# Агент выбирает ходы, чтобы получить как можно более высокий счет, и предполагает, что противник будет
# противодействовать этому, выбирая ходы, чтобы сделать счет как можно более низким.
# Рассмотрим приведенный ниже игрушечный пример дерева игры, который агент будет использовать для выбора своего
# следующего хода.
#
# Какой ход выберет агент? Используйте свой ответ, чтобы установить значение переменной selected_move ниже. Ваш
# ответ должен быть одним из 1, 2 или 3.
#
selected_move = 3
#

# 4) Изучите предположения
# Минимаксный агент предполагает, что его противник играет оптимально (с точки зрения эвристики и использования
# дерева игр с ограниченной глубиной). Но на практике этого почти никогда не бывает: гораздо более вероятно,
# что агент столкнется с неоптимальным (то есть хуже оптимального) противником.
#
# Скажем, минимаксный агент встречает неоптимального противника. Следует ли ожидать, что минимаксный агент
# по-прежнему будет хорошо играть в игру, несмотря на противоречие с его предположениями? Если да, то почему?
# Решение: мы все еще можем ожидать, что минимаксный агент будет работать хорошо. На высоком уровне предположение об
# оптимальном оппоненте просто переоценивает оппонента, но не нарушает алгоритм. Эффект переоценки оппонента просто
# состоит в том, что минимаксному агенту потребуется больше времени, чтобы победить, чем если бы он имел более
# точное понимание своего оппонента. Например, очень маловероятно, что минимаксный агент выберет один и тот же
# столбец три раза в свои первые три хода (поскольку он предполагает оптимального оппонента, который обязательно
# заблокирует выигрышную игру на следующем ходу), но это неплохая начальная стратегия для игра против агента,
# который выбирает столбцы случайным образом.

# 5) Подать заявку на участие в конкурсе
# А  теперь пора выставить агента на конкурс! Используйте следующую ячейку кода, чтобы определить агента. (Вы можете
# увидеть пример того, как написать действующего агента в этой записной книжке.)
#
# Если  вы решите использовать минимаксный код из учебника, вы можете добавить альфа-бета-обрезку, чтобы уменьшить
# время  вычислений (то есть заставить алгоритм минимакса работать намного быстрее!). В этом случае «альфа» и «бета»
# относятся  к двум значениям, которые поддерживаются во время работы алгоритма, что помогает идентифицировать
# условия ранней остановки.
#
# Без  обрезки альфа-бета минимакс оценивает каждый листовой узел. При отсечении альфа-бета минимакс оценивает только
# те  узлы, которые могут предоставить информацию, влияющую на выбор действия агента. Другими словами, он определяет
# узлы,  которые не могут повлиять на конечный результат, и избегает их оценки.

def my_agent(obs, config):
    # Your code here: Amend the agent!
    import random
    valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]
    return random.choice(valid_moves)

# subm
import inspect
import os

def write_agent_to_file(function, file):
    with open(file, "a" if os.path.exists(file) else "w") as f:
        f.write(inspect.getsource(function))
        print(function, "written to", file)

write_agent_to_file(my_agent, "submission.py")