# Linear Regression With Time Series

### Добро пожаловать в Time Series!
Прогнозирование — пожалуй, самое распространенное применение машинного обучения в реальном мире. Предприятия 
прогнозируют спрос на продукцию, правительства прогнозируют рост экономики и населения, метеорологи прогнозируют 
погоду. Понимание того, что грядет, является насущной потребностью в науке, правительстве и промышленности (не 
говоря уже о нашей личной жизни!), и практики в этих областях все чаще применяют машинное обучение для 
удовлетворения этой потребности.

Прогнозирование временных рядов — обширная область с долгой историей. Этот курс посвящен применению современных 
методов машинного обучения к данным временных рядов с целью получения наиболее точных прогнозов. Уроки этого курса 
были вдохновлены победными решениями прошлых соревнований по прогнозированию Kaggle, но будут применимы всякий раз, 
когда точные прогнозы являются приоритетом.

После окончания этого курса вы будете знать, как:

- инженерные функции для моделирования основных компонентов временных рядов (трендов, сезонов и циклов),
- визуализировать временные ряды с множеством видов графиков временных рядов,
- создавать гибриды прогнозирования, которые сочетают в себе сильные стороны дополнительных моделей, и
адаптировать методы машинного обучения к различным задачам прогнозирования.
- В рамках упражнений вы получите возможность принять участие в нашем конкурсе «Продажи в магазине — начало работы по 
  прогнозированию временных рядов». В этом конкурсе вам предстоит спрогнозировать продажи для корпорации Corporación 
  Favorita (крупного продуктового ритейлера из Эквадора) почти по 1800 товарным категориям. 

### Что такое временной ряд?
Основным объектом прогнозирования являются временные ряды, представляющие собой совокупность наблюдений, 
зарегистрированных во времени. В приложениях для прогнозирования наблюдения обычно записываются с регулярной 
периодичностью, например, ежедневно или ежемесячно.  
```python
import pandas as pd

df = pd.read_csv(
    "../input/ts-course-data/book_sales.csv",
    index_col='Date',
    parse_dates=['Date'],
).drop('Paperback', axis=1)

df.head()
```

```python
# Твердый переплет
# Дата
2000-04-01 139
2000-04-02 128
2000-04-03 172
2000-04-04 139
2000-04-05 191
```
Эта серия фиксирует количество продаж книг в твердом переплете в розничном магазине за 30 дней. Обратите внимание, 
что у нас есть один столбец наблюдений в твердом переплете с датой индекса времени. 

### Линейная регрессия с временными рядами
В первой части этого курса мы будем использовать алгоритм линейной регрессии для построения моделей прогнозирования. 
Линейная регрессия широко используется на практике и естественным образом адаптируется даже к сложным задачам 
прогнозирования.  

Алгоритм линейной регрессии учится делать взвешенную сумму из своих входных признаков. Для двух функций у нас будет:
```commandline
цель = вес_1 * признак_1 + вес_2 * признак_2 + смещение
```



Во время обучения алгоритм регрессии изучает значения параметров Weight_1, Weight_2 и смещения, которые лучше всего 
соответствуют цели. (Этот алгоритм часто называют обычным методом наименьших квадратов, так как он выбирает значения,
которые минимизируют квадрат ошибки между целью и предсказаниями.) Веса также называют коэффициентами регрессии, а 
смещение также называют точкой пересечения, потому что он говорит вам, где график этого функция пересекает ось Y.

### Функции временного шага
Есть два вида признаков, уникальных для временных рядов: признаки временного шага и признаки запаздывания.

Функции временного шага — это функции, которые мы можем получить непосредственно из временного индекса. Самая 
основная функция временного шага — это манекен времени, который отсчитывает временные шаги в ряду от начала до конца.  
```commandline
import numpy as np

df['Time'] = np.arange(len(df.index))

df.head()
```

```commandline
Время в твердом переплете
Дата
01.04.2000 139 0
2000-04-02 128 1
03.04.2000 172 2
04.04.2000 139 3
2000-04-05 191 4
```



Линейная регрессия с манекеном времени дает модель:
```commandline
цель = вес * время + погрешность
```

Затем манекен времени позволяет нам подогнать кривые к временным рядам на временном графике, где время образует ось x.
```python
import matplotlib.pyplot as plt
import seaborn as sns
plt.style.use("seaborn-whitegrid")
plt.rc(
    "figure",
    autolayout=True,
    figsize=(11, 4),
    titlesize=18,
    titleweight='bold',
)
plt.rc(
    "axes",
    labelweight="bold",
    labelsize="large",
    titleweight="bold",
    titlesize=16,
    titlepad=10,
)
%config InlineBackend.figure_format = 'retina'

fig, ax = plt.subplots()
ax.plot('Time', 'Hardcover', data=df, color='0.75')
ax = sns.regplot(x='Time', y='Hardcover', data=df, ci=None, scatter_kws=dict(color='0.25'))
ax.set_title('Time Plot of Hardcover Sales');
```

Функции временного шага позволяют моделировать временную зависимость. Ряд зависит от времени, если его значения 
можно предсказать по времени их возникновения. В серии «Продажи в твердом переплете» мы можем предсказать, что 
продажи в конце месяца, как правило, выше, чем продажи в начале месяца.   

### Особенности отставания
Чтобы создать запаздывающий признак, мы сдвигаем наблюдения целевого ряда так, чтобы они выглядели более поздними во 
времени. Здесь мы создали функцию отставания на 1 шаг, хотя возможно и смещение на несколько шагов. 

```python
df['Lag_1'] = df['Hardcover'].shift(1)
df = df.reindex(columns=['Hardcover', 'Lag_1'])

df.head()
```

```commandline
Отставание в твердом переплете_1
Дата
2000-04-01 139 NaN
2000-04-02 128 139,0
03.04.2000 172 128,0
04.04.2000 139 172,0
05.04.2000 191 139,0
```

Линейная регрессия с функцией запаздывания дает модель:

```commandline
цель = вес * отставание + смещение
```
Таким образом, функции запаздывания позволяют нам подгонять кривые к графикам запаздывания, где каждое наблюдение в 
серии отображается в сравнении с предыдущим наблюдением. 

```python
fig, ax = plt.subplots()
ax = sns.regplot(x='Lag_1', y='Hardcover', data=df, ci=None, scatter_kws=dict(color='0.25'))
ax.set_aspect('equal')
ax.set_title('Lag Plot of Hardcover Sales');
```

На графике запаздывания видно, что продажи за один день (в твердом переплете) коррелируют с продажами за предыдущий 
день (Запаздывание_1). Когда вы видите такие отношения, вы знаете, что функция задержки будет полезна. 

В более общем плане функции запаздывания позволяют моделировать последовательную зависимость. Временной ряд имеет 
последовательную зависимость, когда наблюдение можно предсказать на основе предыдущих наблюдений. В продажах в 
твердом переплете мы можем предсказать, что высокие продажи в один день обычно означают высокие продажи на следующий 
день.   

Адаптация алгоритмов машинного обучения к проблемам временных рядов в значительной степени связана с разработкой 
признаков с временным индексом и задержками. В большей части курса мы используем линейную регрессию из-за ее простоты. 
 но эти функции будут полезны независимо от того, какой алгоритм вы выберете для своей задачи прогнозирования.

### Пример — туннельный трафик
Туннельный трафик — это временной ряд, описывающий количество транспортных средств, проезжающих через туннель Барегг 
в Швейцарии каждый день с ноября 2003 г. по ноябрь 2005 г. В этом примере мы попрактикуемся в применении линейной 
регрессии к функциям временного шага и функциям запаздывания.  
```python
from pathlib import Path
from warnings import simplefilter

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

simplefilter("ignore")  # ignore warnings to clean up output cells

# Set Matplotlib defaults
plt.style.use("seaborn-whitegrid")
plt.rc("figure", autolayout=True, figsize=(11, 4))
plt.rc(
    "axes",
    labelweight="bold",
    labelsize="large",
    titleweight="bold",
    titlesize=14,
    titlepad=10,
)
plot_params = dict(
    color="0.75",
    style=".-",
    markeredgecolor="0.25",
    markerfacecolor="0.25",
    legend=False,
)
%config InlineBackend.figure_format = 'retina'


# Load Tunnel Traffic dataset
data_dir = Path("../input/ts-course-data")
tunnel = pd.read_csv(data_dir / "tunnel.csv", parse_dates=["Day"])

# Create a time series in Pandas by setting the index to a date
# column. We parsed "Day" as a date type by using `parse_dates` when
# loading the data.
tunnel = tunnel.set_index("Day")

# By default, Pandas creates a `DatetimeIndex` with dtype `Timestamp`
# (equivalent to `np.datetime64`, representing a time series as a
# sequence of measurements taken at single moments. A `PeriodIndex`,
# on the other hand, represents a time series as a sequence of
# quantities accumulated over periods of time. Periods are often
# easier to work with, so that's what we'll use in this course.
tunnel = tunnel.to_period()

tunnel.head()
```

Скрытая ячейка настраивает все.
```commandline
NumТранспортные средства
День
2003-11-01 103536
2003-11-02 92051
2003-11-03 100795
2003-11-04 102352
2003-11-05 106569
```

### Функция временного шага
При условии, что во временном ряду нет пропущенных дат, мы можем создать временной манекен, посчитав длину ряда.
```python
df = tunnel.copy()

df['Time'] = np.arange(len(tunnel.index))

df.head()
```
```commandline
Количество транспортных средств Время
День
01.11.2003 103536 0
2003-11-02 92051 1
03.11.2003 100795 2
2003-11-04 102352 3
05.11.2003 106569 4
```

Процедура подбора модели линейной регрессии следует стандартным шагам scikit-learn.

из sklearn.linear_model импортировать линейную регрессию
```python
from sklearn.linear_model import LinearRegression

# Тренировочные данные
X = df.loc[:, ['Time']]  # features
y = df.loc[:, 'NumVehicles']  # target

# Обучить модель
model = LinearRegression()
model.fit(X, y)

# Сохраняем подобранные значения как временной ряд с тем же временным индексом, что и
# обучающие данные
y_pred = pd.Series(model.predict(X), index=X.index)
```

Фактически созданная модель (приблизительно): Транспортные средства = 22,5 * Время + 98176. График сопоставленных 
значений с течением времени показывает нам, как подгонка линейной регрессии к временному манекену создает линию 
тренда, определяемую этим уравнением.   
```python
ax = y.plot(**plot_params)
ax = y_pred.plot(ax=ax, linewidth=3)
ax.set_title('Time Plot of Tunnel Traffic');
```

### Функция задержки
Pandas предоставляет нам простой метод отставания серии, метод сдвига.

```python
df['Lag_1'] = df['NumVehicles'].shift(1)
df.head()
```
```commandline
NumVehicles Time Lag_1
День
01.11.2003 103536 0 NaN
2003-11-02 92051 1 103536.0
03.11.2003 100795 2 92051.0
04.11.2003 102352 3 100795.0
05.11.2003 106569 4 102352.0
```


При создании запаздывающих функций нам нужно решить, что делать с полученными отсутствующими значениями. Заполнение 
их - это один из вариантов, возможно, с 0,0 или «обратным заполнением» с первым известным значением. Вместо этого мы 
просто отбросим отсутствующие значения, убедившись, что также отбросим значения в цели с соответствующими датами.   

из sklearn.linear_model импортировать линейную регрессию

```python
from sklearn.linear_model import LinearRegression

X = df.loc[:, ['Lag_1']]
X.dropna(inplace=True)  # drop missing values in the feature set
y = df.loc[:, 'NumVehicles']  # create the target
y, X = y.align(X, join='inner')  # drop corresponding values in target

model = LinearRegression()
model.fit(X, y)

y_pred = pd.Series(model.predict(X), index=X.index)
```
График запаздывания показывает нам, насколько хорошо мы смогли установить соотношение между количеством транспортных 
средств за один день и их количеством в предыдущий день.  
```python
fig, ax = plt.subplots()
ax.plot(X['Lag_1'], y, '.', color='0.25')
ax.plot(X['Lag_1'], y_pred)
ax.set_aspect('equal')
ax.set_ylabel('NumVehicles')
ax.set_xlabel('Lag_1')
ax.set_title('Lag Plot of Tunnel Traffic');
```

Что это предсказание по признаку запаздывания означает, насколько хорошо мы можем предсказать ряд во времени? 
Следующий временной график показывает нам, как наши прогнозы теперь реагируют на поведение ряда в недавнем прошлом. 
```python
ax = y.plot(**plot_params)
ax = y_pred.plot()
```

Лучшие модели временных рядов обычно включают некоторую комбинацию функций временного шага и функций запаздывания. В 
течение следующих нескольких уроков мы узнаем, как проектировать функции, моделирующие наиболее распространенные 
шаблоны во временных рядах, используя функции из этого урока в качестве отправной точки.   