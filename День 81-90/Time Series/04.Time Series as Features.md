# Time Series as Features
### Что такое последовательная зависимость?
На предыдущих уроках мы исследовали свойства временных рядов, которые проще всего моделировать как свойства, 
зависящие от времени, то есть с признаками, которые мы могли получить непосредственно из временного индекса. Однако 
некоторые свойства временных рядов можно моделировать только как последовательно зависимые свойства, то есть 
используя в качестве признаков прошлые значения целевого ряда. Структура этих временных рядов может быть не очевидна 
на графике с течением времени; однако на графике по сравнению с прошлыми значениями структура становится ясной, как 
мы видим на рисунке ниже.     


Эти два ряда имеют последовательную зависимость, но не зависимость от времени. Точки справа имеют координаты 
(значение во время t-1, значение во время t). 
С помощью тренда и сезонности мы обучили модели подгонять кривые к графикам, подобным тем, что слева на рисунке выше 
— модели изучали зависимость от времени. Цель этого урока — научить модели подгонять кривые к графикам, подобным тем,
что справа — мы хотим, чтобы они научились последовательной зависимости.   

### Циклы
Одним из наиболее распространенных способов проявления последовательной зависимости являются циклы. Циклы — это 
закономерности роста и спада во временном ряду, связанные с тем, как значение в ряду в определенный момент времени 
зависит от значений в предыдущие моменты времени, но не обязательно от самого временного шага. Циклическое поведение 
характерно для систем, которые могут воздействовать на самих себя или чьи реакции сохраняются во времени. Экономика, 
эпидемии, популяции животных, извержения вулканов и подобные природные явления часто демонстрируют циклическое поведение.    


### Четыре временных ряда с циклическим поведением.
Что отличает циклическое поведение от сезонности, так это то, что циклы не обязательно зависят от времени, как 
сезоны. То, что происходит в цикле, связано не столько с конкретной датой возникновения, сколько с тем, что 
произошло в недавнем прошлом. Независимость (по крайней мере, относительная) от времени означает, что циклическое 
поведение может быть гораздо более нерегулярным, чем сезонность.   

### Запаздывающие серии и запаздывающие графики
Чтобы исследовать возможную последовательную зависимость (например, циклы) во временном ряду, нам нужно создать 
«запаздывающие» копии ряда. Отставание временного ряда означает смещение его значений вперед на один или несколько 
временных шагов или, что то же самое, смещение времени в его индексе назад на один или несколько шагов. В любом 
случае эффект заключается в том, что наблюдения в запаздывающих рядах, по-видимому, произошли позже во времени.   

Это показывает месячный уровень безработицы в США (y) вместе с его первым и вторым лаговыми рядами (y_lag_1 и 
y_lag_2 соответственно). Обратите внимание, как значения лагированного ряда сдвинуты вперед во времени. 
```python
import pandas as pd

# Federal Reserve dataset: https://www.kaggle.com/federalreserve/interest-rates
reserve = pd.read_csv(
    "../input/ts-course-data/reserve.csv",
    parse_dates={'Date': ['Year', 'Month', 'Day']},
    index_col='Date',
)

y = reserve.loc[:, 'Unemployment Rate'].dropna().to_period('M')
df = pd.DataFrame({
    'y': y,
    'y_lag_1': y.shift(1),
    'y_lag_2': y.shift(2),    
})

df.head()
```

```commandline
y y_lag_1 y_lag_2
Дата
1954-07 5,8 NaN NaN
1954-08 6,0 5,8 NaN
1954-09 6,1 6,0 5,8
1954-10 5,7 6,1 6,0
1954-11 5,3 5,7 6,1
```


Запаздывая временной ряд, мы можем заставить его прошлые значения выглядеть одновременно со значениями, которые мы 
пытаемся предсказать (другими словами, в той же строке). Это делает запаздывающие ряды полезными в качестве 
признаков для моделирования последовательной зависимости. Чтобы спрогнозировать ряд показателей уровня безработицы в 
США, мы могли бы использовать y_lag_1 и y_lag_2 в качестве признаков для прогнозирования целевого значения y. Это 
позволит прогнозировать будущий уровень безработицы в зависимости от уровня безработицы за предыдущие два месяца.    

### Графики отставания
График запаздывания временного ряда показывает его значения в зависимости от запаздывания. Последовательная 
зависимость во временном ряду часто становится очевидной, если взглянуть на график запаздывания. Из этого 
лаг-графика безработицы в США видно, что между текущим уровнем безработицы и прошлыми уровнями существует сильная и 
явно линейная зависимость.    


### Запаздывающий график безработицы в США с указанием автокорреляции.
Наиболее часто используемая мера последовательной зависимости известна как автокорреляция, которая представляет собой просто корреляцию временного ряда с одним из его лагов. Безработица в США имеет автокорреляцию 0,99 при лаге 1, 0,98 при лаге 2 и так далее.

### Выбор лагов
При выборе лагов для использования в качестве признаков обычно нецелесообразно включать каждое лаг с большой 
автокорреляцией. Например, в отчете по безработице в США автокорреляция при лаге 2 может быть полностью результатом 
«затухающей» информации из лага 1 — просто корреляция, перенесенная с предыдущего шага. Если лаг 2 не содержит 
ничего нового, то нет смысла его включать, если у нас уже есть лаг 1.   

Частичная автокорреляция сообщает вам корреляцию задержки с учетом всех предыдущих задержек — так сказать, 
количество «новой» корреляции, которую вносит задержка. Построение графика частичной автокорреляции может помочь вам 
выбрать, какие функции задержки использовать. На приведенном ниже рисунке отставание от 1 до отставания 6 не 
попадает в интервалы «отсутствия корреляции» (обозначены синим цветом), поэтому мы можем выбрать отставание от 1 до 
6 в качестве характеристик для безработицы в США. (Задержка 11, вероятно, является ложным срабатыванием.)    


Частичные автокорреляции безработицы в США через лаг 12 с 95% доверительными интервалами отсутствия корреляции.
График, подобный приведенному выше, называется коррелограммой. Коррелограмма для признаков с отставанием по существу 
аналогична периодограмме для признаков Фурье. 

Наконец, мы должны помнить, что автокорреляция и частичная автокорреляция являются мерами линейности.

зависимость. Поскольку временные ряды реального мира часто имеют существенные нелинейные зависимости, при выборе признаков запаздывания лучше всего смотреть на график запаздывания (или использовать какую-либо более общую меру зависимости, например, взаимную информацию). Ряд солнечных пятен имеет лаги с нелинейной зависимостью, которые мы можем не заметить при автокорреляции.


Отставание сюжета сериала «Солнечные пятна».
Подобные нелинейные отношения можно либо преобразовать в линейные, либо изучить с помощью соответствующего алгоритма.

### Пример — тенденции гриппа
Набор данных Flu Trends содержит записи о посещениях врача по поводу гриппа за несколько недель с 2009 по 2016 год. 
Наша цель — спрогнозировать количество случаев заболевания гриппом на ближайшие недели. 

Мы сделаем два подхода. В первом мы будем прогнозировать визиты к врачу, используя лаг-функции. Наш второй подход 
будет заключаться в прогнозировании посещений врача с использованием лагов другого набора временных рядов: поисковых 
запросов, связанных с гриппом, согласно Google Trends.  
```python
from pathlib import Path
from warnings import simplefilter

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy.signal import periodogram
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from statsmodels.graphics.tsaplots import plot_pacf

simplefilter("ignore")

# Set Matplotlib defaults
plt.style.use("seaborn-whitegrid")
plt.rc("figure", autolayout=True, figsize=(11, 4))
plt.rc(
    "axes",
    labelweight="bold",
    labelsize="large",
    titleweight="bold",
    titlesize=16,
    titlepad=10,
)
plot_params = dict(
    color="0.75",
    style=".-",
    markeredgecolor="0.25",
    markerfacecolor="0.25",
)
%config InlineBackend.figure_format = 'retina'


def lagplot(x, y=None, lag=1, standardize=False, ax=None, **kwargs):
    from matplotlib.offsetbox import AnchoredText
    x_ = x.shift(lag)
    if standardize:
        x_ = (x_ - x_.mean()) / x_.std()
    if y is not None:
        y_ = (y - y.mean()) / y.std() if standardize else y
    else:
        y_ = x
    corr = y_.corr(x_)
    if ax is None:
        fig, ax = plt.subplots()
    scatter_kws = dict(
        alpha=0.75,
        s=3,
    )
    line_kws = dict(color='C3', )
    ax = sns.regplot(x=x_,
                     y=y_,
                     scatter_kws=scatter_kws,
                     line_kws=line_kws,
                     lowess=True,
                     ax=ax,
                     **kwargs)
    at = AnchoredText(
        f"{corr:.2f}",
        prop=dict(size="large"),
        frameon=True,
        loc="upper left",
    )
    at.patch.set_boxstyle("square, pad=0.0")
    ax.add_artist(at)
    ax.set(title=f"Lag {lag}", xlabel=x_.name, ylabel=y_.name)
    return ax


def plot_lags(x, y=None, lags=6, nrows=1, lagplot_kwargs={}, **kwargs):
    import math
    kwargs.setdefault('nrows', nrows)
    kwargs.setdefault('ncols', math.ceil(lags / nrows))
    kwargs.setdefault('figsize', (kwargs['ncols'] * 2, nrows * 2 + 0.5))
    fig, axs = plt.subplots(sharex=True, sharey=True, squeeze=False, **kwargs)
    for ax, k in zip(fig.get_axes(), range(kwargs['nrows'] * kwargs['ncols'])):
        if k + 1 <= lags:
            ax = lagplot(x, y, lag=k + 1, ax=ax, **lagplot_kwargs)
            ax.set_title(f"Lag {k + 1}", fontdict=dict(fontsize=14))
            ax.set(xlabel="", ylabel="")
        else:
            ax.axis('off')
    plt.setp(axs[-1, :], xlabel=x.name)
    plt.setp(axs[:, 0], ylabel=y.name if y is not None else x.name)
    fig.tight_layout(w_pad=0.1, h_pad=0.1)
    return fig


data_dir = Path("../input/ts-course-data")
flu_trends = pd.read_csv(data_dir / "flu-trends.csv")
flu_trends.set_index(
    pd.PeriodIndex(flu_trends.Week, freq="W"),
    inplace=True,
)
flu_trends.drop("Week", axis=1, inplace=True)

ax = flu_trends.FluVisits.plot(title='Flu Trends', **plot_params)
_ = ax.set(ylabel="Office Visits")
```

Наши данные Flu Trends показывают нерегулярные циклы, а не регулярную сезонность: пик, как правило, приходится на 
новый год, но иногда раньше или позже, иногда больше или меньше. Моделирование этих циклов с запаздыванием позволит 
нашему прогнозисту динамически реагировать на меняющиеся условия, а не ограничиваться точными датами и временем, как 
в случае с сезонными особенностями.   

Давайте сначала посмотрим на графики задержки и автокорреляции:

```python
_ = plot_lags(flu_trends.FluVisits, lags=12, nrows=2)
_ = plot_pacf(flu_trends.FluVisits, lags=12)
```


Графики запаздывания показывают, что отношение FluVisits к его задержкам в основном линейное, в то время как 
частичные автокорреляции предполагают, что зависимость может быть зафиксирована с использованием задержек 1, 2, 3 и 
4. Мы можем отложить временной ряд в Pandas с помощью метода сдвига. Для этой проблемы мы заполним недостающие 
   значения, создаваемые отставанием, с помощью 0,0.   
```python
def make_lags(ts, lags):
    return pd.concat(
        {
            f'y_lag_{i}': ts.shift(i)
            for i in range(1, lags + 1)
        },
        axis=1)


X = make_lags(flu_trends.FluVisits, lags=4)
X = X.fillna(0.0)
```
На предыдущих уроках мы могли создавать прогнозы для любого количества шагов, помимо обучающих данных. Однако при 
использовании запаздывающих функций мы ограничены прогнозированием временных шагов, для которых доступны 
запаздывающие значения. Используя функцию запаздывания 1 в понедельник, мы не можем сделать прогноз на среду, потому 
что необходимое значение запаздывания 1 — это вторник, которого еще не произошло.   

Мы рассмотрим стратегии решения этой проблемы в Уроке 6. В этом примере мы просто используем значения из тестового набора.
```python
# Create target series and data splits
y = flu_trends.FluVisits.copy()
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=60, shuffle=False)

# Fit and predict
model = LinearRegression()  # `fit_intercept=True` since we didn't use DeterministicProcess
model.fit(X_train, y_train)
y_pred = pd.Series(model.predict(X_train), index=y_train.index)
y_fore = pd.Series(model.predict(X_test), index=y_test.index)
```
```python
ax = y_train.plot(**plot_params)
ax = y_test.plot(**plot_params)
ax = y_pred.plot(ax=ax)
_ = y_fore.plot(ax=ax, color='C3')
```
Глядя только на прогнозные значения, мы видим, как нашей модели нужен временной шаг, чтобы реагировать на внезапные 
изменения в целевом ряду. Это обычное ограничение моделей, использующих в качестве признаков только лаги целевого 
ряда.  

```python
ax = y_test.plot(**plot_params)
_ = y_fore.plot(ax=ax, color='C3')
```

Чтобы улучшить прогноз, мы могли бы попытаться найти опережающие индикаторы, временные ряды, которые могли бы 
обеспечить «раннее предупреждение» об изменениях в заболеваемости гриппом. Для нашего второго подхода мы добавим к 
нашим обучающим данным популярность некоторых поисковых запросов, связанных с гриппом, согласно данным Google Trends.   

Сопоставление поисковой фразы «FluCough» с целью «FluVisits» предполагает, что такие поисковые термины могут быть 
полезны в качестве опережающих индикаторов: поисковые запросы, связанные с гриппом, как правило, становятся более 
популярными за несколько недель до посещения офиса.  
```python
ax = flu_trends.plot(
    y=["FluCough", "FluVisits"],
    secondary_y="FluCough",
)
```

Набор данных содержит 129 таких терминов, но мы будем использовать только некоторые из них.
```python
search_terms = ["FluContagious", "FluCough", "FluFever", "InfluenzaA", "TreatFlu", "IHaveTheFlu", "OverTheCounterFlu", "HowLongFlu"]

# Create three lags for each search term
X0 = make_lags(flu_trends[search_terms], lags=3)

# Create four lags for the target, as before
X1 = make_lags(flu_trends['FluVisits'], lags=4)

# Combine to create the training data
X = pd.concat([X0, X1], axis=1).fillna(0.0)
```
```python
search_terms = ["ГриппКонтагиозный", "ГриппКашель", "ГриппЛихорадка", "ГриппАА", "ЛечениеГриппа", "ЯБолеюГрипп",
"ВнебиржевойГрипп","КакДлительныйГрипп"] 

# Создайте три задержки для каждого поискового запроса
X0 = make_lags(flu_trends[search_terms], lags=3)

# Создаем четыре лага для таргета, как и раньше
X1 = make_lags(flu_trends['FluVisits'], lags=4)

# Объединить для создания обучающих данных
X = pd.concat([X0, X1], ось=1).fillna(0.0)
```



Наши прогнозы немного более приблизительны, но наша модель, похоже, лучше способна предвидеть внезапное увеличение 
числа посещений в связи с гриппом, предполагая, что несколько временных рядов популярности поиска действительно были 
эффективными в качестве опережающих индикаторов.   
```python
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=60, shuffle=False)

model = LinearRegression()
model.fit(X_train, y_train)
y_pred = pd.Series(model.predict(X_train), index=y_train.index)
y_fore = pd.Series(model.predict(X_test), index=y_test.index)

ax = y_test.plot(**plot_params)
_ = y_fore.plot(ax=ax, color='C3')
```

Временные ряды, показанные в этом уроке, можно назвать «чисто циклическими»: они не имеют явного тренда или 
сезонности. Однако временные ряды нередко обладают трендом, сезонностью и циклами — всеми тремя компонентами 
одновременно. Вы можете моделировать такие ряды с помощью линейной регрессии, просто добавляя соответствующие 
функции для каждого компонента. Вы даже можете комбинировать модели, обученные изучать компоненты по отдельности, 
что мы научимся делать на следующем уроке с гибридами прогнозирования.    